<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>catalinaLi&#39;s Notes</title>
  <subtitle>Rooookie</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://catalinali.top/"/>
  <updated>2018-11-12T06:41:52.947Z</updated>
  <id>http://catalinali.top/</id>
  
  <author>
    <name>从不装逼夫斯基</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA并发编程(七)：并发容器（ConcurrentHashMap）</title>
    <link href="http://catalinali.top/2018/knowConHashMap/"/>
    <id>http://catalinali.top/2018/knowConHashMap/</id>
    <published>2018-10-23T02:27:00.000Z</published>
    <updated>2018-11-12T06:41:52.947Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-894019d64cfb767f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>我们上节讲了HashMap，实际上HashMap并不是线程安全的，在并发插入元素的时候有可能出现环形链表，让下一次读操作出现死循环。解决的办法就是使用线程安全的容器，除了Collections提供的synchronizedMap同步容器外，实际上我们还可以选择性能更好的juc提供的同步容器。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、分段锁Segment概述"><a href="#一、分段锁Segment概述" class="headerlink" title="一、分段锁Segment概述"></a>一、分段锁Segment概述</h2><p>分段锁Segment是ConcurrentHashMap很重要的一个概念。</p>
<p>Segment本身就相当于一个HashMap对象。</p>
<p>同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。</p>
<p>像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。<br>因此整个ConcurrentHashMap的结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3962292-74587e0c863b9eaa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ConHashMap_1"></p>
<p>可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。<br>这样的二级结构，和数据库的水平拆分有些相似。每一个Segment就好比一个高度自治的自治区。读写高度自治，Segment之间互不影响。</p>
<p>这种结构下的ConcurrentHashMap有以下特点：</p>
<ul>
<li>不同Segment的写入是可以并发执行的。</li>
<li>同一Segment的写和读是可以并发执行的。</li>
<li>对同一Segment的并发写入会被阻塞。</li>
</ul>
<p>由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p>
<h2 id="二、ConcurrentHashMap读写概述"><a href="#二、ConcurrentHashMap读写概述" class="headerlink" title="二、ConcurrentHashMap读写概述"></a>二、ConcurrentHashMap读写概述</h2><p>###Get方法：</p>
<p>1.为输入的Key做Hash运算，得到hash值。<br>2.通过hash值，定位到对应的Segment对象<br>3.再次通过hash值，定位到Segment当中数组的具体位置。</p>
<p>###Put方法：</p>
<p>1.为输入的Key做Hash运算，得到hash值。<br>2.通过hash值，定位到对应的Segment对象<br>3.获取可重入锁<br>4.再次通过hash值，定位到Segment当中数组的具体位置。<br>5.插入或覆盖HashEntry对象。<br>6.释放锁。</p>
<p>从以上步骤可以看出，ConcurrentHashMap在读写时都需要两次定位（Hash）操作。</p>
<h2 id="三、ConcurrentHashMap的size-方法"><a href="#三、ConcurrentHashMap的size-方法" class="headerlink" title="三、ConcurrentHashMap的size()方法"></a>三、ConcurrentHashMap的size()方法</h2><p>Size方法的目的是统计ConcurrentHashMap的总元素数量， 自然需要把各个Segment内部的元素数量汇总起来。</p>
<p>但是，如果在统计Segment元素数量的过程中，已统计过的Segment瞬间插入新的元素，这时候该怎么办呢？</p>
<p>ConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：</p>
<p>1.遍历所有的Segment。<br>2.把Segment的元素数量累加起来。<br>3.把Segment的修改次数累加起来。<br>4.判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。<br>5.如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。<br>6.再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。<br>7.释放锁，统计结束。</p>
<p>这种思想和乐观锁悲观锁的思想如出一辙。</p>
<p>为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/1yWSfdz0j-PprGkDgOomhQ" target="_blank" rel="noopener">什么是ConcurrentHashMap</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/knowConHashMap/">http://catalinali.top/2018/knowConHashMap/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-894019d64cfb767f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们上节讲了HashMap，实际上HashMap并不是线程安全的，在并发插入元素的时候有可能出现环形链表，让下一次读操作出现死循环。解决的办法就是使用线程安全的容器，除了Collections提供的synchronizedMap同步容器外，实际上我们还可以选择性能更好的juc提供的同步容器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="juc" scheme="http://catalinali.top/categories/juc/"/>
    
    
      <category term="juc" scheme="http://catalinali.top/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>深入理解HashMap</title>
    <link href="http://catalinali.top/2018/knowHashMap/"/>
    <id>http://catalinali.top/2018/knowHashMap/</id>
    <published>2018-10-19T01:46:26.000Z</published>
    <updated>2018-11-12T06:41:38.833Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-12e9899d89e68f47.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis_logo"></p>
<blockquote>
<p>HashMap是我们使用非常多的Collection,它是基于哈希表的 Map 接口的实现,以key-value的形式存在。今天我们来深入了解一下这个集合的底层原理。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3962292-9586406d9946c776.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hashmap_logo"></p>
<p>这个数组在首次使用时进行初始化，每一个元素的初始值都是Null。<br>为了了解它，我们从Put方法个Get方法来进行阐述。</p>
<h2 id="一、Put方法的原理"><a href="#一、Put方法的原理" class="headerlink" title="一、Put方法的原理"></a>一、Put方法的原理</h2><p>HashMap在调用put方法时会先根据Key值来进行哈希运算来得到结果，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index =  Hash（“Key”）</span><br></pre></td></tr></table></figure></p>
<p>假如计算出的index是2，那么就会将它放入index为2的位置，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3962292-51863fe255a6985b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hashmap_2"></p>
<p>但是再完美的Hash函数也难免会出现index冲突的情况。比如下面这样。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-7cada083ed007cca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hashmap_3"><br>这时候我们就可以使用<strong>链表</strong>来解决</p>
<p>HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：<br><img src="http://upload-images.jianshu.io/upload_images/3962292-4509c3909ad70d4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hashmap_4"><br>需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。<br>所以一个完整的HashMap样子应该是这样的<br><img src="http://upload-images.jianshu.io/upload_images/3962292-2361da42619ca5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hashmap_5"></p>
<h2 id="二、Get方法的原理"><a href="#二、Get方法的原理" class="headerlink" title="二、Get方法的原理"></a>二、Get方法的原理</h2><p>使用Get方法根据Key来查找Value的时候，发生了什么呢？</p>
<p>首先会把输入的Key做一次Hash映射，得到对应的index：</p>
<p>index =  Hash（“apple”）</p>
<p>由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：<br><img src="http://upload-images.jianshu.io/upload_images/3962292-500ba5fdf4ea01ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hashmap_6"><br>第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。</p>
<p>第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。</p>
<p>之所以把Entry6放在头节点，是因为HashMap的发明者认为，<strong>后插入的Entry被查找的可能性更大</strong>。</p>
<h2 id="三、哈希方法"><a href="#三、哈希方法" class="headerlink" title="三、哈希方法"></a>三、哈希方法</h2><p>如何实现一个尽量均匀分布的Hash函数呢？我们通过利用Key的HashCode值来做某种运算。具体公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index =  HashCode（Key） &amp;  （Length - 1）</span><br></pre></td></tr></table></figure></p>
<p>从公式中我们可以看到运用了HashMap的长度。那么它的长度是多少呢？答案是16。因为这个数字可以尽量避免哈希碰撞，减少相同index的几率。如果你不相信的话，换个别的数字试试？</p>
<h2 id="四、HashMap的扩容"><a href="#四、HashMap的扩容" class="headerlink" title="四、HashMap的扩容"></a>四、HashMap的扩容</h2><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。</p>
<p>这时候，HashMap需要扩展它的长度，也就是进行Resize。</p>
<p>影响发生Resize的因素有两个：</p>
<p>1.Capacity<br>HashMap的当前长度。上一期曾经说过，HashMap的长度是2的幂。<br>2.LoadFactor<br>HashMap负载因子，默认值为0.75f。</p>
<p>衡量HashMap是否进行Resize的条件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap.Size   &gt;=  Capacity * LoadFactor</span><br></pre></td></tr></table></figure></p>
<p><strong>1.扩容</strong><br>创建一个新的Entry空数组，长度是原数组的2倍。</p>
<p><strong>2.ReHash</strong><br>遍历原Entry数组，把所有的Entry重新Hash到新数组。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。</p>
<p>让我们回顾一下Hash公式：<br>index =  HashCode（Key） &amp;  （Length - 1） </p>
<p>当原数组长度为8时，Hash运算是和111B做与运算；新数组长度为16，Hash运算是和1111B做与运算。Hash结果显然不同。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s/HzRH9ZJYmidzW5jrMvEi4w" target="_blank" rel="noopener">漫画：什么是HashMap？</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/knowHashMap/">http://catalinali.top/2018/knowHashMap/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-12e9899d89e68f47.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;redis_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HashMap是我们使用非常多的Collection,它是基于哈希表的 Map 接口的实现,以key-value的形式存在。今天我们来深入了解一下这个集合的底层原理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HashMap" scheme="http://catalinali.top/categories/HashMap/"/>
    
    
      <category term="HashMap" scheme="http://catalinali.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之单例模式的究极版写法</title>
    <link href="http://catalinali.top/2018/singletonPattern/"/>
    <id>http://catalinali.top/2018/singletonPattern/</id>
    <published>2018-10-11T01:29:06.000Z</published>
    <updated>2018-11-12T06:51:32.964Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-acac6f7616985e72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis_logo"></p>
<blockquote>
<p>单例模式可能是后端学习者接触到的第一种设计模式，可是单例模式真的有那么简单吗？在并发模式下会出现什么样的问题？在学习了前面的并发知识后，我们来看看究极版的单例模式应该怎么写。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="一、单例模式第一版"><a href="#一、单例模式第一版" class="headerlink" title="一、单例模式第一版"></a>一、单例模式第一版</h2><p>我们最初接触到的单例模式一般就是懒汉模式与饿汉模式。我们先来看看怎么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  <span class="comment">//单例对象</span></span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  <span class="comment">//单例对象</span></span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Signleton的构造方法是私有的。</p>
</li>
<li><p>instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。</p>
</li>
<li><p>getInstance是获取单例对象的方法。</p>
</li>
</ul>
<p>这两个名字很形象：饿汉主动找食物吃，懒汉躺在地上等着人喂。<br>1、饿汉式：在程序启动或单件模式类被加载的时候，单件模式实例就已经被创建。<br>2、懒汉式：当程序第一次访问单件模式实例时才进行创建。</p>
<p>懒汉模式加载快执行慢，但是有线程安全问题，容易引起不同步问题，所以应该创建同步”锁”。</p>
<h2 id="二、单例模式第二版"><a href="#二、单例模式第二版" class="headerlink" title="二、单例模式第二版"></a>二、单例模式第二版</h2><p>懒汉模式的线程安全问题主要在<code>if (instance == null)</code>这句判断是否为空上。在多线程的环境下，可能有多个线程同时通过这个判断。这样一来，就有可能同时创建多个实例。让我们来对代码做一下修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//私有构造函数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  <span class="comment">//单例对象</span></span><br><span class="line">   <span class="comment">//静态工厂方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;      <span class="comment">//双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     <span class="comment">//双重检测机制</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。</p>
</li>
<li><p>进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</p>
</li>
</ul>
<p>然而，这种方法也有一定的缺席。</p>
<h2 id="三、单例模式第三版"><a href="#三、单例模式第三版" class="headerlink" title="三、单例模式第三版"></a>三、单例模式第三版</h2><p>假设这样的场景，当两个线程一先一后访问getInstance方法的时候，当A线程正在构建对象，B线程刚刚进入方法。</p>
<p>这种情况表面看似没什么问题，要么Instance还没被线程A构建，线程B执行 if（instance == null）的时候得到true；要么Instance已经被线程A构建完成，线程B执行 if（instance == null）的时候得到false。</p>
<p>我们之前在<a href="http://catalinali.top/2018/helloVolatile/">JAVA并发编程(一)：理解volatile关键字</a>学习过<strong>指令重排</strong>的知识，<code>instance = new Singleton()</code>这个操作不是一个原子操作，它在执行的时候要经历以下三个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间 </span><br><span class="line">ctorInstance(memory);  //2：初始化对象 </span><br><span class="line">instance =memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>
<p>所以这里有可能出现如下情况：</p>
<p>当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行  if（instance == null）的结果会是false，从而返回一个没有初始化完成的instance对象。</p>
<p>如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符volatile。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;  //私有构造函数</span><br><span class="line">    private volatile static Singleton instance = null;  //单例对象</span><br><span class="line">    //静态工厂方法</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">          if (instance == null) &#123;      //双重检测机制</span><br><span class="line">         synchronized (Singleton.class)&#123;  //同步锁</span><br><span class="line">           if (instance == null) &#123;     //双重检测机制</span><br><span class="line">             instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return instance;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、其他方式实现单例模式"><a href="#三、其他方式实现单例模式" class="headerlink" title="三、其他方式实现单例模式"></a>三、其他方式实现单例模式</h2><p>实现单例模式的手段还有很多，我们再来看一些别的实现方式。</p>
<h3 id="①静态内部类实现单例模式"><a href="#①静态内部类实现单例模式" class="headerlink" title="①静态内部类实现单例模式"></a>①静态内部类实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li><p>从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。</p>
</li>
<li><p>INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。</p>
</li>
<li><p>静态内部类与饿汉&amp;懒汉模式存在共同的问题:无法防止利用反射来重复构建对象。</p>
</li>
</ul>
<h3 id="②枚举实现单例模式"><a href="#②枚举实现单例模式" class="headerlink" title="②枚举实现单例模式"></a>②枚举实现单例模式</h3><p>可以防止反射的无懈可击的单例模式代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用枚举实现的单例模式不仅能够防止反射构造对象，而且可以保证线程安全。不过这种方式也有一个缺点，那就是不能实现懒加载，它的单例模式是在枚举类被加载的时候进行初始化的。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s/2UYXNzgTCEZdEfuGIbcczA" target="_blank" rel="noopener">漫画：什么是单例模式？</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/singletonPattern/">http://catalinali.top/2018/singletonPattern/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-acac6f7616985e72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;redis_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单例模式可能是后端学习者接触到的第一种设计模式，可是单例模式真的有那么简单吗？在并发模式下会出现什么样的问题？在学习了前面的并发知识后，我们来看看究极版的单例模式应该怎么写。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="design-patterns" scheme="http://catalinali.top/categories/design-patterns/"/>
    
    
      <category term="design-patterns" scheme="http://catalinali.top/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>解析Vue.js的MVVM模式</title>
    <link href="http://catalinali.top/2018/getMVVM/"/>
    <id>http://catalinali.top/2018/getMVVM/</id>
    <published>2018-08-31T03:44:06.000Z</published>
    <updated>2018-11-12T06:44:56.481Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-2a81793926834d13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getMVVM_logo"></p>
<blockquote>
<p>近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="一、MVP模式"><a href="#一、MVP模式" class="headerlink" title="一、MVP模式"></a>一、MVP模式</h2><p>我们以前使用JQuery操作Dom的模式就是遵循了MVP模式,我们来看一下MVP模式的图示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3962292-162fe3b8fcc01f81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getMVVM_1"></p>
<ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Presenter）：业务逻辑</li>
<li>模型（Model）：数据保存</li>
</ul>
<p>MVP有以下特点：</p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<p>在我们常规的DOM操作中，Model层的数据一般通过AJAX获取，Presenter层通常就是我们的js逻辑而相应的View就是我们用户看到的界面。</p>
<h2 id="二、MVVM模式"><a href="#二、MVVM模式" class="headerlink" title="二、MVVM模式"></a>二、MVVM模式</h2><p>MVVM是Model-View-ViewModel的简写。它本质上就是MVP的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。</p>
<p>我们先来看一下图示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3962292-1a409887611e6e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getMVVM_2"></p>
<p>它与MVP的区别在于它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Vue.js 正是采用了这种模式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3962292-dbd01a83b745d32d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getMVVM_3"><br>Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对比较轻量级的JS 库，API 简洁，很容易上手。</p>
<p>小伙伴们，快来试试Vue.js吧！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/getMVVM/">http://catalinali.top/2018/getMVVM/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-2a81793926834d13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;getMVVM_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="vue.js" scheme="http://catalinali.top/categories/vue-js/"/>
    
    
      <category term="vue.js" scheme="http://catalinali.top/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>（转载）Java设计模式之代理模式</title>
    <link href="http://catalinali.top/2018/proxyPattern/"/>
    <id>http://catalinali.top/2018/proxyPattern/</id>
    <published>2018-08-29T03:22:19.000Z</published>
    <updated>2018-11-12T06:40:53.702Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-7c035942db875458.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>设计模式是语言的表达方式，它能让语言轻便而富有内涵、易读却功能强大。代理模式在Java中十分常见，有为扩展某些类的功能而使用静态代理，也有如Spring实现AOP而使用动态代理，更有RPC实现中使用的调用端调用的代理服务。代理模型除了是一种设计模式之外，它更是一种思维，所以探讨并深入理解这种模型是非常有必要的。</p>
</blockquote>
<a id="more"></a>
<p>本文转载自</p>
<ul>
<li><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">Java的三种代理模式</a></li>
<li><p><a href="https://blog.csdn.net/minidrupal/article/details/28588507" target="_blank" rel="noopener">浅析JAVA设计模式之代理模式(七)</a></p>
<p> 代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。</p>
<p> 代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象</p>
<p> 代理的实现可以分为静态代理和动态代理，动态代理又分为JDK动态代理和CGlib动态代理，下面我们依次来说明一下这三种方式：</p>
</li>
</ul>
<h2 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h2><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.</p>
<p>下面举个案例来解释:<br>模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.<br>需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法.<br>代码示例:<br>接口:IUserDao.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口</span><br><span class="line"> */</span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line"></span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目标对象:UserDao.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口实现</span><br><span class="line"> * 目标对象</span><br><span class="line"> */</span><br><span class="line">public class UserDao implements IUserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;----已经保存数据!----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理对象:UserDaoProxy.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代理对象,静态代理</span><br><span class="line"> */</span><br><span class="line">public class UserDaoProxy implements IUserDao&#123;</span><br><span class="line">    //接收保存目标对象</span><br><span class="line">    private IUserDao target;</span><br><span class="line">    public UserDaoProxy(IUserDao target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;开始事务...&quot;);</span><br><span class="line">        target.save();//执行目标对象的方法</span><br><span class="line">        System.out.println(&quot;提交事务...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类:App.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //目标对象</span><br><span class="line">        UserDao target = new UserDao();</span><br><span class="line"></span><br><span class="line">        //代理对象,把目标对象传给代理对象,建立代理关系</span><br><span class="line">        UserDaoProxy proxy = new UserDaoProxy(target);</span><br><span class="line"></span><br><span class="line">        proxy.save();//执行的是代理的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态代理总结:<br>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>2.缺点:<br>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p>
<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式.</p>
<h2 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h2><p>动态代理有以下特点:<br>1.代理对象,不需要实现接口<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>3.动态代理也叫做:JDK代理,接口代理</p>
<p>JDK中生成代理对象的API<br>代理类所在包:java.lang.reflect.Proxy<br>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</span><br></pre></td></tr></table></figure></p>
<p>注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:</p>
<ul>
<li>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的</li>
<li>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型</li>
<li>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入<br>代码示例:<br>接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法</li>
</ul>
<p>代理工厂类:ProxyFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建动态代理对象</span><br><span class="line"> * 动态代理不需要实现接口,但是需要指定接口类型</span><br><span class="line"> */</span><br><span class="line">public class ProxyFactory&#123;</span><br><span class="line"></span><br><span class="line">    //维护一个目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public ProxyFactory(Object target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //给目标对象生成代理对象</span><br><span class="line">    public Object getProxyInstance()&#123;</span><br><span class="line">        return Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;开始事务2&quot;);</span><br><span class="line">                        //执行目标对象方法</span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(&quot;提交事务2&quot;);</span><br><span class="line">                        return returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类:App.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 目标对象</span><br><span class="line">        IUserDao target = new UserDao();</span><br><span class="line">        // 【原始的类型 class cn.itcast.b_dynamic.UserDao】</span><br><span class="line">        System.out.println(target.getClass());</span><br><span class="line"></span><br><span class="line">        // 给目标对象，创建代理对象</span><br><span class="line">        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();</span><br><span class="line">        // class $Proxy0   内存中动态生成的代理对象</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line"></span><br><span class="line">        // 执行方法   【代理对象】</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:<br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理</p>
<h2 id="二、CGLIB代理"><a href="#二、CGLIB代理" class="headerlink" title="二、CGLIB代理"></a>二、CGLIB代理</h2><h3 id="CGLIB概述"><a href="#CGLIB概述" class="headerlink" title="CGLIB概述"></a>CGLIB概述</h3><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p>
<p>CGLIB也提供了一个处理器接口（这里成为回调接口）net.sf.cglib.proxy.MethodInterceptor（相当于JDK代理的InvocationHandler接口），它自定义了一个intercept方法（相当于JDK代理的invoke方法），用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数是代理类对象，第二个参数是委托类被调用的方法的类对象</span></span><br><span class="line"><span class="comment">// 第三个是该方法的参数，第四个是生成在代理类里面，除了方法名不同，其他都和被代理方法一样的（参数，方法体里面的东西）一个方法的类对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodproxy)</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure></p>
<p>然后CGLIB也提供了一个生成代理类的类net.sf.cglib.proxy.Enhancer（相当于JDK代理的java.lang.reflect.Proxy），它提供了一组静态方法来为一组接口动态地生成代理类及其对象。本文创建代理用到的Enhancer的静态方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object proxy,Method method, Object[] args,  MethodProxy methodproxy) throws Throwable</span><br><span class="line">       //为指定类装载器、接口及调用处理器生成动态代理类实例</span><br><span class="line">       public static  Object create(Class class ,Callback callback h)&#123;&#125;</span><br><span class="line">       public static  Object create(Class class,Class[] interfaces,Callback h)&#123;&#125;</span><br><span class="line">       public static Object create(Classclass, Class[] interfaces, CallbackFilter filter, Callback[] hs)</span><br><span class="line">       public Object create(Class[] argumentTypes, Object[] arguments)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p> 这个create方法相当于JDK代理的newProxyInstance方法，该方法的参数具体含义如下：</p>
<ul>
<li>Class class：指定一个被代理类的类对象。</li>
<li>Class[]interfaces：如果要代理接口，指定一组被代理类实现的所有接口的类对象。</li>
<li>Callback h：指定一个实现了处理器接口（这里称回调接口）的对象。</li>
<li>CallbackFilter filter：指定一个方法过滤器。</li>
<li>Callback[]hs：指定一组实现了处理器接口的对象。</li>
<li>Class[] argumentTypes：指定某个构造器的参数类型</li>
<li>Object[] arguments：指定某个gouz</li>
</ul>
<h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ol>
<li>通过实现 MethodInterceptor接口创建自己的处理器；</li>
<li>通过给Enhancer类的create()方法传进被代理类的类对象、实现了MethodInterceptor接口的处理器对象，得到一个代理类对   象。</li>
<li>其中Enhancer类通过反射机制获得代理类的构造函数，有一个参数类型是处理器接口类型。</li>
<li>Enhancer类再通过构造函数对象创建动态代理类实例，构造时处理器对象作为参数被传入。</li>
<li><p>当客户端调用了代理类的方法时，该方法调用了处理器的intercept()方法并给intercept()方法传进委托类方法的类对象，intercept方法再调用委托类的真实方法。<br>(1)建一个reallyCglibProxy包，所有程序都放在该包下，我在Spring的包库里面找到两个包：asm.jar和cblib-2.1.3.jar，最好在Spring里面同时拷贝这两个包到项目的类库下，不要分别从网上下载，可能会冲突。<br>(2)建一个被代理类（RealSubject.java）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">//被代理类</span><br><span class="line">public class RealSubject &#123;</span><br><span class="line">  public void print() &#123;</span><br><span class="line">    System.out.println(&quot;被代理的人郭襄&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）建一个用户自定义的处理器类LogHandler.java，需要实现处理接口，在intercept（）方法里写上被代理类的方法调用前后要进行的动作。这个intercept（）方法我们不用直接调用，是让将来自动生成的代理类去调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import jdkDynamicProxy.LonHanderReflectTool;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line">//相当于实现jdk的InvocationHandler接口</span><br><span class="line">public class LogHandler implements MethodInterceptor&#123;</span><br><span class="line">  private Object delegate; //被代理类的对象</span><br><span class="line">  //绑定被代理类的对象</span><br><span class="line">  public Object bind(Object delegate)throws Exception&#123;</span><br><span class="line">    this.delegate=delegate;</span><br><span class="line">  return Enhancer.create(delegate.getClass(),this);</span><br><span class="line">  &#125;  </span><br><span class="line">  //相当于InvocationHandler接口里面的invoke()方法</span><br><span class="line">  @Override</span><br><span class="line">  public Object intercept(Object proxy, Method method, Object[] args,</span><br><span class="line">      MethodProxy methodproxy) throws Throwable &#123;</span><br><span class="line">    Object result=null;</span><br><span class="line">    System.out.println(&quot;我是代理人郭靖，开始代理&quot;);</span><br><span class="line">    </span><br><span class="line">    //method.invoke()或者methodproxy.invoke()都可以</span><br><span class="line">    result=method.invoke(delegate,args);</span><br><span class="line">    //result=methodproxy.invoke(delegate,args);</span><br><span class="line">    System.out.println(&quot;我是代理人郭靖，代理完毕&quot;);</span><br><span class="line"> </span><br><span class="line">    //调用工具类反射jdk的Proxy生成的代理类，可参考《五》中这个工具类</span><br><span class="line">    LonHanderReflectTool.ReflectClass(proxy.getClass().getName());</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>(4)编写测试客户端（TestReallyCglibProxy.java）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">public class TestReallyCglibProxy &#123;</span><br><span class="line">  public static void main(String[] args)throws Exception &#123;</span><br><span class="line">    RealSubject sub1=new RealSubject();</span><br><span class="line">    LogHandler hander=new LogHandler();</span><br><span class="line">    RealSubject sub2=(RealSubject)hander.bind(sub1);</span><br><span class="line">    sub2.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是代理人郭靖，开始代理</span><br><span class="line"></span><br><span class="line">被代理的人郭襄</span><br><span class="line"></span><br><span class="line">我是代理人郭靖，代理完毕</span><br></pre></td></tr></table></figure></p>
<p>从结果可以看出，成功自动生成了代理类RealSubject$$EnhancerByCGLIB$$48574fb2，并成功实现了代理的效果，而且还代理了RealSubject类从父类继承的finalize、equals、toString、hashCode、clone这几个方法。</p>
<h3 id="CBLIB方法过滤器"><a href="#CBLIB方法过滤器" class="headerlink" title="CBLIB方法过滤器"></a>CBLIB方法过滤器</h3><p>如果现在有个要求，被代理类的print方法不用处理。当最简单的方式是修改方法拦截器（即intercept方法），在里面进行判断，如果是print()方法就不做任何逻辑处理，直接调用，这样子使得编写拦截器（相当于JDK代理里的处理器）逻辑变复杂，不易维护。我们可以使用CGLIB提供的方法过滤器（CallbackFilter），使得被代理类中不同的方法，根据我们的逻辑要求，调用不同的处理器，从而使用不同的拦截方法（处理器方法）。<br>基本步骤如下:<br>（1）修改一下被代理类（RealSubject.java），增加一个方法print2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">//被代理类</span><br><span class="line">public class RealSubject &#123;</span><br><span class="line">  public void print() &#123;</span><br><span class="line">    System.out.println(&quot;被代理的人郭襄&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public void print2() &#123;</span><br><span class="line">    System.out.println(&quot;我是print2方法哦&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）新建一个用户自定义的方法过滤器类MyProxyFilter.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line"> </span><br><span class="line">import net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"> </span><br><span class="line">import net.sf.cglib.proxy.NoOp;</span><br><span class="line"> </span><br><span class="line">//自定义方法过滤器类</span><br><span class="line"> </span><br><span class="line">public class MyProxyFilterimplements CallbackFilter &#123;</span><br><span class="line"> </span><br><span class="line">    public int accept(Method method) &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">    *这句话可发现，所有被代理的方法都会被过滤一次。Enhancer的源代码中看到下面一段代码</span><br><span class="line">    while(it1.hasNext())&#123;</span><br><span class="line">    MethodInfomethod=(MethodInfo)it1.next();</span><br><span class="line">    MethodactualMethod=(it2!=null)?(Method)it2.next():null;</span><br><span class="line">    intindex=filter.accept(actualMethod);</span><br><span class="line">    if(index&gt;=callbackTypes.length)&#123;</span><br><span class="line">    thrownewIllegalArgumentException(&quot;Callbackfilterreturnedanindexthatistoolarge:&quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line">    上段代码可以看到所有的被代理的方法，本例子中就是print、print2、从父类继承的finalize、equals、toString、</span><br><span class="line">    hashCode、clone这几个方法）都被调用accept方法进行过滤，给每个方法返回一个整数，</span><br><span class="line">    本例子是0或者1，从而选择不同的处理器。</span><br><span class="line">    */</span><br><span class="line"> </span><br><span class="line">System.out.println(method.getDeclaringClass()+&quot;类的&quot;+method.getName()+&quot;方法被检查过滤！&quot;);</span><br><span class="line"> </span><br><span class="line">    /* </span><br><span class="line">    如果调用是print方法，则要调用0号位的拦截器去处理</span><br><span class="line">         */</span><br><span class="line"> </span><br><span class="line">    if(&quot;print&quot;.equals(method.getName()))   </span><br><span class="line"> </span><br><span class="line">    //0号位即LogHandler里面 new Callback[]&#123;this,NoOp.INSTANCE&#125;中的this，它在这个数组第0位置</span><br><span class="line"> </span><br><span class="line">return 1; </span><br><span class="line"> </span><br><span class="line">    /*     </span><br><span class="line">      1号位即LogHandler里面 new Callback[]&#123;this,NoOp.INSTANCE&#125;中的NoOp.INSTANCE，它在这个数组第1位置。</span><br><span class="line">    NoOp.INSTANCE是指不做任何事情的拦截器。</span><br><span class="line">在这里就是任何人都有权限访问print方法，即这个方法没有代理，直接调用</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">return 0;   </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）修改一下用户自定义的处理器类LogHandler.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import jdkDynamicProxy.LonHanderReflectTool;</span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">import net.sf.cglib.proxy.NoOp;</span><br><span class="line">//相当于实现jdk的InvocationHandler接口</span><br><span class="line">public class LogHandler implements MethodInterceptor&#123;</span><br><span class="line">  private Object delegate; //被代理类的对象</span><br><span class="line">  //绑定被代理类的对象</span><br><span class="line">  public Object bind(Object delegate)throws Exception&#123;</span><br><span class="line">    this.delegate=delegate;</span><br><span class="line">  /**</span><br><span class="line">   *传进不同的拦截器（相当于JDK代理里面的处理器）,NoOp.INSTANCE是cglib已经写好的不做任何事情的拦截器，传进去的new Callback[]是一个数组，现在数组有两个拦截器对象，分别是this,和NoOp.INSTANCE，它们分别在数组的第0位和第一位对应着自定义过滤器MyProxyFilter里的accept方法返回的整数，如果是0就调用this拦截器，如果是1就调用NoOp.INSTANCE所以自定义过滤器MyProxyFilter里的accept方法返回的整数最大就是拦截器数组的长度，比如本例子当中，只能是0或者1，不能是2，因为这个数组只有两个元素，最大位置就是1号位。</span><br><span class="line">   */</span><br><span class="line">  return Enhancer.create(delegate.getClass(), null, new MyProxyFilter(), new Callback[]&#123;this,NoOp.INSTANCE&#125;); </span><br><span class="line">  &#125;  </span><br><span class="line">  //相当于InvocationHandler接口里面的invoke()方法</span><br><span class="line">  </span><br><span class="line">  public Object intercept(Object proxy, Method method, Object[] args,</span><br><span class="line">      MethodProxy methodproxy) throws Throwable &#123;</span><br><span class="line">    Object result=null;</span><br><span class="line">    System.out.println(&quot;我是代理人郭靖，开始代理&quot;);</span><br><span class="line">    </span><br><span class="line">    //method.invoke()或者methodproxy.invoke()都可以</span><br><span class="line">    result=method.invoke(delegate,args);</span><br><span class="line">    //result=methodproxy.invoke(delegate,args);</span><br><span class="line">    System.out.println(&quot;我是代理人郭靖，代理完毕&quot;);</span><br><span class="line"> </span><br><span class="line">    //调用工具类反射jdk的Proxy生成的代理类，可参考《五》中这个工具类</span><br><span class="line">    //LonHanderReflectTool.ReflectClass(proxy.getClass().getName());</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4) 修改测试客户端（TestReallyCglibProxy.java）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">publicclass TestReallyCglibProxy &#123;</span><br><span class="line">  publicstaticvoid main(String[] args)throws Exception &#123;</span><br><span class="line">    RealSubject sub1=new RealSubject();</span><br><span class="line">    LogHandler hander=new LogHandler();</span><br><span class="line">    RealSubject sub2=(RealSubject)hander.bind(sub1);</span><br><span class="line">    sub2.print();</span><br><span class="line">        sub2.print2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class reallyCglibProxy.RealSubject类的print2方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class reallyCglibProxy.RealSubject类的print方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的finalize方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的equals方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的toString方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的hashCode方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的clone方法被检查过滤！</span><br><span class="line"></span><br><span class="line">被代理的人郭襄</span><br><span class="line"></span><br><span class="line">我是代理人郭靖，开始代理</span><br><span class="line"></span><br><span class="line">我是print2方法哦</span><br><span class="line"></span><br><span class="line">我是代理人郭靖，代理完毕</span><br></pre></td></tr></table></figure></p>
<pre><code>从结果可以看出，print方法没有被代理，print2方法被代理了，有了方法过滤器，被代理类被代理的方法（本文例子中就是print、print2、从父类继承的finalize、equals、toString、hashCode、clone这几个方法）都被调用accept方法进行过滤，给每个方法返回一个整数，本例子是0或者1，从而选择不同的处理器。
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">Java的三种代理模式</a></li>
<li><a href="https://blog.csdn.net/minidrupal/article/details/28588507" target="_blank" rel="noopener">浅析JAVA设计模式之代理模式(七)</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/proxyPattern/">http://catalinali.top/2018/proxyPattern/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-7c035942db875458.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设计模式是语言的表达方式，它能让语言轻便而富有内涵、易读却功能强大。代理模式在Java中十分常见，有为扩展某些类的功能而使用静态代理，也有如Spring实现AOP而使用动态代理，更有RPC实现中使用的调用端调用的代理服务。代理模型除了是一种设计模式之外，它更是一种思维，所以探讨并深入理解这种模型是非常有必要的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="design-patterns" scheme="http://catalinali.top/categories/design-patterns/"/>
    
    
      <category term="design-patterns" scheme="http://catalinali.top/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程(六)：线程本地变量ThreadLocal与TransmittableThreadLocal</title>
    <link href="http://catalinali.top/2018/helloThreadLocal/"/>
    <id>http://catalinali.top/2018/helloThreadLocal/</id>
    <published>2018-08-28T01:44:53.000Z</published>
    <updated>2018-11-12T06:43:39.701Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-9a65cf48d4f39524.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>我们知道有时候一个对象的共享变量会被多个线程所访问，这时就会有线程安全问题。当然我们可以使用synchorinized 关键字来为此变量加锁，进行同步处理。从而限制只能有一个线程来使用此变量，但是加锁会大大影响程序执行效率，此外我们还可以使用ThreadLocal来解决对某一个变量的访问冲突问题。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、ThreadLocal-概述"><a href="#一、ThreadLocal-概述" class="headerlink" title="一、ThreadLocal 概述"></a>一、ThreadLocal 概述</h2><p>当使用ThreadLocal维护变量的时候 它为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。<br>ThreadLocal 的几个方法： ThreadLocal 可以存储任何类型的变量对象， get返回的是一个Object对象，但是我们可以通过泛型来制定存储对象的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123; &#125; // 用来获取ThreadLocal在当前线程中保存的变量副本</span><br><span class="line">public void set(T value) &#123; &#125; //set()用来设置当前线程中变量的副本</span><br><span class="line">public void remove() &#123; &#125; //remove()用来移除当前线程中变量的副本</span><br><span class="line">protected T initialValue() &#123; &#125; //initialValue()是一个protected方法，一般是用来在使用时进行重写的</span><br></pre></td></tr></table></figure></p>
<p>Thread 在内部是通过ThreadLocalMap来维护ThreadLocal变量表， 在Thread类中有一个threadLocals 变量，是ThreadLocalMap类型的，它就是为每一个线程来存储自身的ThreadLocal变量的， ThreadLocalMap是ThreadLocal类的一个内部类，这个Map里面的最小的存储单位是一个Entry， 它使用ThreadLocal作为key， 变量作为 value，这是因为在每一个线程里面，可能存在着多个ThreadLocal变量</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找<br>我们来看一个使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void set() &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">        stringLocal.set(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public long getLong() &#123;</span><br><span class="line">        return longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        test.set();</span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.set();</span><br><span class="line">                System.out.println(test.getLong());</span><br><span class="line">                System.out.println(test.getString());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">         </span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">main </span><br><span class="line">9 </span><br><span class="line">Thread-0 </span><br><span class="line">1 </span><br><span class="line">main</span><br></pre></td></tr></table></figure></p>
<h2 id="二、父子线程传递InheritableThreadLocal"><a href="#二、父子线程传递InheritableThreadLocal" class="headerlink" title="二、父子线程传递InheritableThreadLocal"></a>二、父子线程传递InheritableThreadLocal</h2><p>以上方案在父子线程中就有了局限性，如果子线程想要拿到父线程的中的ThreadLocal值怎么办呢？比如会有以下的这种代码的实现。由于ThreadLocal的实现机制,在子线程中get时,我们拿到的Thread对象是当前子线程对象,那么他的ThreadLocalMap是null的,所以我们得到的value也是null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final ThreadLocal threadLocal=new ThreadLocal()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object initialValue() &#123;</span><br><span class="line">                return &quot;xiezhaodong&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                threadLocal.get();//NULL</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>JDK已经为这种情况提供了实现方案:InheritableThreadLocal。大致的解释了一下InheritableThreadLocal为什么能解决父子线程传递Threadlcoal值的问题。<br>1）在创建InheritableThreadLocal对象的时候赋值给线程的t.inheritableThreadLocals变量<br>2）在创建新线程的时候会check父线程中t.inheritableThreadLocals变量是否为null，如果不为null则copy一份ThradLocalMap到子线程的t.inheritableThreadLocals成员变量中去<br>3）因为复写了getMap(Thread)和CreateMap()方法,所以get值得时候，就可以在getMap(t)的时候就会从t.inheritableThreadLocals中拿到map对象，从而实现了可以拿到父线程ThreadLocal中的值</p>
<p>所以,在最开始的代码示例中，如果把ThreadLocal对象换成InheritableThreadLocal对象，那么get到的字符会是“xiezhaodong”而不是NULL</p>
<h2 id="二、线程池传递TransmittableThreadLocal"><a href="#二、线程池传递TransmittableThreadLocal" class="headerlink" title="二、线程池传递TransmittableThreadLocal"></a>二、线程池传递TransmittableThreadLocal</h2><p>我们在使用线程的时候往往不会只是简单的new Thrad对象，而是使用线程池，当然线程池的好处多多。这里不详解，既然这里提出了问题，那么线程池会给InheritableThreadLocal带来什么问题呢？我们列举一下线程池的特点：</p>
<p>1）为了减小创建线程的开销，线程池会缓存已经使用过的线程<br>2）生命周期统一管理,合理的分配系统资源</p>
<p>对于第一点，如果一个子线程已经使用过，并且会set新的值到ThreadLocal中，那么第二个task提交进来的时候还能获得父线程中的值吗？答案是不能，如果我们能够，在使用完这个线程的时候清除所有的localMap，在submit新任务的时候在重新重父线程中copy所有的Entry。然后重新给当前线程的t.inhertableThreadLocal赋值。这样就能够解决在线程池中每一个新的任务都能够获得父线程中ThreadLocal中的值而不受其他任务的影响，因为在生命周期完成的时候会自动clear所有的数据。Alibaba的一个库解决了这个问题<a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">github:alibaba/transmittable-thread-local</a><br><strong>如何使用</strong><br>这个库最简单的方式是这样使用的,通过简单的修饰，使得提交的runable拥有了上一节所述的功能。具体的API文档详见github，这里不再赘述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TransmittableThreadLocal&lt;String&gt; parent = new TransmittableThreadLocal&lt;String&gt;();</span><br><span class="line">parent.set(&quot;value-set-in-parent&quot;);</span><br><span class="line"></span><br><span class="line">Runnable task = new Task(&quot;1&quot;);</span><br><span class="line">// 额外的处理，生成修饰了的对象ttlRunnable</span><br><span class="line">Runnable ttlRunnable = TtlRunnable.get(task); </span><br><span class="line">executorService.submit(ttlRunnable);</span><br><span class="line"></span><br><span class="line">// Task中可以读取, 值是&quot;value-set-in-parent&quot;</span><br><span class="line">String value = parent.get();</span><br></pre></td></tr></table></figure></p>
<p><strong>原理简述</strong><br>这个方法TtlRunnable.get(task)最终会调用构造方法，返回的是该类本身，也是一个Runable,这样就完成了简单的装饰。最重要的是在run方法这个地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final class TtlRunnable implements Runnable &#123;</span><br><span class="line">    private final AtomicReference&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;&gt; copiedRef;</span><br><span class="line">    private final Runnable runnable;</span><br><span class="line">    private final boolean releaseTtlValueReferenceAfterRun;</span><br><span class="line"></span><br><span class="line">    private TtlRunnable(Runnable runnable, boolean releaseTtlValueReferenceAfterRun) &#123;</span><br><span class="line">    //从父类copy值到本类当中</span><br><span class="line">        this.copiedRef = new AtomicReference&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;&gt;(TransmittableThreadLocal.copy());</span><br><span class="line">        this.runnable = runnable;//提交的runable,被修饰对象</span><br><span class="line">        this.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * wrap method &#123;@link Runnable#run()&#125;.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; copied = copiedRef.get();</span><br><span class="line">        if (copied == null || releaseTtlValueReferenceAfterRun &amp;&amp; !copiedRef.compareAndSet(copied, null)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;TTL value reference is released after run!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //装载到当前线程</span><br><span class="line">        Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = TransmittableThreadLocal.backupAndSetToCopied(copied);</span><br><span class="line">        try &#123;</span><br><span class="line">            runnable.run();//执行提交的task</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        //clear</span><br><span class="line">            TransmittableThreadLocal.restoreBackup(backup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的使用线程池的例子当中，如果换成这种修饰的方式进行操作，B任务得到的肯定是父线程中ThreadLocal的值，解决了在线程池中InheritableThreadLocal不能解决的问题。<br><strong>如何更新父线程ThreadLocal值？</strong><br>如果线程之间出了要能够得到父线程中的值，同时想更新值怎么办呢？在前面我们有提到，当子线程copy父线程的ThreadLocalMap的时候是浅拷贝的,代表子线程Entry里面的value都是指向的同一个引用，我们只要修改这个引用的同时就能够修改父线程当中的值了,比如这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              System.out.println(&quot;========&quot;);</span><br><span class="line">              Span span=  inheritableThreadLocal.get();</span><br><span class="line">              System.out.println(span);</span><br><span class="line">              span.name=&quot;liuliuliu&quot;;//修改父引用为liuliuliu</span><br><span class="line">              inheritableThreadLocal.set(new Span(&quot;zhangzhangzhang&quot;));</span><br><span class="line">              System.out.println(inheritableThreadLocal.get());</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样父线程中的值就会得到更新了。能够满足父线程ThreadLocal值的实时更新，同时子线程也能共享父线程的值。不过场景倒是不是很常见的样子。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></li>
<li><a href="https://blog.csdn.net/a837199685/article/details/52712547" target="_blank" rel="noopener">ThreadLocal父子线程传递实现方案</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloThreadLocal/">http://catalinali.top/2018/helloThreadLocal/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-9a65cf48d4f39524.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们知道有时候一个对象的共享变量会被多个线程所访问，这时就会有线程安全问题。当然我们可以使用synchorinized 关键字来为此变量加锁，进行同步处理。从而限制只能有一个线程来使用此变量，但是加锁会大大影响程序执行效率，此外我们还可以使用ThreadLocal来解决对某一个变量的访问冲突问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="juc" scheme="http://catalinali.top/categories/juc/"/>
    
    
      <category term="juc" scheme="http://catalinali.top/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程(五)：创建线程的第三种方式：实现Callable接口</title>
    <link href="http://catalinali.top/2018/helloCallable/"/>
    <id>http://catalinali.top/2018/helloCallable/</id>
    <published>2018-08-27T02:49:54.000Z</published>
    <updated>2018-11-12T06:44:46.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-a886bc10a753b44e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>众所周知创建线程的方式有两种：1.继承Thread类。2.实现Runnable接口。从jdk1.5开始，提供了另一种创建线程的方式。今天我们就来看看这第三种方式：实现Callable接口</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Callable与Runnable"><a href="#一、Callable与Runnable" class="headerlink" title="一、Callable与Runnable"></a>一、Callable与Runnable</h2><p>我们直接来看一个使用Callable创建线程的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer sum = result.get();  <span class="comment">//FutureTask 可用于 闭锁</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个例子可以看出，Callable与Runnable的主要区别在于Callable可以拿到任务执行后的返回值。Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></p>
<p>第一个submit方法里面的参数类型就是Callable。<br>一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p>
<h2 id="二、Future和FutureTask"><a href="#二、Future和FutureTask" class="headerlink" title="二、Future和FutureTask"></a>二、Future和FutureTask</h2><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>　　Future类位于java.util.concurrent包下，它是一个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p>
<ul>
<li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>
<li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就会抛出异常，如果捕获了直接返回null。<br>也就是说Future提供了三种功能<br>1）判断任务是否完成；<br>2）能够中断任务；<br>3）能够获取任务执行结果<br>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有FutureTask。</li>
</ul>
<p>我们先来看一下FutureTask的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>
<p> 　　FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p>　　FutureTask提供了2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　事实上，FutureTask是Future接口的一个唯一实现类。<br>　　下面来一个FutureTaskde使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line">        <span class="comment">/*Task task = new Task();</span></span><br><span class="line"><span class="comment">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">        Thread thread = new Thread(futureTask);</span></span><br><span class="line"><span class="comment">        thread.start();*/</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java并发编程：Callable、Future和FutureTask</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloCallable/">http://catalinali.top/2018/helloCallable/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-a886bc10a753b44e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;众所周知创建线程的方式有两种：1.继承Thread类。2.实现Runnable接口。从jdk1.5开始，提供了另一种创建线程的方式。今天我们就来看看这第三种方式：实现Callable接口&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="juc" scheme="http://catalinali.top/categories/juc/"/>
    
    
      <category term="juc" scheme="http://catalinali.top/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>（转载）JAVA并发编程(四)：线程池的使用</title>
    <link href="http://catalinali.top/2018/helloThreadPool/"/>
    <id>http://catalinali.top/2018/helloThreadPool/</id>
    <published>2018-08-27T02:48:41.000Z</published>
    <updated>2018-11-12T06:43:22.745Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-32986334ff3bf845.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p>
</blockquote>
<a id="more"></a>
<p>本文转载自<a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></p>
<h2 id="一、Java中的ThreadPoolExecutor类"><a href="#一、Java中的ThreadPoolExecutor类" class="headerlink" title="一、Java中的ThreadPoolExecutor类"></a>一、Java中的ThreadPoolExecutor类</h2><p>　java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。<br>　　在ThreadPoolExecutor类中提供了四个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。<br> 　　下面解释下一下构造器中各个参数的含义：</p>
<ul>
<li><p>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
</li>
<li><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
</li>
<li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               //天</span><br><span class="line">TimeUnit.HOURS;             //小时</span><br><span class="line">TimeUnit.MINUTES;           //分钟</span><br><span class="line">TimeUnit.SECONDS;           //秒</span><br><span class="line">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class="line">TimeUnit.MICROSECONDS;      //微妙</span><br><span class="line">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></table></figure>
</li>
<li><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br><span class="line">PriorityBlockingQueue;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>
<ul>
<li>threadFactory：线程工厂，主要用来创建线程；</li>
<li>handler：表示当拒绝处理任务时的策略，有以下四种取值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。<br>　　我们接着看ExecutorService接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　到这里，大家应该明白了ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。<br>　　Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；<br>　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；<br>　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；<br>　　然后ThreadPoolExecutor继承了类AbstractExecutorService。<br>　　在ThreadPoolExecutor类中有几个非常重要的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute()</span><br><span class="line">submit()</span><br><span class="line">shutdown()</span><br><span class="line">shutdownNow()</span><br></pre></td></tr></table></figure></p>
<p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。<br>　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。<br>　　shutdown()和shutdownNow()是用来关闭线程池的。<br>　　还有很多其他的方法：<br>　　比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。</p>
<h2 id="二、深入剖析线程池实现原理"><a href="#二、深入剖析线程池实现原理" class="headerlink" title="二、深入剖析线程池实现原理"></a>二、深入剖析线程池实现原理</h2><p>在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：<br>　　<strong>1.线程池状态<br>　　2.任务的执行<br>　　3.线程池中的线程初始化<br>　　4.任务缓存队列及排队策略<br>　　5.任务拒绝策略<br>　　6.线程池的关闭<br>　　7.线程池容量的动态调整</strong></p>
<h3 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1.线程池状态"></a>1.线程池状态</h3><p>在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile int runState;</span><br><span class="line">static final int RUNNING    = 0;</span><br><span class="line">static final int SHUTDOWN   = 1;</span><br><span class="line">static final int STOP       = 2;</span><br><span class="line">static final int TERMINATED = 3;</span><br></pre></td></tr></table></figure></p>
<p>　  runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；<br>　　下面的几个static final变量表示runState可能的几个取值。<br>　　当创建线程池后，初始时，线程池处于RUNNING状态；<br>　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p>
<h3 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2.任务的执行"></a>2.任务的执行</h3><p>在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;              <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小</span></span><br><span class="line">                                                              <span class="comment">//、runState等）的改变都要使用这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure></p>
<pre><code>每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。
</code></pre><p>　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：<br>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。<br>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；<br>　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；<br>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；<br>　　然后就将任务也分配给这4个临时工人做；<br>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。<br>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。<br>　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。<br>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。<br>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。<br>　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。<br>　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。<br>　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：<br>　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；<br>　　接着是这句，这句要好好理解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))</span><br></pre></td></tr></table></figure></p>
<p>　　由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。<br>　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderCorePoolSize(command)</span><br></pre></td></tr></table></figure></p>
<pre><code>如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。
</code></pre><p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (runState == RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure></p>
<p>如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderMaximumPoolSize(command)</span><br></pre></td></tr></table></figure></p>
<p>如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。回到前面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (runState == RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure></p>
<p>这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (runState != RUNNING || poolSize == 0)</span><br></pre></td></tr></table></figure></p>
<p>这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureQueuedTaskHandled(command)</span><br></pre></td></tr></table></figure></p>
<p>进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);        <span class="comment">//创建线程去执行firstTask任务   </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = addThread(firstTask);</span><br></pre></td></tr></table></figure></p>
<p> 　　这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。<br>　　我们来看一下addThread方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Thread addThread(Runnable firstTask) &#123;</span><br><span class="line">    Worker w = new Worker(firstTask);</span><br><span class="line">    Thread t = threadFactory.newThread(w);  //创建一个线程，执行任务   </span><br><span class="line">    if (t != null) &#123;</span><br><span class="line">        w.thread = t;            //将创建的线程的引用赋值为w的成员变量       </span><br><span class="line">        workers.add(w);</span><br><span class="line">        int nt = ++poolSize;     //当前线程数加1       </span><br><span class="line">        if (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = nt;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。<br>　　下面我们看一下Worker类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker implements Runnable &#123;</span><br><span class="line">    private final ReentrantLock runLock = new ReentrantLock();</span><br><span class="line">    private Runnable firstTask;</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line">    Thread thread;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        this.firstTask = firstTask;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isActive() &#123;</span><br><span class="line">        return runLock.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    void interruptIfIdle() &#123;</span><br><span class="line">        final ReentrantLock runLock = this.runLock;</span><br><span class="line">        if (runLock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">        if (thread != Thread.currentThread())</span><br><span class="line">        thread.interrupt();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                runLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void interruptNow() &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void runTask(Runnable task) &#123;</span><br><span class="line">        final ReentrantLock runLock = this.runLock;</span><br><span class="line">        runLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (runState &lt; STOP &amp;&amp;</span><br><span class="line">                Thread.interrupted() &amp;&amp;</span><br><span class="line">                runState &gt;= STOP)</span><br><span class="line">            boolean ran = false;</span><br><span class="line">            beforeExecute(thread, task);   //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据</span><br><span class="line">            //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           </span><br><span class="line">            try &#123;</span><br><span class="line">                task.run();</span><br><span class="line">                ran = true;</span><br><span class="line">                afterExecute(task, null);</span><br><span class="line">                ++completedTasks;</span><br><span class="line">            &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">                if (!ran)</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable task = firstTask;</span><br><span class="line">            firstTask = null;</span><br><span class="line">            while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">                runTask(task);</span><br><span class="line">                task = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workerDone(this);   //当任务队列中没有任务时，进行清理工作       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new Thread(w);</span><br></pre></td></tr></table></figure></p>
<p>相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = null;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        workerDone(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> state = runState;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Runnable r;</span><br><span class="line">            <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                r = workQueue.poll();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) <span class="comment">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span></span><br><span class="line">                <span class="comment">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span></span><br><span class="line">                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">if</span> (workerCanExit()) &#123;    <span class="comment">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span></span><br><span class="line">                <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                    interruptIdleWorkers();   <span class="comment">//中断处于空闲状态的worker</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Else retry</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> state = runState;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Runnable r;</span><br><span class="line">            <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                r = workQueue.poll();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) <span class="comment">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span></span><br><span class="line">                <span class="comment">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span></span><br><span class="line">                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">if</span> (workerCanExit()) &#123;    <span class="comment">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span></span><br><span class="line">                <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                    interruptIdleWorkers();   <span class="comment">//中断处于空闲状态的worker</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Else retry</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。<br>　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。<br>　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。<br>　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private boolean workerCanExit() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    boolean canExit;</span><br><span class="line">    //如果runState大于等于STOP，或者任务缓存队列为空了</span><br><span class="line">    //或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1</span><br><span class="line">    try &#123;</span><br><span class="line">        canExit = runState &gt;= STOP ||</span><br><span class="line">            workQueue.isEmpty() ||</span><br><span class="line">            (allowCoreThreadTimeOut &amp;&amp;</span><br><span class="line">             poolSize &gt; Math.max(1, corePoolSize));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return canExit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void interruptIdleWorkers() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers)  //实际上调用的是worker的interruptIfIdle()方法</span><br><span class="line">            w.interruptIfIdle();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void interruptIfIdle() &#123;</span><br><span class="line">    final ReentrantLock runLock = this.runLock;</span><br><span class="line">    if (runLock.tryLock()) &#123;    //注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的</span><br><span class="line">                                //如果成功获取了锁，说明当前worker处于空闲状态</span><br><span class="line">        try &#123;</span><br><span class="line">    if (thread != Thread.currentThread())  </span><br><span class="line">    thread.interrupt();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  　　这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。<br> 　　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfUnderMaximumPoolSize(Runnable firstTask) &#123;</span><br><span class="line">    Thread t = null;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (t == null)</span><br><span class="line">        return false;</span><br><span class="line">    t.start();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。<br>　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：<br>　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；<br>　　2）其次，要知道Worker是用来起到什么作用的；<br>　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：<br>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</p>
<h3 id="3-线程池中的线程初始化"><a href="#3-线程池中的线程初始化" class="headerlink" title="3.线程池中的线程初始化"></a>3.线程池中的线程初始化</h3><p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p>
<p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
<p>prestartCoreThread()：初始化一个核心线程；<br>prestartAllCoreThreads()：初始化所有核心线程<br>　　下面是这2个方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean prestartCoreThread() &#123;</span><br><span class="line">    return addIfUnderCorePoolSize(null); //注意传进去的参数是null</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int prestartAllCoreThreads() &#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">    while (addIfUnderCorePoolSize(null))//注意传进去的参数是null</span><br><span class="line">        ++n;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = workQueue.take();</span><br></pre></td></tr></table></figure></p>
<p>即等待任务队列中有任务。</p>
<h3 id="4-任务缓存队列及排队策略"><a href="#4-任务缓存队列及排队策略" class="headerlink" title="4.任务缓存队列及排队策略"></a>4.任务缓存队列及排队策略</h3><p>　　在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。<br>　　workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：<br>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；<br>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；<br>　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</runnable></p>
<h3 id="5-任务拒绝策略"><a href="#5-任务拒绝策略" class="headerlink" title="5.任务拒绝策略"></a>5.任务拒绝策略</h3><p>　　当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></p>
<h3 id="6-线程池的关闭"><a href="#6-线程池的关闭" class="headerlink" title="6.线程池的关闭"></a>6.线程池的关闭</h3><p>　　ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li><p>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p>
<h3 id="7-线程池容量的动态调整"><a href="#7-线程池容量的动态调整" class="headerlink" title="7.线程池容量的动态调整"></a>7.线程池容量的动态调整</h3><p>　　ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize():</p>
</li>
<li><p>setCorePoolSize：设置核心池大小</p>
</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小<br>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。　　<br>##　三、使用示例　　<br>前面我们讨论了关于线程池的实现原理，这一节我们来看一下它的具体使用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                 <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">             MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">             executor.execute(myTask);</span><br><span class="line">             System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">             executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</span><br><span class="line">         &#125;</span><br><span class="line">         executor.shutdown();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行task "</span>+taskNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"task "</span>+taskNum+<span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行结果：　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">正在执行task 0</span><br><span class="line">线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 1</span><br><span class="line">线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 2</span><br><span class="line">线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 3</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 4</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 10</span><br><span class="line">线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 11</span><br><span class="line">线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 12</span><br><span class="line">线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 13</span><br><span class="line">线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 14</span><br><span class="line">task 3执行完毕</span><br><span class="line">task 0执行完毕</span><br><span class="line">task 2执行完毕</span><br><span class="line">task 1执行完毕</span><br><span class="line">正在执行task 8</span><br><span class="line">正在执行task 7</span><br><span class="line">正在执行task 6</span><br><span class="line">正在执行task 5</span><br><span class="line">task 4执行完毕</span><br><span class="line">task 10执行完毕</span><br><span class="line">task 11执行完毕</span><br><span class="line">task 13执行完毕</span><br><span class="line">task 12执行完毕</span><br><span class="line">正在执行task 9</span><br><span class="line">task 14执行完毕</span><br><span class="line">task 8执行完毕</span><br><span class="line">task 5执行完毕</span><br><span class="line">task 7执行完毕</span><br><span class="line">task 6执行完毕</span><br><span class="line">task 9执行完毕</span><br></pre></td></tr></table></figure></p>
<p>从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。<br>　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span><br><span class="line">Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池</span><br><span class="line">Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池</span><br></pre></td></tr></table></figure></p>
<p>下面是这三个静态方法的具体实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。<br>　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；<br>　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；<br>　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。<br>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。<br>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p>
<h2 id="四、如何合理配置线程池的大小"><a href="#四、如何合理配置线程池的大小" class="headerlink" title="四、如何合理配置线程池的大小"></a>四、如何合理配置线程池的大小</h2><p>　  本节来讨论一个比较重要的话题：如何合理配置线程池大小，仅供参考。<br>　　一般需要根据任务的类型来配置线程池大小：<br>　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1<br>　　如果是IO密集型任务，参考值可以设置为2*NCPU<br>　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。
　　</p>
<h2 id=""><a href="#" class="headerlink" title="　　"></a>　　</h2><blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloThreadPool/">http://catalinali.top/2018/helloThreadPool/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-32986334ff3bf845.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="juc" scheme="http://catalinali.top/categories/juc/"/>
    
    
      <category term="juc" scheme="http://catalinali.top/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程(三)：同步的辅助类之闭锁（CountDownLatch）与循环屏障（CyclicBarrier）</title>
    <link href="http://catalinali.top/2018/helloLatch/"/>
    <id>http://catalinali.top/2018/helloLatch/</id>
    <published>2018-08-23T11:11:08.000Z</published>
    <updated>2018-11-12T06:44:07.454Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-a0fa086b5465c2e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>jdk1.5的concurrent包为我们提供了很多有用的辅助类，今天我们来学习一下</p>
</blockquote>
<a id="more"></a>
<h2 id="一、闭锁CountDownLatch"><a href="#一、闭锁CountDownLatch" class="headerlink" title="一、闭锁CountDownLatch"></a>一、闭锁CountDownLatch</h2><p>CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。它的作用是，在完成某些运算时，只有其他所有线程的运算全部完成，当前线程的运算才继续执行。<br>CountDownLatch类只提供了一个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;  &#125;;  //参数count为计数值</span><br></pre></td></tr></table></figure></p>
<p>然后下面这3个方法是CountDownLatch类中最重要的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123; &#125;;   //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">public void countDown() &#123; &#125;;  //将count值减1</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看看下面的这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class TestCountDownLatch &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final CountDownLatch latch = new CountDownLatch(50);</span><br><span class="line">		LatchDemo ld = new LatchDemo(latch);</span><br><span class="line"></span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">			new Thread(ld).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			latch.await();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		long end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;耗费时间为：&quot; + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LatchDemo implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">	public LatchDemo(CountDownLatch latch) &#123;</span><br><span class="line">		this.latch = latch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			for (int i = 0; i &lt; 50000; i++) &#123;</span><br><span class="line">				if (i % 2 == 0) &#123;</span><br><span class="line">					System.out.println(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			latch.countDown();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过CountDownLatch，我们就可以计算一批线程的执行时间。从这个例子中我们也可以看出：CountDownLatch中维护了一个int类型的变量。当前线程调用await()方法来使用这个辅助类，在这个变量成为0之后当前线程就会继续执行下去了。所以我们在构造器里填入的变量要跟等待的线程数量相同。</p>
<h2 id="二、CyclicBarrier"><a href="#二、CyclicBarrier" class="headerlink" title="二、CyclicBarrier"></a>二、CyclicBarrier</h2><pre><code>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。
</code></pre><p>CyclicBarrier提供2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。<br>　　然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123; &#125;;</span><br><span class="line">public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p> 　　第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p>
<p>　　第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 4;</span><br><span class="line">        CyclicBarrier barrier  = new CyclicBarrier(N);</span><br><span class="line">        for(int i=0;i&lt;N;i++)</span><br><span class="line">            new Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Writer extends Thread&#123;</span><br><span class="line">        private CyclicBarrier cyclicBarrier;</span><br><span class="line">        public Writer(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            this.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);      //以睡眠来模拟写入数据操作</span><br><span class="line">                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;catch(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure></p>
<h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><ul>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器是可以重用的。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="noopener">Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</a></li>
<li><a href="http://ifeve.com/concurrency-cyclicbarrier/" target="_blank" rel="noopener">并发工具类（二）同步屏障CyclicBarrier</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloLatch/">http://catalinali.top/2018/helloLatch/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-a0fa086b5465c2e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;jdk1.5的concurrent包为我们提供了很多有用的辅助类，今天我们来学习一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="juc" scheme="http://catalinali.top/categories/juc/"/>
    
    
      <category term="juc" scheme="http://catalinali.top/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程(二)：理解CAS机制</title>
    <link href="http://catalinali.top/2018/helloCAS/"/>
    <id>http://catalinali.top/2018/helloCAS/</id>
    <published>2018-08-19T06:09:25.000Z</published>
    <updated>2018-11-12T06:44:32.571Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-e74f791fa0e5c43f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>也许大家已经听说过，锁分两种，一个叫悲观锁，一种称之为乐观锁。Synchronized就是悲观锁的一种，也称之为独占锁，加了synchronized关键字的代码基本上就只能以单线程的形式去执行了，它会导致其他需要该资源的线程挂起，直到前面的线程执行完毕释放所资源。而另外一种乐观锁是一种更高效的机制，它的原理就是每次不加锁去执行某项操作，如果发生冲突则失败并重试，直到成功为止，其实本质上不算锁，所以很多地方也称之为自旋。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、并发编程中的原子性问题"><a href="#一、并发编程中的原子性问题" class="headerlink" title="一、并发编程中的原子性问题"></a>一、并发编程中的原子性问题</h2><p>在上篇<a href="http://catalinali.top/2018/helloVolatile/">JAVA并发编程(一)：理解volatile关键字</a>的结尾留了一个原子性的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写”</span></span><br><span class="line"><span class="comment"> * 		  int i = 10;</span></span><br><span class="line"><span class="comment"> * 		  i = i++; //10</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		  int temp = i;</span></span><br><span class="line"><span class="comment"> * 		  i = i + 1;</span></span><br><span class="line"><span class="comment"> * 		  i = temp;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(getSerialNumber());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> serialNumber++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果并不总是0-10。要想解决这个问题，你可能会说加Synchronized同步锁：加了同步锁之后，serialNumber++操作变成了原子性操作，所以最终的输出一定是0-9，代码实现了线程安全。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (TestAtomicDemo.class) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是众所周知的是Synchronized同步锁比较耗费性能，在某些情况下并不是一个好的选择，那有没有什么好的办法呢？在JDK1.5之后，java.util.concurrent.atomic包下为我们封装了常用的原子变量，他们底层就是使用了<strong>CAS</strong>（compare and swap）算法来保证原子性，我们将上面例子中的serialNumber改为使用AtomicInteger修饰，然后运行发现也可以得到正确的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	private volatile int serialNumber = 0;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serialNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="二、什么是CAS？"><a href="#二、什么是CAS？" class="headerlink" title="二、什么是CAS？"></a>二、什么是CAS？</h2><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。<br>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。<br>来看一个例子：<br>我们现在有两个线程：<br>1.在内存地址V当中，存储着值为10的变量。<br>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。<br>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。<br>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。<br>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。<br>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。<br>7.线程1进行SWAP，把地址V的值替换为B，也就是12。<br>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<h2 id="三、CAS的缺点"><a href="#三、CAS的缺点" class="headerlink" title="三、CAS的缺点"></a>三、CAS的缺点</h2><p>CAS机制这么巧妙，是不是在任何地方都比同步锁要好？然而并不是这样的，CAS机制有以下几个问题：</p>
<ul>
<li><strong>CPU开销较大</strong><br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
<li><strong>不能保证代码块的原子性</strong><br>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</li>
<li><p><strong>ABA问题</strong><br>什么是ABA呢？简单说就是一个值从A改成了B，又从B改成了A。<br>1.假设内存中有一个值为A的变量，存储在地址V当中。<br>2.此时有三个线程想使用CAS的方式更新这个变量值，每个线程的执行时间有略微的偏差。线程1和线程2已经获得当前值，线程3还未获得当前值。<br>3.接下来，线程1先一步执行成功，把当前值成功从A更新为B；同时线程2因为某种原因被阻塞住，没有做更新操作；线程3在线程1更新之后，获得了当前值B。<br>4.再之后，线程2仍然处于阻塞状态，线程3继续执行，成功把当前值从B更新成了A。<br>5.最后，线程2终于恢复了运行状态，由于阻塞之前已经获得了“当前值”A，并且经过compare检测，内存地址V中的实际值也是A，所以成功把变量值A更新成了B。<br>6.这个过程中，线程2获取到的变量值A是一个旧值，尽管和当前的实际值相同，但内存地址V中的变量已经经历了A-&gt;B-&gt;A的改变。<br>从表面看起来运行结果好像没什么问题，但是结合实际情况就会出现问题了。比如取款时有可能发生两个线程同时扣款成功的情况。所以，真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。<br>在Java当中，AtomicStampedReference类就实现了用版本号做比较的CAS机制。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2></li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192625&amp;idx=1&amp;sn=cbabbd806e4874e8793332724ca9d454&amp;chksm=8c99f36bbbee7a7d169581dedbe09658d0b0edb62d2cbc9ba4c40f706cb678c7d8c768afb666&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">漫画：什么是 CAS 机制？</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloCAS/">http://catalinali.top/2018/helloCAS/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-e74f791fa0e5c43f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也许大家已经听说过，锁分两种，一个叫悲观锁，一种称之为乐观锁。Synchronized就是悲观锁的一种，也称之为独占锁，加了synchronized关键字的代码基本上就只能以单线程的形式去执行了，它会导致其他需要该资源的线程挂起，直到前面的线程执行完毕释放所资源。而另外一种乐观锁是一种更高效的机制，它的原理就是每次不加锁去执行某项操作，如果发生冲突则失败并重试，直到成功为止，其实本质上不算锁，所以很多地方也称之为自旋。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="juc" scheme="http://catalinali.top/categories/juc/"/>
    
    
      <category term="juc" scheme="http://catalinali.top/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程(一)：理解volatile关键字</title>
    <link href="http://catalinali.top/2018/helloVolatile/"/>
    <id>http://catalinali.top/2018/helloVolatile/</id>
    <published>2018-08-15T02:11:12.000Z</published>
    <updated>2018-11-12T06:42:59.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-1ee2de3eaca0668e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_logo"></p>
<blockquote>
<p>Java中volatile这个热门的关键字，在面试中经常会被提及，在各种技术交流群中也经常被讨论：volatile关键字在java多线程中有着比较重要作用，volatile主要作用是可以保持变量在多线程中是实时可见的,是java中提供的最轻量的同步机制。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、JAVA内存模型概述"><a href="#一、JAVA内存模型概述" class="headerlink" title="一、JAVA内存模型概述"></a>一、JAVA内存模型概述</h2><p>在了解volatile关键字之前，我们先来认识一下Java的内存模型。<br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意如图所示<br><img src="http://upload-images.jianshu.io/upload_images/3962292-cdc87cd855505d31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_1"><br>如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。<br>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>2）线程B到主内存中去读取线程A之前已更新过的共享变量。<br>这个模型在单线程中没有什么问题，但是在多线程中就会产生一些数据的“脏读”等问题。<br>举个简单的例子：在java中，使用两个线程执行下面这个语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>我们期望的是在两个线程执行完之后获得i的结果是2，但事实真的会这样的吗？<br>我们反复执行后可以发现：结果可能是2，也可能是1。<br>每条线程执行时需要将i的值从主内存中读取到工作内存中。其中存在这么一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的工作内存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。当出现这种情况后返回的结果就成了1了。<br>这就是缓存一致性的问题，在解决这个问题前我们要先了解一下并发编程的三个概念：原子性，有序性，可见性。</p>
<h2 id="二、并发编程中的三个概念"><a href="#二、并发编程中的三个概念" class="headerlink" title="二、并发编程中的三个概念"></a>二、并发编程中的三个概念</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>定义：原子操作意 为“不可被中断的一个或一系列操作。<br>比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。如果一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。<br>如果要实现更大范围操作的原子性，可以通过<strong>锁</strong>和<strong>CAS算法</strong>来实现。</p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>定义：可见性是指当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure></p>
<p>由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>定义：即程序执行的顺序按照代码的先后顺序执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。<br>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。<br>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：<br><img src="http://upload-images.jianshu.io/upload_images/3962292-09441fc193e78b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile_2"><br>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line"></span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"></span><br><span class="line"> //线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">   sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。<br>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h2 id="三、深入理解volatile关键字"><a href="#三、深入理解volatile关键字" class="headerlink" title="三、深入理解volatile关键字"></a>三、深入理解volatile关键字</h2><p>　在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的 synchronized。如果volatile变量修饰符使用恰当 的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h3 id="1-volatile的作用"><a href="#1-volatile的作用" class="headerlink" title="1.volatile的作用"></a>1.volatile的作用</h3><p>　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>　　1）保证了内存的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>　　2）禁止进行指令重排序。</p>
<h3 id="1-volatile不能保证原子性"><a href="#1-volatile不能保证原子性" class="headerlink" title="1.volatile不能保证原子性"></a>1.volatile不能保证原子性</h3><p>我们来看下面这一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写”</span></span><br><span class="line"><span class="comment"> * 		  int i = 10;</span></span><br><span class="line"><span class="comment"> * 		  i = i++; //10</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		  int temp = i;</span></span><br><span class="line"><span class="comment"> * 		  i = i + 1;</span></span><br><span class="line"><span class="comment"> * 		  i = temp;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(getSerialNumber());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> serialNumber++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反复运行这段代码，发现结果并不是每次都是0-9,而是有可能会有重复结果出现。<br>自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行：<br>线程1对变量进行读取操作之后，被阻塞了的话，并没有对serialNumber值进行修改。虽然volatile能保证线程2对变量serialNumber的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。那么原子性问题究竟应该怎么解决呢？我们在下篇文章中会给出详细解答。</p>
<h2 id="四、volatile关键字的应用场景"><a href="#四、volatile关键字的应用场景" class="headerlink" title="四、volatile关键字的应用场景"></a>四、volatile关键字的应用场景</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>1）对变量的写操作不依赖于当前值<br>2）该变量没有包含在具有其他变量的不变式中</p>
<p>下面列举几个Java中使用volatile的几个场景。<br><strong>1.状态标记量</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">根据状态标记，终止线程。</span><br></pre></td></tr></table></figure></p>
<p><strong>2.单例模式中的double check</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么要使用volatile 修饰instance？<br>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:<br>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.baidu.com/s?wd=java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF&amp;rsv_spt=1&amp;rsv_iqid=0xc652b9a6000070c7&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;oq=java%25E5%25B9%25B6%25E5%258F%2591%25E7%25BC%2596%25E7%25A8%258B%25E7%259A%2584%25E8%2589%25BA%25E6%259C%25AFpdf&amp;inputT=1301&amp;rsv_t=9400ch8xJFe67WDXfsXzKSARdHHTqMDsYP9q4z0hVkvXwCg7TDPQj8n8kCqdXIhmXqYR&amp;rsv_pq=cec2174c00008def&amp;rsv_sug3=20&amp;rsv_sug4=1301" target="_blank" rel="noopener">《java并发编程的艺术》</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></li>
<li><a href="https://blog.csdn.net/it_dx/article/details/70045286?locationNum=4&amp;fps=1" target="_blank" rel="noopener">Java中volatile关键字详解（2）？真正了解volatile</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloVolatile/">http://catalinali.top/2018/helloVolatile/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-1ee2de3eaca0668e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;volatile_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java中volatile这个热门的关键字，在面试中经常会被提及，在各种技术交流群中也经常被讨论：volatile关键字在java多线程中有着比较重要作用，volatile主要作用是可以保持变量在多线程中是实时可见的,是java中提供的最轻量的同步机制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="juc" scheme="http://catalinali.top/categories/juc/"/>
    
    
      <category term="juc" scheme="http://catalinali.top/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>小白学SpringCloud(六)：服务降级（Hystrix）</title>
    <link href="http://catalinali.top/2018/startHystrix/"/>
    <id>http://catalinali.top/2018/startHystrix/</id>
    <published>2018-08-06T01:40:58.000Z</published>
    <updated>2018-11-12T06:38:19.496Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-ae286ea5393ce055.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hystrix_logo"></p>
<blockquote>
<p>在微服务架构中，我们将系统拆分为很多个服务，各个服务之间通过注册与订阅的方式相互依赖，由于各个服务都是在各自的进程中运行，就有可能由于网络原因或者服务自身的问题导致调用故障或延迟，随着服务的积压，可能会导致服务崩溃。为了解决这一系列的问题，断路器等一系列服务保护机制出现了。<br><a id="more"></a></p>
</blockquote>
<h2 id="一、Hystrix简介"><a href="#一、Hystrix简介" class="headerlink" title="一、Hystrix简介"></a>一、Hystrix简介</h2><p>Netflix提供了一个叫Hystrix的类库，它实现了断路器模式。在微服务架构中，通常一个微服务会调用多个其他的微服务。一个相对低层级的服务失败可能造成上层应用的级联失败，服务访问量越大失败率越高。当断路打开的时候，这个调用就被终止了。打开的断路可以阻止级联失败。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-0663026043bf85a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hystrix_1"><br>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-c4a8b1078ee2dbbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hystrix_2"></p>
<h2 id="二、Hystrix使用"><a href="#二、Hystrix使用" class="headerlink" title="二、Hystrix使用"></a>二、Hystrix使用</h2><p>这里我们使用之前的Client项目进行演示。<br><strong>1.在服务调用方添加pom</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.添加@EnableCircuitBreaker注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="comment">//@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时我们发现我们的启动类上添加了很多的注解，所以Spring Cloud将这些注解封装了一下，提供了一个@SpringCloudApplication的注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public @interface SpringCloudApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.对要服务进行降级</strong><br>之前的例子里我们有一个<em>restHello</em>的接口,这个接口调用的Discovery的<em>hello</em>接口。<br>我们现在在他上面添加一个@HystrixCommand注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod  = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/restHello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用fallbackMethod属性指定一个fallback方法，在需要降级的时候调用这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">helloFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"哎呀，服务器开小差了！请稍后再试。"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们将服务端和客户端都启动进行访问<br><img src="http://upload-images.jianshu.io/upload_images/3962292-eac6f600a0451dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hystrix_3"><br>这时候我们将服务端Discover关掉然后再访问这个地址，他就会去访问降级的地址<br><img src="http://upload-images.jianshu.io/upload_images/3962292-921e057f06b161a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hystrix_4"><br>这样我们就实现了服务降级。但是这样需要没一个接口都添加这个注解，有没有更快一点的方法呢？</p>
<p><strong>4.配置默认服务降级注解</strong><br>在类上添加@DefaultProperties注解配置默认的降级方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientController</span> </span>&#123;</span><br><span class="line">        <span class="comment">//@HystrixCommand(fallbackMethod  = "helloFallback")</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/restHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helloFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"哎呀，服务器开小差了！请稍后再试。"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们再进行刚才的操作，可以发现是同样的效果^_^<br><img src="http://upload-images.jianshu.io/upload_images/3962292-34621cd535b6d54a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hystrix_4"></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startHystrix/">http://catalinali.top/2018/startHystrix/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-ae286ea5393ce055.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;hystrix_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在微服务架构中，我们将系统拆分为很多个服务，各个服务之间通过注册与订阅的方式相互依赖，由于各个服务都是在各自的进程中运行，就有可能由于网络原因或者服务自身的问题导致调用故障或延迟，随着服务的积压，可能会导致服务崩溃。为了解决这一系列的问题，断路器等一系列服务保护机制出现了。&lt;br&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://catalinali.top/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://catalinali.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>小白学SpringCloud(五)：路由网关（Zuul）</title>
    <link href="http://catalinali.top/2018/startZuul/"/>
    <id>http://catalinali.top/2018/startZuul/</id>
    <published>2018-07-10T10:15:28.000Z</published>
    <updated>2018-11-12T06:50:37.663Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-0196ff9f46197af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul_logo"></p>
<blockquote>
<p>在微服务的架构下，各个服务一般会有各自的网络地址，在这样的情况下外部客户端的调用可能会形成杂乱无章的局面。这时候我们就可以使用微服务网关Zuul这个组件，我们让所有的客户端请求全部请求Zuul，再由Zuul统一的去请求各个服务。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、Zuul简介"><a href="#一、Zuul简介" class="headerlink" title="一、Zuul简介"></a>一、Zuul简介</h2><p>Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：</p>
<ul>
<li>身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</li>
<li>审查与监控：</li>
<li>动态路由：动态将请求路由到不同后端集群</li>
<li>压力测试：逐渐增加指向集群的流量，以了解性能</li>
<li>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li>静态响应处理：边缘位置进行响应，避免转发到内部集群</li>
<li>多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化</li>
</ul>
<p>Spring Cloud对Zuul进行了整合和增强。目前，Zuul使用的默认是Apache的HTTP Client，也可以使用Rest Client，可以设置ribbon.restclient.enabled=true.。</p>
<h2 id="二、创建一个api-gateway工程"><a href="#二、创建一个api-gateway工程" class="headerlink" title="二、创建一个api-gateway工程"></a>二、创建一个api-gateway工程</h2><p>这里我们使用IntelliJ IDEA进行展示。<br><strong>1.首先创建一个Zuul项目</strong><br>使用IDEA创建一个项目<br><img src="http://upload-images.jianshu.io/upload_images/3962292-b79c552c2c709087.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_2"><br>中间有一步我们选择Zuul选项和SpringBoot版本，如图<br><img src="http://upload-images.jianshu.io/upload_images/3962292-bddeee8a3e4e947c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_2"><br>然后下一步就可以创建好了<br><strong>2.添加@EnableZuulProxy注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGetwayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGetwayApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在配置文件中添加config的配置，具体可以见<a href="http://catalinali.top/2018/startconfig/">小白学SpringCloud(三)：统一配置中心(config)</a>。然后就可以使用Zuul工程的路由了，依次运行Eureka、Config、Client客户端、Zuul。<br>我们先来随便访问一下client端的env接口<br><img src="http://upload-images.jianshu.io/upload_images/3962292-647dd90de5e26676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul_2"><br>然后我们通过<em>zuul服务的端口+项目名/接口名</em>这种方式来访问一下这个接口<br><img src="http://upload-images.jianshu.io/upload_images/3962292-40ab3d967fd21088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul_3"><br>可以看到,同样访问到了结果。<br>另外，我们也可以在配置文件中更加细粒度控制路由路径：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示只要HTTP请求是 /client1开始的，就会转发到服务id为client1的服务上面</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    client1:</span></span><br><span class="line"><span class="attr">      path:</span><span class="string">/client1/**</span>  <span class="string">//</span> <span class="string">路由路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">client1</span> <span class="string">//</span> <span class="string">服务id</span></span><br><span class="line"><span class="attr">    client2:</span></span><br><span class="line"><span class="attr">      path:</span><span class="string">/client2/**</span>  <span class="string">//</span> <span class="string">路由路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">client2</span> <span class="string">//</span> <span class="string">服务id</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，使用Zuul默认不会将Cookie的信息带入服务端，所以我们需要在配置文件中进行配置,将敏感头设置为空即可：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  sensitiveHeaders:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二、服务过滤"><a href="#二、服务过滤" class="headerlink" title="二、服务过滤"></a>二、服务过滤</h2><p>zuul不仅只是路由，并且还能过滤，做一些安全验证。我们来新建一个Filter并且继承ZuulFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_DECORATION_FILTER_ORDER;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: lllx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created on 17:54 2018/7/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modefied</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*返回一个字符串代表过滤器的类型</span></span><br><span class="line"><span class="comment">    pre：路由之前</span></span><br><span class="line"><span class="comment">    routing：路由之时</span></span><br><span class="line"><span class="comment">    post： 路由之后</span></span><br><span class="line"><span class="comment">    error：发送错误调用</span></span><br><span class="line"><span class="comment">    我们可以通过导入FilterConstants这个常量类中的属性来返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤的顺序，Zuul中也自定义了很多过滤器，调用的顺序即通过这个方法返回的大小，越小越靠前。我们可以通过FilterConstants这个常量类中定义好的过滤器-1来返回</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_DECORATION_FILTER_ORDER -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = requestContext.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从url参数获取如果没有token这个参数就不允许请求</span></span><br><span class="line">        String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            requestContext.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过这样的方式去自定义一个个的过滤器。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startZuul/">http://catalinali.top/2018/startZuul/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-0196ff9f46197af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;zuul_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在微服务的架构下，各个服务一般会有各自的网络地址，在这样的情况下外部客户端的调用可能会形成杂乱无章的局面。这时候我们就可以使用微服务网关Zuul这个组件，我们让所有的客户端请求全部请求Zuul，再由Zuul统一的去请求各个服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://catalinali.top/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://catalinali.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>小白学SpringCloud(四)：消息总线（Spring Cloud Bus）</title>
    <link href="http://catalinali.top/2018/startbus/"/>
    <id>http://catalinali.top/2018/startbus/</id>
    <published>2018-07-02T06:33:08.000Z</published>
    <updated>2018-11-12T06:39:27.185Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-1bdafcb6a0c162eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bus_logo"></p>
<blockquote>
<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。上篇我们有说到Spring Cloud为我们提供了在不重启项目的情况下切换配置的功能，就要用到它，让我们来看看怎么实现的吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、安装MQ"><a href="#一、安装MQ" class="headerlink" title="一、安装MQ"></a>一、安装MQ</h2><p>Spring Cloud Bus支持常见的Rabbitmq、kafka、Activemq等。我们这里使用Rabbitmq来作为演示。Rabbitmq的安装这里就不作演示了，大家可以使用docker来安装使用，很方便。给大家一个度娘的<a href="https://www.baidu.com/s?wd=docker%E5%AE%89%E8%A3%85activemq&amp;rsv_spt=1&amp;rsv_iqid=0xf5578fe4000354b9&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;oq=docker%2520%25E5%25AE%2589%25E8%25A3%2585activemq&amp;inputT=1021&amp;rsv_t=11e21%2FaLzaFQGzuvMvLtKuHmxzuLUWS0TB6d8t9pETvwOEs%2B0fjRN9KsfhoNwJv1cAky&amp;rsv_pq=ef4e2567000322af&amp;sug=activemq&amp;rsv_sug3=21&amp;rsv_sug1=17&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=1751" target="_blank" rel="noopener">传送门</a>。</p>
<h2 id="二、Config-Server配置"><a href="#二、Config-Server配置" class="headerlink" title="二、Config Server配置"></a>二、Config Server配置</h2><p>这里我们还是以廖师兄的图为例，先来看看自动更新配置的原理(图中product、order均为客户端)。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-611760fc9abe2a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bus_1"><br>当我们在远端Git修改了配置之后，如果我们访问Config Server的<code>/bus-refresh</code>接口，Config Server就会把更改的配置发送给MQ，之后MQ就会把要改变的配置推送给各个客户端，这样就实现了自动更换配置的功能，现在我们来试一试吧。记住在这之前要先启动Rabbitmq。<br><strong>1.</strong>添加pom引用<br>老规矩，先来添加pom引用，要注意的是Config的Server和Client端都要添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong>修改配置文件<br>首先我们要先添加rabbitmq的配置，我们可以直接配置在远程git上面，这样服务端和客户端就都有这份配置了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="string">.xxx.xxx</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们也要显示的使我们的服务暴漏<code>/bus-refresh</code>接口。在Spring2.0中把这个接口都移动到了<em>actuator</em>下面。这个只需要在Config端进行配置就好了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">bus-refresh</span> <span class="comment">#也可以改为"*"来暴露所有接口</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们逐一启动我们的Eureka、Config和Client项目，同时在启动Config Server的时候可以看到我们对外暴露的接口<br><img src="http://upload-images.jianshu.io/upload_images/3962292-93427423681e0aa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bus_2"><br>这样我们就完成配置了，现在我们修改一下远端配置中的<code>env</code>的值，然后访问一下这个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8764/actuator/bus-refresh</span><br></pre></td></tr></table></figure></p>
<p>这时候我们发现在不重启项目的情况下，我们的配置已经修改了。<br><strong>3.</strong>配置Webhook<br>刚才我们已经实现了自动替换项目配置，但是我们每次更改配置都要手动访问<code>/bus-refresh</code>接口，有没有简单的方式呢?答案当然是有的。现在大部分远端Git都提供了webhook功能，即我们每更改一次配置，就自动向某一接口发送一次请求。这不就是我们想要的吗？</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startbus/">http://catalinali.top/2018/startbus/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-1bdafcb6a0c162eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;bus_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。上篇我们有说到Spring Cloud为我们提供了在不重启项目的情况下切换配置的功能，就要用到它，让我们来看看怎么实现的吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://catalinali.top/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://catalinali.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>小白学SpringCloud(三)：统一配置中心(config)</title>
    <link href="http://catalinali.top/2018/startconfig/"/>
    <id>http://catalinali.top/2018/startconfig/</id>
    <published>2018-06-15T07:45:19.000Z</published>
    <updated>2018-11-12T06:39:13.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-62ca605cfc26e971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config_logo"></p>
<blockquote>
<p>在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成。如果我们每个服务都有一个独立的配置的话，这样很不方便我们维护。Spring Cloud中为我们提供了一个config组件为我们解决了这个问题，并且更改了配置并不需要我们重启。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Config概述"><a href="#一、Config概述" class="headerlink" title="一、Config概述"></a>一、Config概述</h2><p>同Eureka一样，config也分为server端和client端，我们先来看看server端的原理。这里引用一张廖师兄的图（注：图中的order、product都是客户端）<br><img src="http://upload-images.jianshu.io/upload_images/3962292-b00594da29c8fa54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config_1"><br>从这张图我们可以看出，Config Server是以远端Git作为依托（SVN也可以,这里使用Github作为演示），从远端Git仓库中拉取配置并同步到本地Git上。当客户端需要配置的时候就可以从Server端进行配置的拉取。</p>
<h2 id="二、Config-Server配置"><a href="#二、Config-Server配置" class="headerlink" title="二、Config Server配置"></a>二、Config Server配置</h2><p><strong>1.</strong>创建Config工程<br>跟前文一样，我们使用IDEA的Spring Initializr创建我们的Config工程，如图:除了图中圈起来的config Server要勾上，Eureka Discover也要勾上。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-452ae02135db574d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config_2"></p>
<p><strong>2.</strong>创建远程仓库<br>首先我们先创建一个远程Git仓库，这里以Github为例，这里我已经创建好了一个公开仓库<a href="https://github.com/catalinaLi/config_repo" target="_blank" rel="noopener">https://github.com/catalinaLi/config_repo</a><br>然后在里面先添加一份配置<br><img src="http://upload-images.jianshu.io/upload_images/3962292-dca270a81063ad0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config_3"><br><strong>3.</strong>配置Config工程<br>将我们的Config工程注册到Eureka注册中心：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8764</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/catalinaLi/config_repo</span> <span class="comment">#config_Server仓库地址</span></span><br><span class="line">          <span class="comment">#如果我们配置的是私有仓库，则还需要远程仓库的账号和密码</span></span><br><span class="line">          <span class="comment">#username: yourusername  </span></span><br><span class="line">          <span class="comment">#password: yourpassword</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="string">dev</span></span><br></pre></td></tr></table></figure></p>
<p>然后在启动类上添加注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.</strong> Config Server配置<br>接下来就可以通过网络来访问我们的配置了，首先启动注册中心Eureka，然后启动我们的Config。这时候我们通过浏览器访问<a href="http://localhost:8764/client-dev.yml" target="_blank" rel="noopener">http://localhost:8764/client-dev.yml</a>就可以看到我们的配置了。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-84f14530c33c9004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config_5"><br>这里是Spring Cloud对配置请求的路径做了映射,通常为：</p>
<ul>
<li>/{name}-{profiles}.yml</li>
<li>/{label}/{name}-{profiles}.yml</li>
</ul>
<p>这两种方式大家可以挑选一个适合你的。<br>后缀名也可以不是yml，你可以试试properties，json。Spring Cloud会自动帮你转换。</p>
<h2 id="三、Config-Client配置"><a href="#三、Config-Client配置" class="headerlink" title="三、Config Client配置"></a>三、Config Client配置</h2><p>这里我们使用上一篇文章<a href="http://catalinali.top/2018/startfeignRest/">小白SpringCloud(二)：服务间的调用</a>中的Client项目来进行改造<br><strong>1.添加pom引用</strong><br>在FeignClient的pom文件中添加Config Client引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.修改配置文件</strong><br>首先我们要把配置文件的名字改为<strong>bootstrap.yml</strong>，改成这个名字Spring Cloud就会先去Config Server拉取配置。<br>然后我们要在bootstrap.yml中定义我们要拉取的文件名称，还记得刚才说的Spring Cloud对请求的路径做的映射方式吗(/{name}-{profiles}.yml)？在这里我们配置<em>name</em>、<em>profiles</em>和<em>Config项目的名称</em></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#name</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">config</span> <span class="comment">#Eureka Config's name</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span> <span class="comment">#profiles</span></span><br></pre></td></tr></table></figure>
<p>这时候，我们的Client就可以正常启动啦，怎么样简单吧。</p>
<h2 id="二、Config-Server的高可用"><a href="#二、Config-Server的高可用" class="headerlink" title="二、Config Server的高可用"></a>二、Config Server的高可用</h2><p>统一配置中心的高可用很简单，只需要我们多启动几个相同的实例就好了。Config Client在启动的时候会根据负载均衡去访问Config Server中的某一台.</p>
<p>还记得导语中说的更改配置可以不用重新启动项目吗？这里需要用到另外一个组件，我们在下篇文章进行讲解。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/config/">http://catalinali.top/2018/config/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-62ca605cfc26e971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;config_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成。如果我们每个服务都有一个独立的配置的话，这样很不方便我们维护。Spring Cloud中为我们提供了一个config组件为我们解决了这个问题，并且更改了配置并不需要我们重启。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://catalinali.top/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://catalinali.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>小白学SpringCloud(二)：服务间的调用</title>
    <link href="http://catalinali.top/2018/startfeignRest/"/>
    <id>http://catalinali.top/2018/startfeignRest/</id>
    <published>2018-06-05T02:07:05.000Z</published>
    <updated>2018-11-12T06:38:37.540Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-cb3a0601d6b8becc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="feign&amp;Rest_logo"></p>
<blockquote>
<p>SpringCloud服务间的调用有两种方式：RestTemplate和FeignClient。不管是什么方式，他都是通过REST接口调用服务的http接口，参数和结果默认都是通过jackson序列化和反序列化。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Ribbon简介"><a href="#一、Ribbon简介" class="headerlink" title="一、Ribbon简介"></a>一、Ribbon简介</h2><p>在说这两种方式之前，我们先来简单的看一下Ribbon。</p>
<blockquote>
<p>Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.</p>
</blockquote>
<p>这是官网对Ribbon的简介，简单的说Ribbon是一个负载均衡客户端，SpringCloud的两种服务间调用方式背后都用了Ribbon。</p>
<h2 id="二、使用RestTemplate进行服务调用"><a href="#二、使用RestTemplate进行服务调用" class="headerlink" title="二、使用RestTemplate进行服务调用"></a>二、使用RestTemplate进行服务调用</h2><p>代码Demo接上篇<a href="http://catalinali.top/2018/startEureka/">SpringCloud(一)：服务的注册与发现（Eureka）</a><br><strong>1.</strong>我们首先启动端口为8761的eureka工程，把SpringCloud的服务注册中心启动。</p>
<p><strong>2.</strong>打开我们的Discovery工程。这时候Discovery工程相当于服务端，我们来为它写一个提供服务的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello! 我是"</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后将配置文件中的端口改为8762和8763分别启动。<br>如果你使用的是IDEA的话，只需要去掉下图中红框框住的部分就可以将同一工程启动多个实例<br><img src="http://upload-images.jianshu.io/upload_images/3962292-9c024f444feabe8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rest_1"><br>这时，我们就拥有了端口为8762和8763的两个Discovery集群，Eureka中可以看到<br><img src="http://upload-images.jianshu.io/upload_images/3962292-b110811fc70ff1fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="feign&amp;Rest_2"><br><strong>3.</strong>我们再新建一个Eureka-Discovery工程（可以参照上一篇文章），首先为他配置好Eureka-Client的配置。在配置文件中为它指定端口为8764：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8764</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#客户端名称</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们为它添加一个RestTemplate的配置Bean，可以参照如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后我们就可以在需要调用的地方用如下方式进行调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cliHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数为：服务端的应用名称/调用接口的Mapping</span></span><br><span class="line">        <span class="comment">//第二个参数为返回的类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如图：<br><img src="http://upload-images.jianshu.io/upload_images/3962292-d32b6de8827e0976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="feign&amp;Rest_3"><br>这里因为Ribbon的默认负载均衡方式为轮询，所以我们可以看到端口8762和8763依次出现。如果有想改变负载均衡方式的小伙伴可以下去自行研究一下，这里就不过多赘述了。</p>
<h2 id="三、使用Feign进行服务调用"><a href="#三、使用Feign进行服务调用" class="headerlink" title="三、使用Feign进行服务调用"></a>三、使用Feign进行服务调用</h2><p><strong>1.添加Feign的pom引用</strong><br>在FeignClient的pom文件中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是版本一定要跟我的一致，否则添加的依赖有可能会不一样<br><strong>2.为启动类添加注解</strong><br>这一步很简单，只需要在在启动类上添加<code>@EnableFeignClients</code>注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class ClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.定义一个Feign接口</strong><br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name是服务端的名称</span></span><br><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"discovery"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url是调用服务的url值</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.调用</strong><br>在配置了Feign接口后，我们就可以直接进行注入调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/feignHello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">feignHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloClient.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的结果跟RestTemplate也相同<br><img src="http://upload-images.jianshu.io/upload_images/3962292-b24f4d1c3624f57f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="feign&amp;Rest_3_1"><br>从这里我们可以看到，使用Feign是伪分布式的调用方式。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startfeign&amp;Rest/">http://catalinali.top/2018/startfeign&amp;Rest/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-cb3a0601d6b8becc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;feign&amp;amp;Rest_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SpringCloud服务间的调用有两种方式：RestTemplate和FeignClient。不管是什么方式，他都是通过REST接口调用服务的http接口，参数和结果默认都是通过jackson序列化和反序列化。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://catalinali.top/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://catalinali.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>小白学SpringCloud(一)：服务的注册与发现（Eureka）</title>
    <link href="http://catalinali.top/2018/startEureka/"/>
    <id>http://catalinali.top/2018/startEureka/</id>
    <published>2018-05-31T10:19:58.000Z</published>
    <updated>2018-11-12T06:49:48.420Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-ab00c7411900a8c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_logo"></p>
<hr>
<a id="more"></a>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>首先我们先引用Dubbo官网的一段话</p>
<ul>
<li>单一应用架构<br>  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>  此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</li>
<li>垂直应用架构<br>  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>  此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</li>
<li>分布式服务架构<br>  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中 心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</li>
<li>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA) 是关键。</li>
</ul>
<p>结合现在大火的微服务，SpringCloud成了炙手可热的微服务架构方案，这里我们介绍一个他的核心组件：Eureka ,eureka是一个服务注册和发现模块。类似于Dubbo的管控台。它分为两个模块:客户端和服务端</p>
<h2 id="二、创建一个Eureka-Server"><a href="#二、创建一个Eureka-Server" class="headerlink" title="二、创建一个Eureka Server"></a>二、创建一个Eureka Server</h2><p>这里我们使用IntelliJ IDEA进行展示。<br><strong>1.首先创建一个Eureka Server</strong><br>使用IDEA创建一个项目。这里SpringBoot我们统一使用2.0.2版本，SpringCloud使用Finchley.RELEASE版本<br><img src="http://upload-images.jianshu.io/upload_images/3962292-040720dc5c9e1cb6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_2"><br>中间有一步我们选择Eureka Server选项和SpringBoot版本，如图<br><img src="http://upload-images.jianshu.io/upload_images/3962292-a5ce7d923985a2fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_2"><br>然后下一步就可以创建好了<br><strong>2.添加@EnableEurekaServer注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们就可以启动了，运行EurekaApplication，然后就输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>就可以看到我们Eureka的页面了。但这时候我们观察console可以发现一直在报错，这是因为默认情况下Eureka Server也是一个Client,我们需要通过配置来解决这个问题<br><strong>3.添加配置</strong><br>eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个server。eureka server的配置文件appication.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka</span> <span class="comment">#应用的名称</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">    <span class="comment"># 通过添加配置我们这里忽略自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#表示是否注册自身到eureka服务器</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment">#表示是否从eureka服务器获取注册信息</span></span><br></pre></td></tr></table></figure></p>
<p>这时候再启动应用，就大功告成了<br><img src="http://upload-images.jianshu.io/upload_images/3962292-2794ae9cf1a788e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_4"></p>
<h2 id="三、创建一个Eureka-Client"><a href="#三、创建一个Eureka-Client" class="headerlink" title="三、创建一个Eureka Client"></a>三、创建一个Eureka Client</h2><p><strong>1.运行Eureka Server</strong><br>这里我们可以使用命令行在Eureka Server的目录位置使用<code>mvn clean package</code>来进行打包<br>然后使用<code>java -jar target/eureka-0.0.1-SNAPSHOT.jar</code>命令来进行启动jar包<br>也可以使用<code>nohup java -jar target/eureka-0.0.1-SNAPSHOT.jar &amp;</code>来后台启动这个jar。<br>最后刷新Eureka Server来判断是否启动成功<br><strong>2.创建一个Eureka Client</strong><br>这一步跟创建Server端的步骤是一样的，不同的是模板选择Discovery<br><img src="http://upload-images.jianshu.io/upload_images/3962292-1c39334b0a04fc1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_5"><br><strong>3.添加@EnableEurekaServer注解和服务端地址</strong><br>基本和服务端的做法一样，首先我们在DicoveryApplication.java的代码上添加@EnableDiscoveryClient注解。然后在application.yml上添加配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DicoveryApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DicoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#客户端名称</span></span><br></pre></td></tr></table></figure>
<p>注意了，这个版本我们需要在pom文件中添加<code>spring-boot-starter-web</code>的依赖，<br>这时候我们就可以启动我们的服务了，然后就可以在eureka的页面上看到我们刚才的Client了<br><img src="http://upload-images.jianshu.io/upload_images/3962292-0b366efb0d3611c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_6"></p>
<h2 id="三、Eureka-Server的高可用"><a href="#三、Eureka-Server的高可用" class="headerlink" title="三、Eureka Server的高可用"></a>三、Eureka Server的高可用</h2><p>简单的说，实现Eureka Server的高可用就是让Eureka Server的实例互相注册。<br>让我们来看一下如何实现：<br>首先我们配置文件中这样写<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">discovery-cluster</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">discovery1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">discovery1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      default-zone:</span> <span class="attr">http://discovery2:8762/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">discovery2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">discovery2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      default-zone:</span> <span class="attr">http://discovery1:8761/eureka</span></span><br></pre></td></tr></table></figure></p>
<p>配置文件是通过两个Eureka Server互相注册，这里有三段配置，第一段配置为公共配置，配置了应用名称，第二段为名discovery1的配置，第三段为discovery2的配置。在项目启动可以通过–spring.profiles.active={配置名称} 来启动不同的配置。<br>下面我们来进行测试：<br>1）在discovery-cluster目录下，使用<code>mvn clean package</code>打包项目<br>2）使用下面命令启动两个Eureka Server节点<br><code>java -jar discovery-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=discovery1</code></p>
<p><code>java -jar discovery-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=discovery2</code><br>3）在浏览器上分别输入<a href="http://localhost:8761和http://localhost:8762查看注册的服务。" target="_blank" rel="noopener">http://localhost:8761和http://localhost:8762查看注册的服务。</a><br>这时候我们可以发现两个网址都可以访问Eueka页面<br><img src="http://upload-images.jianshu.io/upload_images/3962292-6120ab29a7912677.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eureka_7"><br>这样我们就大功告成了，如我们我们的实例有3个，那就在配置文件中都写入<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">   client:</span></span><br><span class="line"><span class="attr">      service-url:</span></span><br><span class="line"><span class="attr">          default-zone:</span><span class="attr">http://discovery1:8761/eureka,http://discovery2:8762/eureka</span></span><br></pre></td></tr></table></figure></p>
<p>以上，就是Eureka的基本用法了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-ab00c7411900a8c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;eureka_logo&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://catalinali.top/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://catalinali.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>如何在同一台电脑上使用github和gitlab</title>
    <link href="http://catalinali.top/2018/noteGithubGitlab/"/>
    <id>http://catalinali.top/2018/noteGithubGitlab/</id>
    <published>2018-04-27T01:50:24.000Z</published>
    <updated>2018-11-12T06:41:24.768Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-049428adcf025967.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gitlabgithub_logo"></p>
<blockquote>
<p>换了工作后使用的是gitlab，这样对github的使用会有影响。为了解决这个问题，搜了很多资料后完美解决。现在把它记录下来。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在同一台电脑上使用github和gitlab，主要的思想就是使用不同的仓库时，切换成不同的账号。不同账号的sshKey分别对应github和gitlab。接下来跟着我看看怎么做吧^_^</p>
<h2 id="一、生成ssh密钥"><a href="#一、生成ssh密钥" class="headerlink" title="一、生成ssh密钥"></a>一、生成ssh密钥</h2><p>这里我们要做的事情就是分别对githubn和gitlab生成对应的密钥（默认情况下本地生成的秘钥位于/Users/用户名/.ssh/），并且配置git访问不同host时访问不同的密钥，流程如下：<br><strong>1、</strong> 在gitbash中使用<code>ssh-keygen -t rsa -C &quot;公司邮箱地址&quot;</code>生成对应的gitlab密钥：<em>id_rsa</em>和<em>id_rsa.pub</em><br><strong>2、</strong> 将gitlab公钥即<em>id_rsa.pub</em>中的内容配置到公司的gitlab上<br><strong>3、</strong> 在gitbash中使用<code>ssh-keygen -t rsa -C &quot;github地址&quot; -f ~/.ssh/github_rsa</code>生成对应的github密钥：<em>github_rsa</em>和<em>github_rsa.pub</em><br><strong>4、</strong> 将github公钥即<em>github_rsa.pub</em>中的内容配置到自己的github上<br><strong>5、</strong> 进入密钥生成的位置，创建一个<code>config</code>文件，添加配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line"><span class="string">Host</span> <span class="string">gitlab</span></span><br><span class="line">	<span class="string">HostName</span> <span class="string">git.xxx.com</span> <span class="comment">#这里填你的gitlab的Host</span></span><br><span class="line">	<span class="string">User</span> <span class="string">git</span></span><br><span class="line">	<span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="comment"># githab</span></span><br><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">	<span class="string">HostName</span> <span class="string">github.com</span></span><br><span class="line">	<span class="string">User</span> <span class="string">git</span></span><br><span class="line">	<span class="string">IdentityFile</span> <span class="string">~/.ssh/github_rsa</span></span><br></pre></td></tr></table></figure>
<h2 id="二、测试连接"><a href="#二、测试连接" class="headerlink" title="二、测试连接"></a>二、测试连接</h2><p>在密钥的生成位置/Users/用户名/.ssh/下使用gitbash运行<code>ssh -T git@hostName</code>命令测试sshkey对gitlab与github的连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catalinaLi@catalinaLi MINGW64 ~/.ssh</span><br><span class="line">$ ssh -T git@gitlab</span><br><span class="line">Welcome to GitLab, catalinaLi!</span><br><span class="line"></span><br><span class="line">catalinaLi@catalinaLi MINGW64 ~/.ssh</span><br><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi catalinaLi! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>如果出现上图结果就说明连接成功，如果不是这样的话就仔细看看第一步哪里做错了。</p>
<h2 id="三、配置git仓库"><a href="#三、配置git仓库" class="headerlink" title="三、配置git仓库"></a>三、配置git仓库</h2><p>这里我们要用到git的config配置。git的config文件记录了用户的基本信息，我们的账号信息也在里面，这里我们要做的就行在不同的本地仓库配置不同的用户信息来访问不同的远程仓库。config文件通常有三个位置：</p>
<ul>
<li>system （系统级别）：<br>  位于Windows下在git的安装目录， 包含了适用于系统所有用户和所有库的值。如果你传递参数选项’–system’ 给 git config，它将明确的读和写这个文件。 </li>
<li>global（用户级别）:<br>  位于~/.gitconfig，具体到你的用户。你可以通过传递–global 选项使Git 读或写这个特定的文件。</li>
<li>local（仓库级别）：<br>  位于 .git/config，无论你当前在用的库是什么，特定指向该单一的库。每个级别重写前一个级别的值。</li>
</ul>
<p>简单了解后我们就可以来配置了</p>
<p><strong>1.</strong> 用户级别配置<br>因为公司的代码使用频率较高，所以我们将git配置文件的global（用户级别）设置为公司的gitlab账号,在gitlab中使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &apos;catalinaLi&apos; #公司账号名称</span><br><span class="line">$ git config --global user.email &apos;catalinaLi@companyName.com&apos; #公司账号邮箱</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 仓库级别配置<br>我们将local（仓库级别）配置成github的账号。此时我们需要先<strong>init</strong>一个git的仓库并进入里面后执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --local user.name &apos;username&apos; #github账号名称</span><br><span class="line">$ git config --local user.email &apos;username@gmail.com&apos; #github账号邮箱</span><br></pre></td></tr></table></figure>
<p>之后我们github的代码都应该在这个仓库下拉取。</p>
<p><strong>3.</strong> 克隆代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:catalinaLi/ideaTaotao.git</span><br></pre></td></tr></table></figure>
<p>在使用github克隆代码时，因为配置了config, 所以会通过配置的host自动查找到git@github.com。对于gitlab也是相同的道理</p>
<p>至此，在同一台电脑上使用gitlab与github已经成功了，尽情感受吧。另外，大家可以寻找<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=git%20config&amp;oq=git%25E5%259B%25BE%25E7%2589%2587&amp;rsv_pq=8af24b1f00001879&amp;rsv_t=f935uktxm1WFti3L2TeFRHq8XdFpo%2B3%2FcGp%2F14sVbaYetcqU4uCbhZ5DCCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;inputT=1397&amp;rsv_sug3=14&amp;rsv_sug1=18&amp;rsv_sug7=100&amp;bs=git%E5%9B%BE%E7%89%87" target="_blank" rel="noopener">度娘</a>来学习关于git的config的更多使用</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.arccode.net/config-multi-git-account-and-workspaces.html" target="_blank" rel="noopener">http://www.arccode.net/config-multi-git-account-and-workspaces.html</a><br><a href="https://segmentfault.com/a/1190000002994742" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002994742</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/noteGithubGitlab/">http://catalinali.top/2018/noteGithubGitlab/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-049428adcf025967.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitlabgithub_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;换了工作后使用的是gitlab，这样对github的使用会有影响。为了解决这个问题，搜了很多资料后完美解决。现在把它记录下来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="git" scheme="http://catalinali.top/categories/git/"/>
    
    
      <category term="git" scheme="http://catalinali.top/tags/git/"/>
    
      <category term="github" scheme="http://catalinali.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>笔记：使用hexo，如果换了电脑怎么更新博客</title>
    <link href="http://catalinali.top/2018/noteHexoBak/"/>
    <id>http://catalinali.top/2018/noteHexoBak/</id>
    <published>2018-04-26T08:02:00.000Z</published>
    <updated>2018-11-12T06:41:08.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-8a1515a4832b96d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="note_hexo_install_logo"></p>
<blockquote>
<p>最近换了工作，忙着熟悉业务，好久没写博客了。换了新环境，好多东西都要重装。Hexo博客就是其中之一，这里我从万能的知乎上找了一个感觉很赞的方法，现在把文章搬运过来。话不多说，我们快来看看他是怎么做吧。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。但是考虑到如果每个GitHub Pages都需要额外的一个仓库存放这些文件，就显得特别冗余了。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。</p>
<h2 id="二、搭建的流程"><a href="#二、搭建的流程" class="headerlink" title="二、搭建的流程"></a>二、搭建的流程</h2><p><strong>1.</strong> 创建仓库，<a href="http://catalinaLi.github.io；" target="_blank" rel="noopener">http://catalinaLi.github.io；</a><br><strong>2.</strong> 创建两个分支：master 与 hexo；<br><strong>3.</strong> 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br><strong>4.</strong> 使用git clone git@github.com:catalinaLi/catalinaLi.github.io.git拷贝仓库；<br><strong>5.</strong> 在本地<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br><strong>6.</strong> 修改_config.yml中的deploy参数，分支应为master；<br><strong>7.</strong> 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；<br><strong>8.</strong> 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！</p>
<h2 id="三、日常的改动流程"><a href="#三、日常的改动流程" class="headerlink" title="三、日常的改动流程"></a>三、日常的改动流程</h2><p>在本地对博客进行修改、添加新博文、修改样式等等可以参照以下流程：<br><strong>1.</strong> 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；<br><strong>2.</strong> 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>
<h2 id="四、拉取备份"><a href="#四、拉取备份" class="headerlink" title="四、拉取备份"></a>四、拉取备份</h2><p>本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：<br><strong>1.</strong> 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；<br><strong>2.</strong> 在本地新拷贝的<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/noteHexoBak/">http://catalinali.top/2018/noteHexoBak/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-8a1515a4832b96d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;note_hexo_install_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近换了工作，忙着熟悉业务，好久没写博客了。换了新环境，好多东西都要重装。Hexo博客就是其中之一，这里我从万能的知乎上找了一个感觉很赞的方法，现在把文章搬运过来。话不多说，我们快来看看他是怎么做吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://catalinali.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://catalinali.top/tags/hexo/"/>
    
      <category term="note" scheme="http://catalinali.top/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>微信开发之微信网页授权获取openid</title>
    <link href="http://catalinali.top/2018/wechatOAuth/"/>
    <id>http://catalinali.top/2018/wechatOAuth/</id>
    <published>2018-02-26T08:21:09.000Z</published>
    <updated>2018-11-12T06:50:14.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3962292-6eb93042fa5fda95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechatOAuth_logo"></p>
<blockquote>
<p>不知觉间已经接触了几次微信支付开发，而要进行微信支付就需要用户的唯一标识:openid。还记得第一次获取用户openid的时候就踩了很多坑。这两天又接触了一下，想着索性就把他记录下来，也便于以后查阅</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、准备工具"><a href="#一、准备工具" class="headerlink" title="一、准备工具"></a>一、准备工具</h2><p>不管开发什么，官方的文档应该是第一个想到的这里把官方文档贴出来：<strong><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信网页授权文档</a></strong><br>除此之外，我们还需要一个<strong>内网穿透</strong>的工具在开发环境下让微信能访问到我们的域名。我使用的是natapp。此类工具网上有很多，大家可以自行寻找。<br>这里我们使用微信提供的<strong><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">测试账号</a></strong>来作为演示</p>
<h2 id="二、开始开发"><a href="#二、开始开发" class="headerlink" title="二、开始开发"></a>二、开始开发</h2><p>内网穿透就不在这里演示了，下面我们直入主题：<br><strong>1.填写网页授权域名</strong><br>在这篇文档的一开始就埋了一个坑<br><img src="http://upload-images.jianshu.io/upload_images/3962292-ec7e467e67c31d02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechatOAuth_1"><br>这段话就是说，我们在开发前需要在图片中框红的位置填入我们所要开发的域名。这里我们使用的是测试环境，所以需要在测试账号管理页面的这个位置填入我们自己的域名,这里要注意填入域名的规则。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-866a7344390d10af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechatOAuth_2"><br><strong>2.文档阅读</strong><br>接着阅读文档我们可以发现网页授权有两种scope,<br>snsapi_base和snsapi_userinfo。两种scope都可以获取到opeid，不同的是snsapi_userinfo除了openid外还可以获取到用户的基本信息，但是需要用户手动进行确认。<br>再往下阅读我们可以看到官方文档的授权步骤</p>
<ul>
<li>第一步：用户同意授权，获取code</li>
<li>第二步：通过code换取网页授权access_token以及openid</li>
<li>第三步：刷新access_token（如果需要）</li>
<li>第四步：拉取用户信息(需scope为 snsapi_userinfo)</li>
</ul>
<p>我们只需要openid，所以我们只开发到第二步就好了。下面我们就按着官方步骤来开发。</p>
<p><strong>3.获取code</strong><br>查看文档后我们发现我们需要拼接一个url并且访问它。url的参数文档中写的很清楚了。看他的例子也能看个清楚。这里比较重要的是redirect_uri。这个参数所填的是一个链接。我们访问url后会自动转发到这个链接并且将我们需要的code以及拼接url中的state的值作为参数。这个redirect_uri的值要填入的是我们代码中的controller的位置。<br>所以这里我们需要一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: wechat OAuth2.0</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * Created at:  2018/2/1</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/weixin"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code,@<span class="title">RequestParam</span><span class="params">(<span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"auth开始了。。。。"</span>);</span><br><span class="line">        log.info(<span class="string">"code=&#123;&#125;"</span>,code);</span><br><span class="line">        log.info(<span class="string">"state=&#123;&#125;"</span>,state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我拼接的url，这里大家要注意根据自己的情况进行拼接。拼接成功后需要在<strong>微信app</strong>中进行访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxx&amp;redirect_uri=http://xxx/sell/weixin/auth&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect</span><br></pre></td></tr></table></figure></p>
<p>访问后的结果<br><img src="http://upload-images.jianshu.io/upload_images/3962292-b8aebf3d24fd9380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechatOAuth_3"><br>这样我们就拿到了code<br><strong>4.获取openid</strong><br>继续查看文档，发现我们只需要使用获取到的code再访问另一个url就可以获取到我们想要的了。接着上面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: wechat OAuth2.0</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * Created at:  2018/2/1</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/weixin"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code,@<span class="title">RequestParam</span><span class="params">(<span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"auth开始了。。。。"</span>);</span><br><span class="line">        log.info(<span class="string">"code=&#123;&#125;"</span>,code);</span><br><span class="line">        log.info(<span class="string">"state=&#123;&#125;"</span>,state);</span><br><span class="line">        String url = <span class="string">"https://api.weixin.qq.com/sns/oauth2/access_token?appid=xxxx&amp;secret=xxxx&amp;code="</span>+code+<span class="string">"&amp;grant_type=authorization_code"</span>;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String result = restTemplate.getForObject(url, String.class);</span><br><span class="line">        log.info(<span class="string">"result=&#123;&#125;"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时我们再次访问第三步拼接的url就可以看到如下结果。<br><img src="http://upload-images.jianshu.io/upload_images/3962292-91746bd1b234c646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechatOAuth_4"><br>将结果格式化一下我们可以就看到我们想要的openid<br><img src="http://upload-images.jianshu.io/upload_images/3962292-bbff619cd1b27320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechatOAuth_5"></p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>流程看起来还是很简单的。但以上只是一个最简单、最直接的手工获取openid的例子。真正在使用过程中需要结合自身的业务流程来进行开发，这时可能就有些麻烦了。此时我们也可以借助一些网上第三方sdk来开发。例如:weixin-java-tools。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/wechatOAuth/">http://catalinali.top/2018/wechatOAuth/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3962292-6eb93042fa5fda95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;wechatOAuth_logo&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不知觉间已经接触了几次微信支付开发，而要进行微信支付就需要用户的唯一标识:openid。还记得第一次获取用户openid的时候就踩了很多坑。这两天又接触了一下，想着索性就把他记录下来，也便于以后查阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="wechat" scheme="http://catalinali.top/categories/wechat/"/>
    
    
      <category term="wechat" scheme="http://catalinali.top/tags/wechat/"/>
    
  </entry>
  
</feed>
