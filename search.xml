<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[小白学SpringCloud(六)：服务降级（Hystrix）]]></title>
      <url>/2018/startHystrix/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hystrix_logo.jpg" alt="hystrix_logo"></p>
<blockquote>
<p>在微服务架构中，我们将系统拆分为很多个服务，各个服务之间通过注册与订阅的方式相互依赖，由于各个服务都是在各自的进程中运行，就有可能由于网络原因或者服务自身的问题导致调用故障或延迟，随着服务的积压，可能会导致服务崩溃。为了解决这一系列的问题，断路器等一系列服务保护机制出现了。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Hystrix简介"><a href="#一、Hystrix简介" class="headerlink" title="一、Hystrix简介"></a>一、Hystrix简介</h2><p>Netflix提供了一个叫Hystrix的类库，它实现了断路器模式。在微服务架构中，通常一个微服务会调用多个其他的微服务。一个相对低层级的服务失败可能造成上层应用的级联失败，服务访问量越大失败率越高。当断路打开的时候，这个调用就被终止了。打开的断路可以阻止级联失败。<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_1.png" alt="Hystrix_1"><br>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_2.png" alt="Hystrix_2"></p>
<h2 id="二、Hystrix使用"><a href="#二、Hystrix使用" class="headerlink" title="二、Hystrix使用"></a>二、Hystrix使用</h2><p>这里我们使用之前的Client项目进行演示。<br><strong>1.在服务调用方添加pom</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.添加@EnableCircuitBreaker注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="comment">//@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时我们发现我们的启动类上添加了很多的注解，所以Spring Cloud将这些注解封装了一下，提供了一个@SpringCloudApplication的注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public @interface SpringCloudApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.对要服务进行降级</strong><br>之前的例子里我们有一个<em>restHello</em>的接口,这个接口调用的Discovery的<em>hello</em>接口。<br>我们现在在他上面添加一个@HystrixCommand注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod  = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/restHello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用fallbackMethod属性指定一个fallback方法，在需要降级的时候调用这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">helloFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"哎呀，服务器开小差了！请稍后再试。"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们将服务端和客户端都启动进行访问<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_3.png" alt="Hystrix_3"><br>这时候我们将服务端Discover关掉然后再访问这个地址，他就会去访问降级的地址<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_4.png" alt="Hystrix_4"><br>这样我们就实现了服务降级。但是这样需要没一个接口都添加这个注解，有没有更快一点的方法呢？</p>
<p><strong>4.配置默认服务降级注解</strong><br>在类上添加@DefaultProperties注解配置默认的降级方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientController</span> </span>&#123;</span><br><span class="line">        <span class="comment">//@HystrixCommand(fallbackMethod  = "helloFallback")</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/restHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helloFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"哎呀，服务器开小差了！请稍后再试。"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们再进行刚才的操作，可以发现是同样的效果^_^<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_4.png" alt="Hystrix_4"></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startHystrix/">http://catalinali.top/2018/startHystrix/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(五)：路由网关（Zuul）]]></title>
      <url>/2018/startZuul/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_logo.png" alt="zuul_logo"></p>
<blockquote>
<p>在微服务的架构下，各个服务一般会有各自的网络地址，在这样的情况下外部客户端的调用可能会形成杂乱无章的局面。这时候我们就可以使用微服务网关Zuul这个组件，我们让所有的客户端请求全部请求Zuul，再由Zuul统一的去请求各个服务。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Zuul简介"><a href="#一、Zuul简介" class="headerlink" title="一、Zuul简介"></a>一、Zuul简介</h2><p>Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：</p>
<ul>
<li>身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</li>
<li>审查与监控：</li>
<li>动态路由：动态将请求路由到不同后端集群</li>
<li>压力测试：逐渐增加指向集群的流量，以了解性能</li>
<li>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li>静态响应处理：边缘位置进行响应，避免转发到内部集群</li>
<li>多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化</li>
</ul>
<p>Spring Cloud对Zuul进行了整合和增强。目前，Zuul使用的默认是Apache的HTTP Client，也可以使用Rest Client，可以设置ribbon.restclient.enabled=true.。</p>
<h2 id="二、创建一个api-gateway工程"><a href="#二、创建一个api-gateway工程" class="headerlink" title="二、创建一个api-gateway工程"></a>二、创建一个api-gateway工程</h2><p>这里我们使用IntelliJ IDEA进行展示。<br><strong>1.首先创建一个Zuul项目</strong><br>使用IDEA创建一个项目<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_2.jpg" alt="eureka_2"><br>中间有一步我们选择Zuul选项和SpringBoot版本，如图<br><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_1.png" alt="eureka_2"><br>然后下一步就可以创建好了<br><strong>2.添加@EnableZuulProxy注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGetwayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGetwayApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在配置文件中添加config的配置，具体可以见<a href="http://catalinali.top/2018/startconfig/">小白学SpringCloud(三)：统一配置中心(config)</a>。然后就可以使用Zuul工程的路由了，依次运行Eureka、Config、Client客户端、Zuul。<br>我们先来随便访问一下client端的env接口<br><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_2.png" alt="zuul_2"><br>然后我们通过<em>zuul服务的端口+项目名/接口名</em>这种方式来访问一下这个接口<br><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_3.png" alt="zuul_3"><br>可以看到,同样访问到了结果。<br>另外，我们也可以在配置文件中更加细粒度控制路由路径：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示只要HTTP请求是 /client1开始的，就会转发到服务id为client1的服务上面</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    client1:</span></span><br><span class="line"><span class="attr">      path:</span><span class="string">/client1/**</span>  <span class="string">//</span> <span class="string">路由路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">client1</span> <span class="string">//</span> <span class="string">服务id</span></span><br><span class="line"><span class="attr">    client2:</span></span><br><span class="line"><span class="attr">      path:</span><span class="string">/client2/**</span>  <span class="string">//</span> <span class="string">路由路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">client2</span> <span class="string">//</span> <span class="string">服务id</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，使用Zuul默认不会将Cookie的信息带入服务端，所以我们需要在配置文件中进行配置,将敏感头设置为空即可：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  sensitiveHeaders:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二、服务过滤"><a href="#二、服务过滤" class="headerlink" title="二、服务过滤"></a>二、服务过滤</h2><p>zuul不仅只是路由，并且还能过滤，做一些安全验证。我们来新建一个Filter并且继承ZuulFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_DECORATION_FILTER_ORDER;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: lllx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created on 17:54 2018/7/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modefied</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*返回一个字符串代表过滤器的类型</span></span><br><span class="line"><span class="comment">    pre：路由之前</span></span><br><span class="line"><span class="comment">    routing：路由之时</span></span><br><span class="line"><span class="comment">    post： 路由之后</span></span><br><span class="line"><span class="comment">    error：发送错误调用</span></span><br><span class="line"><span class="comment">    我们可以通过导入FilterConstants这个常量类中的属性来返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤的顺序，Zuul中也自定义了很多过滤器，调用的顺序即通过这个方法返回的大小，越小越靠前。我们可以通过FilterConstants这个常量类中定义好的过滤器-1来返回</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_DECORATION_FILTER_ORDER -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = requestContext.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从url参数获取如果没有token这个参数就不允许请求</span></span><br><span class="line">        String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            requestContext.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过这样的方式去自定义一个个的过滤器。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startZuul/">http://catalinali.top/2018/startZuul/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(四)：消息总线（Spring Cloud Bus）]]></title>
      <url>/2018/startbus/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/bus_logo.jpg" alt="bus_logo"></p>
<blockquote>
<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。上篇我们有说到Spring Cloud为我们提供了在不重启项目的情况下切换配置的功能，就要用到它，让我们来看看怎么实现的吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、安装MQ"><a href="#一、安装MQ" class="headerlink" title="一、安装MQ"></a>一、安装MQ</h2><p>Spring Cloud Bus支持常见的Rabbitmq、kafka、Activemq等。我们这里使用Rabbitmq来作为演示。Rabbitmq的安装这里就不作演示了，大家可以使用docker来安装使用，很方便。给大家一个度娘的<a href="https://www.baidu.com/s?wd=docker%E5%AE%89%E8%A3%85activemq&amp;rsv_spt=1&amp;rsv_iqid=0xf5578fe4000354b9&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;oq=docker%2520%25E5%25AE%2589%25E8%25A3%2585activemq&amp;inputT=1021&amp;rsv_t=11e21%2FaLzaFQGzuvMvLtKuHmxzuLUWS0TB6d8t9pETvwOEs%2B0fjRN9KsfhoNwJv1cAky&amp;rsv_pq=ef4e2567000322af&amp;sug=activemq&amp;rsv_sug3=21&amp;rsv_sug1=17&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=1751" target="_blank" rel="noopener">传送门</a>。</p>
<h2 id="二、Config-Server配置"><a href="#二、Config-Server配置" class="headerlink" title="二、Config Server配置"></a>二、Config Server配置</h2><p>这里我们还是以廖师兄的图为例，先来看看自动更新配置的原理(图中product、order均为客户端)。<br><img src="http://ou3np1yz4.bkt.clouddn.com/bus_1.png" alt="bus_1"><br>当我们在远端Git修改了配置之后，如果我们访问Config Server的<code>/bus-refresh</code>接口，Config Server就会把更改的配置发送给MQ，之后MQ就会把要改变的配置推送给各个客户端，这样就实现了自动更换配置的功能，现在我们来试一试吧。记住在这之前要先启动Rabbitmq。<br><strong>1.</strong>添加pom引用<br>老规矩，先来添加pom引用，要注意的是Config的Server和Client端都要添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong>修改配置文件<br>首先我们要先添加rabbitmq的配置，我们可以直接配置在远程git上面，这样服务端和客户端就都有这份配置了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="string">.xxx.xxx</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们也要显示的使我们的服务暴漏<code>/bus-refresh</code>接口。在Spring2.0中把这个接口都移动到了<em>actuator</em>下面。这个只需要在Config端进行配置就好了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">bus-refresh</span> <span class="comment">#也可以改为"*"来暴露所有接口</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们逐一启动我们的Eureka、Config和Client项目，同时在启动Config Server的时候可以看到我们对外暴露的接口<br><img src="http://ou3np1yz4.bkt.clouddn.com/bus_2.png" alt="bus_2"><br>这样我们就完成配置了，现在我们修改一下远端配置中的<code>env</code>的值，然后访问一下这个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8764/actuator/bus-refresh</span><br></pre></td></tr></table></figure></p>
<p>这时候我们发现在不重启项目的情况下，我们的配置已经修改了。<br><strong>3.</strong>配置Webhook<br>刚才我们已经实现了自动替换项目配置，但是我们每次更改配置都要手动访问<code>/bus-refresh</code>接口，有没有简单的方式呢?答案当然是有的。现在大部分远端Git都提供了webhook功能，即我们每更改一次配置，就自动向某一接口发送一次请求。这不就是我们想要的吗？</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startbus/">http://catalinali.top/2018/startbus/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(三)：统一配置中心(config)]]></title>
      <url>/2018/startconfig/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/config_logo.png" alt="config_logo"></p>
<blockquote>
<p>在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成。如果我们每个服务都有一个独立的配置的话，这样很不方便我们维护。Spring Cloud中为我们提供了一个config组件为我们解决了这个问题，并且更改了配置并不需要我们重启。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Config概述"><a href="#一、Config概述" class="headerlink" title="一、Config概述"></a>一、Config概述</h2><p>同Eureka一样，config也分为server端和client端，我们先来看看server端的原理。这里引用一张廖师兄的图（注：图中的order、product都是客户端）<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_1.png" alt="config_1"><br>从这张图我们可以看出，Config Server是以远端Git作为依托（SVN也可以,这里使用Github作为演示），从远端Git仓库中拉取配置并同步到本地Git上。当客户端需要配置的时候就可以从Server端进行配置的拉取。</p>
<h2 id="二、Config-Server配置"><a href="#二、Config-Server配置" class="headerlink" title="二、Config Server配置"></a>二、Config Server配置</h2><p><strong>1.</strong>创建Config工程<br>跟前文一样，我们使用IDEA的Spring Initializr创建我们的Config工程，如图:除了图中圈起来的config Server要勾上，Eureka Discover也要勾上。<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_2.png" alt="config_2"></p>
<p><strong>2.</strong>创建远程仓库<br>首先我们先创建一个远程Git仓库，这里以Github为例，这里我已经创建好了一个公开仓库<a href="https://github.com/catalinaLi/config_repo" target="_blank" rel="noopener">https://github.com/catalinaLi/config_repo</a><br>然后在里面先添加一份配置<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_6.png" alt="config_3"><br><strong>3.</strong>配置Config工程<br>将我们的Config工程注册到Eureka注册中心：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8764</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/catalinaLi/config_repo</span> <span class="comment">#config_Server仓库地址</span></span><br><span class="line">          <span class="comment">#如果我们配置的是私有仓库，则还需要远程仓库的账号和密码</span></span><br><span class="line">          <span class="comment">#username: yourusername  </span></span><br><span class="line">          <span class="comment">#password: yourpassword</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="string">dev</span></span><br></pre></td></tr></table></figure></p>
<p>然后在启动类上添加注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.</strong> Config Server配置<br>这里首先我们要先填一个坑，因为博主在这里使用的Spring Cloud是<em>Finchley.RC2</em>版本的。可是这个版本这里有一个bug，所以我们暂时把pom中Spring Cloud的版本修改为<em>Finchley.RC1</em>,等待官方的修复。<br>接下来就可以通过网络来访问我们的配置了，首先启动注册中心Eureka，然后启动我们的Config。这时候我们通过浏览器访问<a href="http://localhost:8764/client-dev.yml" target="_blank" rel="noopener">http://localhost:8764/client-dev.yml</a>就可以看到我们的配置了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_5.png" alt="config_5"><br>这里是Spring Cloud对配置请求的路径做了映射,通常为：</p>
<ul>
<li>/{name}-{profiles}.yml</li>
<li>/{label}/{name}-{profiles}.yml</li>
</ul>
<p>这两种方式大家可以挑选一个适合你的。<br>后缀名也可以不是yml，你可以试试properties，json。Spring Cloud会自动帮你转换。</p>
<h2 id="三、Config-Client配置"><a href="#三、Config-Client配置" class="headerlink" title="三、Config Client配置"></a>三、Config Client配置</h2><p>这里我们使用上一篇文章<a href="http://catalinali.top/2018/startfeignRest/">小白SpringCloud(二)：服务间的调用</a>中的Client项目来进行改造<br><strong>1.添加pom引用</strong><br>在FeignClient的pom文件中添加Config Client引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.修改配置文件</strong><br>首先我们要把配置文件的名字改为<strong>bootstrap.yml</strong>，改成这个名字Spring Cloud就会先去Config Server拉取配置。<br>然后我们要在bootstrap.yml中定义我们要拉取的文件名称，还记得刚才说的Spring Cloud对请求的路径做的映射方式吗(/{name}-{profiles}.yml)？在这里我们配置<em>name</em>、<em>profiles</em>和<em>Config项目的名称</em></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#name</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">config</span> <span class="comment">#Eureka Config's name</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span> <span class="comment">#profiles</span></span><br></pre></td></tr></table></figure>
<p>这时候，我们的Client就可以正常启动啦，怎么样简单吧。</p>
<h2 id="二、Config-Server的高可用"><a href="#二、Config-Server的高可用" class="headerlink" title="二、Config Server的高可用"></a>二、Config Server的高可用</h2><p>统一配置中心的高可用很简单，只需要我们多启动几个相同的实例就好了。Config Client在启动的时候会根据负载均衡去访问Config Server中的某一台.</p>
<p>还记得导语中说的更改配置可以不用重新启动项目吗？这里需要用到另外一个组件，我们在下篇文章进行讲解。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startconfig/">http://catalinali.top/2018/startconfig/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(二)：服务间的调用]]></title>
      <url>/2018/startfeignRest/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_logo.png" alt="feign&amp;Rest_logo"></p>
<blockquote>
<p>SpringCloud服务间的调用有两种方式：RestTemplate和FeignClient。不管是什么方式，他都是通过REST接口调用服务的http接口，参数和结果默认都是通过jackson序列化和反序列化。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Ribbon简介"><a href="#一、Ribbon简介" class="headerlink" title="一、Ribbon简介"></a>一、Ribbon简介</h2><p>在说这两种方式之前，我们先来简单的看一下Ribbon。</p>
<blockquote>
<p>Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.</p>
</blockquote>
<p>这是官网对Ribbon的简介，简单的说Ribbon是一个负载均衡客户端，SpringCloud的两种服务间调用方式背后都用了Ribbon。</p>
<h2 id="二、使用RestTemplate进行服务调用"><a href="#二、使用RestTemplate进行服务调用" class="headerlink" title="二、使用RestTemplate进行服务调用"></a>二、使用RestTemplate进行服务调用</h2><p>代码Demo接上篇<a href="http://catalinali.top/2018/startEureka/">SpringCloud(一)：服务的注册与发现（Eureka）</a><br><strong>1.</strong>我们首先启动端口为8761的eureka工程，把SpringCloud的服务注册中心启动。</p>
<p><strong>2.</strong>打开我们的Discovery工程。这时候Discovery工程相当于服务端，我们来为它写一个提供服务的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello! 我是"</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后将配置文件中的端口改为8762和8763分别启动。<br>如果你使用的是IDEA的话，只需要去掉下图中红框框住的部分就可以将同一工程启动多个实例<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_1.png" alt="Rest_1"><br>这时，我们就拥有了端口为8762和8763的两个Discovery集群，Eureka中可以看到<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_2.png" alt="feign&amp;Rest_2"><br><strong>3.</strong>我们再新建一个Eureka-Discovery工程（可以参照上一篇文章），首先为他配置好Eureka-Client的配置。在配置文件中为它指定端口为8764：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8764</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#客户端名称</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们为它添加一个RestTemplate的配置Bean，可以参照如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后我们就可以在需要调用的地方用如下方式进行调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cliHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数为：服务端的应用名称/调用接口的Mapping</span></span><br><span class="line">        <span class="comment">//第二个参数为返回的类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如图：<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_3.png" alt="feign&amp;Rest_3"><br>这里因为Ribbon的默认负载均衡方式为轮询，所以我们可以看到端口8762和8763依次出现。如果有想改变负载均衡方式的小伙伴可以下去自行研究一下，这里就不过多赘述了。</p>
<h2 id="三、使用Feign进行服务调用"><a href="#三、使用Feign进行服务调用" class="headerlink" title="三、使用Feign进行服务调用"></a>三、使用Feign进行服务调用</h2><p><strong>1.添加Feign的pom引用</strong><br>在FeignClient的pom文件中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是版本一定要跟我的一致，否则添加的依赖有可能会不一样<br><strong>2.为启动类添加注解</strong><br>这一步很简单，只需要在在启动类上添加<code>@EnableFeignClients</code>注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class ClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.定义一个Feign接口</strong><br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name是服务端的名称</span></span><br><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"discovery"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url是调用服务的url值</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.调用</strong><br>在配置了Feign接口后，我们就可以直接进行注入调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/feignHello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">feignHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloClient.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的结果跟RestTemplate也相同<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_3.png" alt="feign&amp;Rest_3_1"><br>从这里我们可以看到，使用Feign是伪分布式的调用方式。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startfeign&amp;Rest/">http://catalinali.top/2018/startfeign&amp;Rest/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(一)：服务的注册与发现（Eureka）]]></title>
      <url>/2018/startEureka/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_logo1.jpg" alt="eureka_logo"></p>
<a id="more"></a>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>首先我们先引用Dubbo官网的一段话</p>
<ul>
<li>单一应用架构<br>  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>  此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</li>
<li>垂直应用架构<br>  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>  此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</li>
<li>分布式服务架构<br>  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中 心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</li>
<li>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA) 是关键。</li>
</ul>
<p>结合现在大火的微服务，SpringCloud成了炙手可热的微服务架构方案，这里我们介绍一个他的核心组件：Eureka ,eureka是一个服务注册和发现模块。类似于Dubbo的管控台。它分为两个模块:客户端和服务端</p>
<h2 id="二、创建一个Eureka-Server"><a href="#二、创建一个Eureka-Server" class="headerlink" title="二、创建一个Eureka Server"></a>二、创建一个Eureka Server</h2><p>这里我们使用IntelliJ IDEA进行展示。<br><strong>1.首先创建一个Eureka Server</strong><br>使用IDEA创建一个项目<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_2.jpg" alt="eureka_2"><br>中间有一步我们选择Eureka Server选项和SpringBoot版本，如图<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_3.jpg" alt="eureka_2"><br>然后下一步就可以创建好了<br><strong>2.添加@EnableEurekaServer注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们就可以启动了，运行EurekaApplication，然后就输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>就可以看到我们Eureka的页面了。但这时候我们观察console可以发现一直在报错，这是因为默认情况下Eureka Server也是一个Client,我们需要通过配置来解决这个问题<br><strong>3.添加配置</strong><br>eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个server。eureka server的配置文件appication.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka</span> <span class="comment">#应用的名称</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">    <span class="comment"># 通过添加配置我们这里忽略自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#表示是否注册自身到eureka服务器</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment">#表示是否从eureka服务器获取注册信息</span></span><br></pre></td></tr></table></figure></p>
<p>这时候再启动应用，就大功告成了<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_4.jpg" alt="eureka_4"></p>
<h2 id="三、创建一个Eureka-Client"><a href="#三、创建一个Eureka-Client" class="headerlink" title="三、创建一个Eureka Client"></a>三、创建一个Eureka Client</h2><p><strong>1.运行Eureka Server</strong><br>这里我们可以使用命令行在Eureka Server的目录位置使用<code>mvn clean package</code>来进行打包<br>然后使用<code>java -jar target/eureka-0.0.1-SNAPSHOT.jar</code>命令来进行启动jar包<br>也可以使用<code>nohup java -jar target/eureka-0.0.1-SNAPSHOT.jar &amp;</code>来后台启动这个jar。<br>最后刷新Eureka Server来判断是否启动成功<br><strong>2.创建一个Eureka Client</strong><br>这一步跟创建Server端的步骤是一样的，不同的是模板选择Discovery<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_5.jpg" alt="eureka_5"><br><strong>3.添加@EnableEurekaServer注解和服务端地址</strong><br>基本和服务端的做法一样，首先我们在DicoveryApplication.java的代码上添加@EnableDiscoveryClient注解。然后在application.yml上添加配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DicoveryApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DicoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#客户端名称</span></span><br></pre></td></tr></table></figure>
<p>注意了，这个版本我们需要在pom文件中添加<code>spring-boot-starter-web</code>的依赖，<br>这时候我们就可以启动我们的服务了，然后就可以在eureka的页面上看到我们刚才的Client了<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_6.jpg" alt="eureka_6"></p>
<h2 id="三、Eureka-Server的高可用"><a href="#三、Eureka-Server的高可用" class="headerlink" title="三、Eureka Server的高可用"></a>三、Eureka Server的高可用</h2><p>简单的说，实现Eureka Server的高可用就是让Eureka Server的实例互相注册。<br>让我们来看一下如何实现：<br>首先我们配置文件中这样写<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">discovery-cluster</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">discovery1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">discovery1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      default-zone:</span> <span class="attr">http://discovery2:8762/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">discovery2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">discovery2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      default-zone:</span> <span class="attr">http://discovery1:8761/eureka</span></span><br></pre></td></tr></table></figure></p>
<p>配置文件是通过两个Eureka Server互相注册，这里有三段配置，第一段配置为公共配置，配置了应用名称，第二段为名discovery1的配置，第三段为discovery2的配置。在项目启动可以通过–spring.profiles.active={配置名称} 来启动不同的配置。<br>下面我们来进行测试：<br>1）在discovery-cluster目录下，使用<code>mvn clean package</code>打包项目<br>2）使用下面命令启动两个Eureka Server节点<br><code>java -jar discovery-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=discovery1</code></p>
<p><code>java -jar discovery-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=discovery2</code><br>3）在浏览器上分别输入<a href="http://localhost:8761和http://localhost:8762查看注册的服务。" target="_blank" rel="noopener">http://localhost:8761和http://localhost:8762查看注册的服务。</a><br>这时候我们可以发现两个网址都可以访问Eueka页面<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_7.jpg" alt="eureka_7"><br>这样我们就大功告成了，如我们我们的实例有3个，那就在配置文件中都写入<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">   client:</span></span><br><span class="line"><span class="attr">      service-url:</span></span><br><span class="line"><span class="attr">          default-zone:</span><span class="attr">http://discovery1:8761/eureka,http://discovery2:8762/eureka</span></span><br></pre></td></tr></table></figure></p>
<p>以上，就是Eureka的基本用法了！</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startfeign&amp;Rest/">http://catalinali.top/2018/startfeign&amp;Rest/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在同一台电脑上使用github和gitlab]]></title>
      <url>/2018/noteGithubGitlab/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/gitlabgithub_logo.jpg" alt="gitlabgithub_logo"></p>
<blockquote>
<p>换了工作后使用的是gitlab，这样对github的使用会有影响。为了解决这个问题，搜了很多资料后完美解决。现在把它记录下来。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在同一台电脑上使用github和gitlab，主要的思想就是使用不同的仓库时，切换成不同的账号。不同账号的sshKey分别对应github和gitlab。接下来跟着我看看怎么做吧^_^</p>
<h2 id="一、生成ssh密钥"><a href="#一、生成ssh密钥" class="headerlink" title="一、生成ssh密钥"></a>一、生成ssh密钥</h2><p>这里我们要做的事情就是分别对githubn和gitlab生成对应的密钥（默认情况下本地生成的秘钥位于/Users/用户名/.ssh/），并且配置git访问不同host时访问不同的密钥，流程如下：<br><strong>1、</strong> 在gitbash中使用<code>ssh-keygen -t rsa -C &quot;公司邮箱地址&quot;</code>生成对应的gitlab密钥：<em>id_rsa</em>和<em>id_rsa.pub</em><br><strong>2、</strong> 将gitlab公钥即<em>id_rsa.pub</em>中的内容配置到公司的gitlab上<br><strong>3、</strong> 在gitbash中使用<code>ssh-keygen -t rsa -C &quot;github地址&quot; -f ~/.ssh/github_rsa</code>生成对应的github密钥：<em>github_rsa</em>和<em>github_rsa.pub</em><br><strong>4、</strong> 将github公钥即<em>github_rsa.pub</em>中的内容配置到自己的github上<br><strong>5、</strong> 进入密钥生成的位置，创建一个<code>config</code>文件，添加配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line"><span class="string">Host</span> <span class="string">gitlab</span></span><br><span class="line">	<span class="string">HostName</span> <span class="string">git.xxx.com</span> <span class="comment">#这里填你的gitlab的Host</span></span><br><span class="line">	<span class="string">User</span> <span class="string">git</span></span><br><span class="line">	<span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="comment"># githab</span></span><br><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">	<span class="string">HostName</span> <span class="string">github.com</span></span><br><span class="line">	<span class="string">User</span> <span class="string">git</span></span><br><span class="line">	<span class="string">IdentityFile</span> <span class="string">~/.ssh/github_rsa</span></span><br></pre></td></tr></table></figure>
<h2 id="二、测试连接"><a href="#二、测试连接" class="headerlink" title="二、测试连接"></a>二、测试连接</h2><p>在密钥的生成位置/Users/用户名/.ssh/下使用gitbash运行<code>ssh -T git@hostName</code>命令测试sshkey对gitlab与github的连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catalinaLi@catalinaLi MINGW64 ~/.ssh</span><br><span class="line">$ ssh -T git@gitlab</span><br><span class="line">Welcome to GitLab, catalinaLi!</span><br><span class="line"></span><br><span class="line">catalinaLi@catalinaLi MINGW64 ~/.ssh</span><br><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi catalinaLi! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>如果出现上图结果就说明连接成功，如果不是这样的话就仔细看看第一步哪里做错了。</p>
<h2 id="三、配置git仓库"><a href="#三、配置git仓库" class="headerlink" title="三、配置git仓库"></a>三、配置git仓库</h2><p>这里我们要用到git的config配置。git的config文件记录了用户的基本信息，我们的账号信息也在里面，这里我们要做的就行在不同的本地仓库配置不同的用户信息来访问不同的远程仓库。config文件通常有三个位置：</p>
<ul>
<li>system （系统级别）：<br>  位于Windows下在git的安装目录， 包含了适用于系统所有用户和所有库的值。如果你传递参数选项’–system’ 给 git config，它将明确的读和写这个文件。 </li>
<li>global（用户级别）:<br>  位于~/.gitconfig，具体到你的用户。你可以通过传递–global 选项使Git 读或写这个特定的文件。</li>
<li>local（仓库级别）：<br>  位于 .git/config，无论你当前在用的库是什么，特定指向该单一的库。每个级别重写前一个级别的值。</li>
</ul>
<p>简单了解后我们就可以来配置了</p>
<p><strong>1.</strong> 用户级别配置<br>因为公司的代码使用频率较高，所以我们将git配置文件的global（用户级别）设置为公司的gitlab账号,在gitlab中使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &apos;catalinaLi&apos; #公司账号名称</span><br><span class="line">$ git config --global user.email &apos;catalinaLi@companyName.com&apos; #公司账号邮箱</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 仓库级别配置<br>我们将local（仓库级别）配置成github的账号。此时我们需要先<strong>init</strong>一个git的仓库并进入里面后执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --local user.name &apos;username&apos; #github账号名称</span><br><span class="line">$ git config --local user.email &apos;username@gmail.com&apos; #github账号邮箱</span><br></pre></td></tr></table></figure>
<p>之后我们github的代码都应该在这个仓库下拉取。</p>
<p><strong>3.</strong> 克隆代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:catalinaLi/ideaTaotao.git</span><br></pre></td></tr></table></figure>
<p>在使用github克隆代码时，因为配置了config, 所以会通过配置的host自动查找到git@github.com。对于gitlab也是相同的道理</p>
<p>至此，在同一台电脑上使用gitlab与github已经成功了，尽情感受吧。另外，大家可以寻找<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=git%20config&amp;oq=git%25E5%259B%25BE%25E7%2589%2587&amp;rsv_pq=8af24b1f00001879&amp;rsv_t=f935uktxm1WFti3L2TeFRHq8XdFpo%2B3%2FcGp%2F14sVbaYetcqU4uCbhZ5DCCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;inputT=1397&amp;rsv_sug3=14&amp;rsv_sug1=18&amp;rsv_sug7=100&amp;bs=git%E5%9B%BE%E7%89%87" target="_blank" rel="noopener">度娘</a>来学习关于git的config的更多使用</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.arccode.net/config-multi-git-account-and-workspaces.html" target="_blank" rel="noopener">http://www.arccode.net/config-multi-git-account-and-workspaces.html</a><br><a href="https://segmentfault.com/a/1190000002994742" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002994742</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/noteGithubGitlab/">http://catalinali.top/2018/noteGithubGitlab/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[笔记：使用hexo，如果换了电脑怎么更新博客]]></title>
      <url>/2018/noteHexoBak/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/note_hexo_install_logo.jpg" alt="note_hexo_install_logo"></p>
<blockquote>
<p>最近换了工作，忙着熟悉业务，好久没写博客了。换了新环境，好多东西都要重装。Hexo博客就是其中之一，这里我从万能的知乎上找了一个感觉很赞的方法，现在把文章搬运过来。话不多说，我们快来看看他是怎么做吧。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。但是考虑到如果每个GitHub Pages都需要额外的一个仓库存放这些文件，就显得特别冗余了。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。</p>
<h2 id="二、搭建的流程"><a href="#二、搭建的流程" class="headerlink" title="二、搭建的流程"></a>二、搭建的流程</h2><p><strong>1.</strong> 创建仓库，<a href="http://catalinaLi.github.io；" target="_blank" rel="noopener">http://catalinaLi.github.io；</a><br><strong>2.</strong> 创建两个分支：master 与 hexo；<br><strong>3.</strong> 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br><strong>4.</strong> 使用git clone git@github.com:catalinaLi/catalinaLi.github.io.git拷贝仓库；<br><strong>5.</strong> 在本地<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br><strong>6.</strong> 修改_config.yml中的deploy参数，分支应为master；<br><strong>7.</strong> 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；<br><strong>8.</strong> 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！</p>
<h2 id="三、日常的改动流程"><a href="#三、日常的改动流程" class="headerlink" title="三、日常的改动流程"></a>三、日常的改动流程</h2><p>在本地对博客进行修改、添加新博文、修改样式等等可以参照以下流程：<br><strong>1.</strong> 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；<br><strong>2.</strong> 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>
<h2 id="四、拉取备份"><a href="#四、拉取备份" class="headerlink" title="四、拉取备份"></a>四、拉取备份</h2><p>本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：<br><strong>1.</strong> 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；<br><strong>2.</strong> 在本地新拷贝的<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/noteHexoBak/">http://catalinali.top/2018/noteHexoBak/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> note </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信开发之微信网页授权获取openid]]></title>
      <url>/2018/wechatOAuth/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_logo.jpg" alt="wechatOAuth_logo"></p>
<blockquote>
<p>不知觉间已经接触了几次微信支付开发，而要进行微信支付就需要用户的唯一标识:openid。还记得第一次获取用户openid的时候就踩了很多坑。这两天又接触了一下，想着索性就把他记录下来，也便于以后查阅</p>
</blockquote>
<a id="more"></a>
<h2 id="一、准备工具"><a href="#一、准备工具" class="headerlink" title="一、准备工具"></a>一、准备工具</h2><p>不管开发什么，官方的文档应该是第一个想到的这里把官方文档贴出来：<strong><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信网页授权文档</a></strong><br>除此之外，我们还需要一个<strong>内网穿透</strong>的工具在开发环境下让微信能访问到我们的域名。我使用的是natapp。此类工具网上有很多，大家可以自行寻找。<br>这里我们使用微信提供的<strong><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">测试账号</a></strong>来作为演示</p>
<h2 id="二、开始开发"><a href="#二、开始开发" class="headerlink" title="二、开始开发"></a>二、开始开发</h2><p>内网穿透就不在这里演示了，下面我们直入主题：<br><strong>1.填写网页授权域名</strong><br>在这篇文档的一开始就埋了一个坑<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_1.png" alt="wechatOAuth_1"><br>这段话就是说，我们在开发前需要在图片中框红的位置填入我们所要开发的域名。这里我们使用的是测试环境，所以需要在测试账号管理页面的这个位置填入我们自己的域名,这里要注意填入域名的规则。<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_2.png" alt="wechatOAuth_2"><br><strong>2.文档阅读</strong><br>接着阅读文档我们可以发现网页授权有两种scope,<br>snsapi_base和snsapi_userinfo。两种scope都可以获取到opeid，不同的是snsapi_userinfo除了openid外还可以获取到用户的基本信息，但是需要用户手动进行确认。<br>再往下阅读我们可以看到官方文档的授权步骤</p>
<ul>
<li>第一步：用户同意授权，获取code</li>
<li>第二步：通过code换取网页授权access_token以及openid</li>
<li>第三步：刷新access_token（如果需要）</li>
<li>第四步：拉取用户信息(需scope为 snsapi_userinfo)</li>
</ul>
<p>我们只需要openid，所以我们只开发到第二步就好了。下面我们就按着官方步骤来开发。</p>
<p><strong>3.获取code</strong><br>查看文档后我们发现我们需要拼接一个url并且访问它。url的参数文档中写的很清楚了。看他的例子也能看个清楚。这里比较重要的是redirect_uri。这个参数所填的是一个链接。我们访问url后会自动转发到这个链接并且将我们需要的code以及拼接url中的state的值作为参数。这个redirect_uri的值要填入的是我们代码中的controller的位置。<br>所以这里我们需要一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: wechat OAuth2.0</span></span><br><span class="line"><span class="comment"> * Author:		lllx</span></span><br><span class="line"><span class="comment"> * Version:		1.0</span></span><br><span class="line"><span class="comment"> * Created at:	2018/2/1</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/weixin"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code,@<span class="title">RequestParam</span><span class="params">(<span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"auth开始了。。。。"</span>);</span><br><span class="line">        log.info(<span class="string">"code=&#123;&#125;"</span>,code);</span><br><span class="line">        log.info(<span class="string">"state=&#123;&#125;"</span>,state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我拼接的url，这里大家要注意根据自己的情况进行拼接。拼接成功后需要在<strong>微信app</strong>中进行访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxx&amp;redirect_uri=http://xxx/sell/weixin/auth&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect</span><br></pre></td></tr></table></figure></p>
<p>访问后的结果<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_3.png" alt="wechatOAuth_3"><br>这样我们就拿到了code<br><strong>4.获取openid</strong><br>继续查看文档，发现我们只需要使用获取到的code再访问另一个url就可以获取到我们想要的了。接着上面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: wechat OAuth2.0</span></span><br><span class="line"><span class="comment"> * Author:		lllx</span></span><br><span class="line"><span class="comment"> * Version:		1.0</span></span><br><span class="line"><span class="comment"> * Created at:	2018/2/1</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/weixin"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code,@<span class="title">RequestParam</span><span class="params">(<span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"auth开始了。。。。"</span>);</span><br><span class="line">        log.info(<span class="string">"code=&#123;&#125;"</span>,code);</span><br><span class="line">        log.info(<span class="string">"state=&#123;&#125;"</span>,state);</span><br><span class="line">        String url = <span class="string">"https://api.weixin.qq.com/sns/oauth2/access_token?appid=xxxx&amp;secret=xxxx&amp;code="</span>+code+<span class="string">"&amp;grant_type=authorization_code"</span>;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String result = restTemplate.getForObject(url, String.class);</span><br><span class="line">        log.info(<span class="string">"result=&#123;&#125;"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时我们再次访问第三步拼接的url就可以看到如下结果。<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_4.png" alt="wechatOAuth_4"><br>将结果格式化一下我们可以就看到我们想要的openid<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_5.png" alt="wechatOAuth_5"></p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>流程看起来还是很简单的。但以上只是一个最简单、最直接的手工获取openid的例子。真正在使用过程中需要结合自身的业务流程来进行开发，这时可能就有些麻烦了。此时我们也可以借助一些网上第三方sdk来开发。例如:weixin-java-tools。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/wechatOAuth/">http://catalinali.top/2018/wechatOAuth/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> wechat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wechat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用IDEA搭建第一个SpringBoot程序]]></title>
      <url>/2018/startSpringBoot/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_logo.jpg" alt="startSpringBoot_logo"></p>
<blockquote>
<p>近来在研究SpringBoot的使用，现在把使用IDEA搭建一个SpringBoot的HelloWorld程序记录下来</p>
</blockquote>
<a id="more"></a>
<h2 id="新建一个SpringBoot环境"><a href="#新建一个SpringBoot环境" class="headerlink" title="新建一个SpringBoot环境"></a>新建一个SpringBoot环境</h2><p>打开你的IntelliJ IDEA，然后选择Create New Project。如图，我们要选择一个Spring Initializr<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_1.png" alt="startSpringBoot_1"><br>之后我们填入自己的Group与Artifact(项目名字)后选择Next<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_2.png" alt="startSpringBoot_2"><br>由于我们是Web项目，所以我们先勾选最基本的Web选项，其他的待我们用到了再勾选。<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_3.png" alt="startSpringBoot_3"><br>接下来是选择项目存放的位置<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_4.png" alt="startSpringBoot_4"><br>选择Finish之后静静等待IEAD加载索引搭建工程。OK，一个完整的SpringBoot项目的结构我们已经搭建好了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_5.png" alt="startSpringBoot_5"><br>上图我用红框圈住的可以删掉，保持项目的简洁。这样，一个可供使用的SpringBoot环境就搭好了。</p>
<h2 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h2><p>使用SpringBoot可以让你快速搭建一个SpringWeb项目，它使用“习惯优于配置”的理念让你的项目快速运行起来。使用SpringBoot可以很容易创建一个独立运行（运行jar，内嵌Servlet容器）、准生产级别的基于Spring框架的项目。使用SpringBoot你可以不用或者是很少的配置。<br>使用SpringBoot的优点：</p>
<ul>
<li>快速构建项;</li>
<li>对主流开发框架的无配罝集成；</li>
<li>项目可独立运行，无须外部依赖Servlet容器；</li>
<li>提供运行时的应用监控；</li>
<li>极大地提髙了开发、部署效率；</li>
<li>与云计算的天然集成。<h2 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h2>我们来写一个SpringBoot的HelloWorld<br>打开项目自动生成的DemoApplication类，修改代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"hello world！"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后右键选择Run<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_7.png" alt="startSpringBoot_7"><br>然后打开浏览器访问<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a>就可以看到我们写的HelloWorld<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_8.png" alt="startSpringBoot_8"><br><strong>代码说明：</strong><br>1、@SpringBootApplication：Spring Boot项目的核心注解，主要目的是开启自动配置。；<br>2、@Configuration：这是一个配置Spring的配置类；<br>3、@Controller：标明这是一个SpringMVC的Controller控制器；<br>4、main方法：在main方法中启动一个应用，即：这个应用的入口；</p>
<p>这次只是记录了一下搭建SpringBoot的HelloWorld过程。具体的SpringBoot知识还需要大家去深入学习</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/startSpringBoot/">http://catalinali.top/2017/startSpringBoot/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JSONP解决ajax跨域]]></title>
      <url>/2018/useJSONP/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/jsonp_logo.jpg" alt="jsonp_logo"></p>
<blockquote>
<p>在日常开发中，不免遇到跨域的问题。在这里我们介绍使用Jsonp来解决ajax跨域的问题。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域?"></a>什么是跨域?</h2><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。简单的理解就是开发时当客户端所在的工程与服务端的ip不同或者端口不同时进行请求，就产生了跨域，进而不能请求数据。</p>
<h2 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP?"></a>什么是JSONP?</h2><p>官方的说法是:JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。<br>我们都知道，JSON是一种数据交换格式。而JSONP是一种的数据调用方式。它利用&lt;script&gt;标签可以跨域的特性，将需要跨域获取的数据包在&lt;script&gt;标签中来达到目的。当我们需要使用JSONP时，客户端调用服务端时传递一个callback，这样服务端根据callback的有无就可以判断是否需要使用JSONP。可以简单的理解为带callback的json就是jsonp。</p>
<h2 id="JSONP的使用"><a href="#JSONP的使用" class="headerlink" title="JSONP的使用"></a>JSONP的使用</h2><p>AJAX的使用与平常无异，只需要将dataType改为jsonp即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	url : url,</span><br><span class="line">	dataType : <span class="string">"jsonp"</span>,</span><br><span class="line">	type : <span class="string">"GET"</span>,</span><br><span class="line">	success : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">              ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>服务端接收到以后，只需要手动判断一下有无callback再手动拼一对括号即可,这里以java为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"xxx"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testJsonp</span><span class="params">(String callback)</span> </span>&#123;</span><br><span class="line">	Student result = <span class="keyword">new</span> Student();</span><br><span class="line">	<span class="comment">//响应结果之前，判断是否为jsonp请求</span></span><br><span class="line">	<span class="keyword">if</span> (StringUtils.isNotBlank(callback)) &#123;</span><br><span class="line">		<span class="comment">//把结果封装成一个js语句响应</span></span><br><span class="line">		<span class="keyword">return</span> callback + <span class="string">"("</span> + JsonUtils.objectToJson(result)  + <span class="string">");"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> JsonUtils.objectToJson(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Spring 4.1以上的版本也可以使用MappingJacksonValue来响应<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"xxx"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">testJsonp</span><span class="params">(String callback)</span> </span>&#123;</span><br><span class="line">    Student result = <span class="keyword">new</span> Student();</span><br><span class="line">	<span class="comment">//响应结果之前，判断是否为jsonp请求</span></span><br><span class="line">	<span class="keyword">if</span> (StringUtils.isNotBlank(callback)) &#123;</span><br><span class="line">		<span class="comment">//把结果封装成一个js语句响应</span></span><br><span class="line">		MappingJacksonValue mappingJacksonValue = <span class="keyword">new</span> MappingJacksonValue(result);</span><br><span class="line">		mappingJacksonValue.setJsonpFunction(callback);</span><br><span class="line">		<span class="keyword">return</span> mappingJacksonValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么样，简单几步就可以跨域来访问服务端了。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/useJSONP/">http://catalinali.top/2018/useJSONP/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> jsonp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jsonp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ActiveMQ从入门到实践]]></title>
      <url>/2017/useMQ/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/mq_logo.jpg" alt="mq_logo"><br><a id="more"></a></p>
<h2 id="一、什么是ActiveMQ"><a href="#一、什么是ActiveMQ" class="headerlink" title="一、什么是ActiveMQ"></a>一、什么是ActiveMQ</h2><p>首先我们应该先了解J2EE中的一个重要规范：JMS(The Java Message Service)Java消息服务。而JMS的客户端之间可以通过JMS服务进行异步的消息传输。它主要有两种模型：点对点和发布订阅模型。</p>
<p><strong>点对点的模型特点：</strong>：</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)。</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列。</li>
<li>接收者在成功接收消息之后需向队列应答成功。</li>
</ul>
<p><strong>发布订阅模型特点：</strong></p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li>
<li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li>
</ul>
<p>JMS还定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java原始值的数据流</li>
<li>MapMessage–一套名称-值对</li>
<li>TextMessage–一个字符串对象</li>
<li>ObjectMessage–一个序列化的 Java对象</li>
<li>BytesMessage–一个字节的数据流</li>
</ul>
<p>其中我们用的最多的就是TextMessage字符串对象</p>
<p>消息中间件作为JMS的实现，在J2EE的企业应用中扮演着特殊的角色。ActiveMQ是一个易于使用的消息中间件。作为JMS的实现，消息中间件的使用步骤都大同小异，下面我们以ActiveMQ为例来介绍一下其使用。</p>
<h2 id="二、ActiveMQ的基本使用"><a href="#二、ActiveMQ的基本使用" class="headerlink" title="二、ActiveMQ的基本使用"></a>二、ActiveMQ的基本使用</h2><p><strong>ActiveMQ的安装：</strong><br>ActiveMQ安装很简单，只需从其<a href="http://activemq.apache.org/" target="_blank" rel="noopener">官网</a>下载至linux环境，解压并进入bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./activemq start #启动</span><br><span class="line">./activemq stop #停止</span><br><span class="line">./activemq status #查看状态</span><br></pre></td></tr></table></figure></p>
<p>使用启动命令运行就好了。然后我们打开浏览器进入管理后台<a href="http://yourip:8161/admin/" target="_blank" rel="noopener">http://yourip:8161/admin/</a><br>输入默认的账号密码：admin。就可以看到管控台了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_1.jpg" alt="mq_1"><br>然后我们使用java操作ActiveMQ,mq的使用基本都需要创建连接、session、Destination这么几步，我们直接看代码吧。<br><strong>点对点的模型：</strong><br>生产者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//1、创建一个连接工厂对象，需要指定服务的ip及端口。</span></span><br><span class="line">	ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.25.161:61616"</span>);</span><br><span class="line">	<span class="comment">//2、使用工厂对象创建一个Connection对象。</span></span><br><span class="line">	Connection connection = connectionFactory.createConnection();</span><br><span class="line">	<span class="comment">//3、开启连接，调用Connection对象的start方法。</span></span><br><span class="line">	connection.start();</span><br><span class="line">	<span class="comment">//4、创建一个Session对象。</span></span><br><span class="line">	<span class="comment">//第一个参数：是否开启事务。如果true开启事务，第二个参数无意义。一般不开启事务false。</span></span><br><span class="line">	<span class="comment">//第二个参数：应答模式。自动应答或者手动应答。一般自动应答。</span></span><br><span class="line">	Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">	<span class="comment">//5、使用Session对象创建一个Destination对象。两种形式queue、topic，现在应该使用queue</span></span><br><span class="line">	Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line">	<span class="comment">//6、使用Session对象创建一个Producer对象。</span></span><br><span class="line">	MessageProducer producer = session.createProducer(queue);</span><br><span class="line">	<span class="comment">//7、创建一个Message对象，可以使用TextMessage。</span></span><br><span class="line">	<span class="comment">/*TextMessage textMessage = new ActiveMQTextMessage();</span></span><br><span class="line"><span class="comment">	textMessage.setText("hello Activemq");*/</span></span><br><span class="line">	TextMessage textMessage = session.createTextMessage(<span class="string">"hello activemq"</span>);</span><br><span class="line">	<span class="comment">//8、发送消息</span></span><br><span class="line">	producer.send(textMessage);</span><br><span class="line">	<span class="comment">//9、关闭资源</span></span><br><span class="line">	producer.close();</span><br><span class="line">	session.close();</span><br><span class="line">	connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个ConnectionFactory对象连接MQ服务器</span></span><br><span class="line">	ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.25.161:61616"</span>);</span><br><span class="line">	<span class="comment">//创建一个连接对象</span></span><br><span class="line">	Connection connection = connectionFactory.createConnection();</span><br><span class="line">	<span class="comment">//开启连接</span></span><br><span class="line">	connection.start();</span><br><span class="line">	<span class="comment">//使用Connection对象创建一个Session对象</span></span><br><span class="line">	Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">	<span class="comment">//创建一个Destination对象。queue对象</span></span><br><span class="line">	Queue queue = session.createQueue(<span class="string">"spring-queue"</span>);</span><br><span class="line">	<span class="comment">//使用Session对象创建一个消费者对象。</span></span><br><span class="line">	MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//打印结果</span></span><br><span class="line">			TextMessage textMessage = (TextMessage) message;</span><br><span class="line">			String text;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				text = textMessage.getText();</span><br><span class="line">				System.out.println(text);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//等待接收消息</span></span><br><span class="line">	System.in.read();</span><br><span class="line">	<span class="comment">//关闭资源</span></span><br><span class="line">	consumer.close();</span><br><span class="line">	session.close();</span><br><span class="line">	connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们运行了生产者后，我们可以在管控台看到Queue中多了一条消息，并且还没有被消费<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_2.jpg" alt="mq_2"><br>当我们运行消费者后就可以接收到生产者发送的消息。<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_3.jpg" alt="mq_3"><br>并且管控台也出现了相应的变化<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_4.jpg" alt="mq_4"><br><strong>发布订阅的模型：</strong><br>生产者代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">  public void testTopicProducer() throws Exception &#123;</span><br><span class="line">      //1、创建一个连接工厂对象，需要指定服务的ip及端口。</span><br><span class="line">      ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.72.121:61616&quot;);</span><br><span class="line">      //2、使用工厂对象创建一个Connection对象。</span><br><span class="line">      Connection connection = connectionFactory.createConnection();</span><br><span class="line">      //3、开启连接，调用Connection对象的start方法。</span><br><span class="line">      connection.start();</span><br><span class="line">      //4、创建一个Session对象。</span><br><span class="line">      //第一个参数：是否开启事务。如果true开启事务，第二个参数无意义。一般不开启事务false。</span><br><span class="line">      //第二个参数：应答模式。自动应答或者手动应答。一般自动应答。</span><br><span class="line">      Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">      //5、使用Session对象创建一个Destination对象。两种形式queue、topic，现在应该使用topic</span><br><span class="line">      Topic topic = session.createTopic(&quot;test-topic&quot;);</span><br><span class="line">      //6、使用Session对象创建一个Producer对象。</span><br><span class="line">      MessageProducer producer = session.createProducer(topic);</span><br><span class="line">      //7、创建一个Message对象，可以使用TextMessage。</span><br><span class="line">/*TextMessage textMessage = new ActiveMQTextMessage();</span><br><span class="line">textMessage.setText(&quot;hello Activemq&quot;);*/</span><br><span class="line">      TextMessage textMessage = session.createTextMessage(&quot;topic message&quot;);</span><br><span class="line">      //8、发送消息</span><br><span class="line">      producer.send(textMessage);</span><br><span class="line">      //9、关闭资源</span><br><span class="line">      producer.close();</span><br><span class="line">      session.close();</span><br><span class="line">      connection.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个ConnectionFactory对象连接MQ服务器</span></span><br><span class="line">    ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.72.121:61616"</span>);</span><br><span class="line">    <span class="comment">//创建一个连接对象</span></span><br><span class="line">    Connection connection = connectionFactory.createConnection();</span><br><span class="line">    <span class="comment">//开启连接</span></span><br><span class="line">    connection.start();</span><br><span class="line">    <span class="comment">//使用Connection对象创建一个Session对象</span></span><br><span class="line">    Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">    <span class="comment">//创建一个Destination对象。topic对象</span></span><br><span class="line">    Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line">    <span class="comment">//使用Session对象创建一个消费者对象。</span></span><br><span class="line">    MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//打印结果</span></span><br><span class="line">            TextMessage textMessage = (TextMessage) message;</span><br><span class="line">            String text;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                text = textMessage.getText();</span><br><span class="line">                System.out.println(text);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"topic消费者3启动。。。。"</span>);</span><br><span class="line">    <span class="comment">//等待接收消息</span></span><br><span class="line">    System.in.read();</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    consumer.close();</span><br><span class="line">    session.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发布订阅模型具有严格的时间相关性，如果没有订阅者的话，发布者发布的内容就被浪费掉了。</p>
<h2 id="三、ActiveMQ与Spring整合"><a href="#三、ActiveMQ与Spring整合" class="headerlink" title="三、ActiveMQ与Spring整合"></a>三、ActiveMQ与Spring整合</h2><p>Spring提供了JMSTemplate,极大地便利了MQ的使用，我们只需要提前在配置文件中配置相关的JMS配置，就可在代码中直接使用。<br><strong>Spring配置文件：</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://192.168.25.161:61616"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置生产者 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是队列(Queue)目的地，点对点的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>spring-queue<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是主题(Topic)目的地，一对多的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"itemAddTopic"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 接收消息配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myMessageListener"</span> <span class="attr">class</span>=<span class="string">"cn.e3mall.search.listener.MyMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"queueDestination"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置好后可在代码中使用以下方法<br>生产者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 第一步：初始化一个spring容器</span></span><br><span class="line">	ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring/applicationContext-activemq.xml"</span>);</span><br><span class="line">	<span class="comment">// 第二步：从容器中获得JMSTemplate对象。</span></span><br><span class="line">	JmsTemplate jmsTemplate = applicationContext.getBean(JmsTemplate.class);</span><br><span class="line">	<span class="comment">// 第三步：从容器中获得一个Destination对象</span></span><br><span class="line">	Queue queue = (Queue) applicationContext.getBean(<span class="string">"queueDestination"</span>);</span><br><span class="line">	<span class="comment">// 第四步：使用JMSTemplate对象发送消息，需要知道Destination</span></span><br><span class="line">	jmsTemplate.send(queue, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">			TextMessage textMessage = session.createTextMessage(<span class="string">"spring activemq test"</span>);</span><br><span class="line">			<span class="keyword">return</span> textMessage;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承MessageListener接口并重新它的onMessage方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TextMessage textMessage = (TextMessage) message;</span><br><span class="line">			<span class="comment">//取消息内容</span></span><br><span class="line">			String text = textMessage.getText();</span><br><span class="line">			System.out.println(text);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者的使用是在Spring容器中注入一个监听器，所以我们需要在配置文件中配置它，它随着Spring的启动而启动，并且实时监听。当有消息向它发送时，他会立即进行逻辑处理。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/useMQ/">http://catalinali.top/2017/useMQ/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式之策略模式]]></title>
      <url>/2017/strategyPattern/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/strategy_logo.jpg" alt="strategy_logo"></p>
<blockquote>
<p>在开发中我们会使用很多中间件，开发过程当然是单机配置，可是上生产环境的时候如何快速切换到集群配置，总不能修改代码吧，这里我们就可以结合Spring来使用策略模式。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、什么是策略模式？"><a href="#一、什么是策略模式？" class="headerlink" title="一、什么是策略模式？"></a>一、什么是策略模式？</h2><p>在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过if…else…或者case等条件判断语句来进行选择。<br>    然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。</p>
<h2 id="二、基本的策略模式使用方法"><a href="#二、基本的策略模式使用方法" class="headerlink" title="二、基本的策略模式使用方法"></a>二、基本的策略模式使用方法</h2><p>我们直接来看例子：<br><strong>1.策略接口</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: Strategy Pattern Interface</span></span><br><span class="line"><span class="comment"> * Created at:	2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStrategy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.准备两个实现类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 实现类A</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是实现类A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 实现类B</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是实现类B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.策略执行Context类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 策略执行</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Strategy stg;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stg.testStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  Getter And Setter */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStg</span><span class="params">(Strategy stg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stg = stg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们准备一个main方法来测试一下他<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: StrategyTest</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Strategy stgB = <span class="keyword">new</span> StrategyB();</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(stgB);</span><br><span class="line">        context.setStg(stgB);</span><br><span class="line">        context.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://ou3np1yz4.bkt.clouddn.com/strategy_1.jpg" alt="strategy_1"><br>实例化不同的实现类可以出现不同的结果。</p>
<h2 id="三、与Spring想结合的策略模式"><a href="#三、与Spring想结合的策略模式" class="headerlink" title="三、与Spring想结合的策略模式"></a>三、与Spring想结合的策略模式</h2><p>我们主要利用Spring的核心IOC来实现它，还是使用上面的例子；<br>由于我们要在Spring的配置文件中来注入Context的实例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"context"</span> <span class="attr">class</span> = <span class="string">"top.catalinali.search.service.impl.Context"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stg"</span> <span class="attr">ref</span>=<span class="string">"stgB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stgA"</span> <span class="attr">class</span> = <span class="string">"top.catalinali.search.service.impl.StrategyA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stgB"</span> <span class="attr">class</span> = <span class="string">"top.catalinali.search.service.impl.StrategyB"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以通过只修改配置文件来更改context的实现类，从而达到策略模式的目的。</p>
<h2 id="四、通过Spring使用策略模式替换中间件的单机与集群配置"><a href="#四、通过Spring使用策略模式替换中间件的单机与集群配置" class="headerlink" title="四、通过Spring使用策略模式替换中间件的单机与集群配置"></a>四、通过Spring使用策略模式替换中间件的单机与集群配置</h2><p>在开发环境中，许多中间件使用的是单机配置。可到了生产我们就需要使用集群配置。这里我们就可以通过策略模式来快速改变中间件的配置，现在我们以Redis为例：<br><strong>1.策略接口</strong><br>首先我们把Redis方法抽成一个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JedisClient</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">set</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Boolean <span class="title">exists</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">ttl</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">incr</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">hset</span><span class="params">(String key, String field, String value)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">hget</span><span class="params">(String key, String field)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">hdel</span><span class="params">(String key, String... field)</span></span>;</span><br><span class="line">	<span class="function">Boolean <span class="title">hexists</span><span class="params">(String key, String field)</span></span>;</span><br><span class="line">	<span class="function">List&lt;String&gt; <span class="title">hvals</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">del</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.单机和集群两个实现类</strong><br>这里我们准备单机和集群两个实现类：JedisClientPool和JedisClientCluster。实现上面的JedisClient接口，分别使用单机和集群的代码来实现这些方法。因为代码冗长就不在这里贴出来了。<br><strong>3.配置文件</strong><br>我们使用不同的环境只需要把不用的配置注释掉就好。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 连接redis单机版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisClientPool"</span> <span class="attr">class</span>=<span class="string">"top.catalinali.common.jedis.JedisClientPool"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jedisPool"</span> <span class="attr">ref</span>=<span class="string">"jedisPool"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPool"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"192.168.72.121"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接redis集群 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;bean id="jedisClientCluster" class="cn.e3mall.common.jedis.JedisClientCluster"&gt;</span></span><br><span class="line"><span class="comment">	&lt;property name="jedisCluster" ref="jedisCluster"/&gt;</span></span><br><span class="line"><span class="comment">&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt;</span></span><br><span class="line"><span class="comment">	&lt;constructor-arg name="nodes"&gt;</span></span><br><span class="line"><span class="comment">		&lt;set&gt;</span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7001"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7002"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7003"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7004"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7005"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7006"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">		&lt;/set&gt;</span></span><br><span class="line"><span class="comment">	&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">&lt;/bean&gt; --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样在我们开发时只需要注释掉连接集群的配置，而在上线时注释掉单机的配置就好。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://scholers.iteye.com/blog/2012936" target="_blank" rel="noopener">spring与策略模式</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/strategyPattern/">http://catalinali.top/2017/strategyPattern/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> design-patterns </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design-patterns </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js小白入门，搭建开发环境]]></title>
      <url>/2017/installVue/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_logo.jpg" alt="installvue_logo"></p>
<blockquote>
<p>最近Vue.js的热度持续上升，甚至有标题说2017再不会Vue.js就out了。而作为一个不排斥前段的后端码农来说，当然也要跟得上时代。近来准备放下手中的DOM操作，来一次Vue.js从入门到放弃。现将环境搭建过程记录下来。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>Node.js Javascript的运行时环境</li>
<li>npm Node.js下的包管理工具</li>
<li>webpack 前端资源模块化管理和打包工具</li>
<li>vue-cli 脚手架构建工具</li>
<li>cnpm  npm的淘宝镜像</li>
</ul>
<p>如果你像我一样是个后端开发者，并且对以上的工具还处在一脸懵逼的状态下。那么可以先看一下这篇文章<a href="https://zhuanlan.zhihu.com/p/31044340" target="_blank" rel="noopener">萌新也能懂的现代 JavaScript 开发</a>。了解一下现代 JavaScript的演变过程。</p>
<h3 id="Vue-js安装"><a href="#Vue-js安装" class="headerlink" title="Vue.js安装"></a>Vue.js安装</h3><p><strong>1.</strong> Node.js的安装非常容易，首先从<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载你所需操作系统的版本，然后一直下一步就ok，这里贴个菜鸟教程的<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">传送门</a>。<br>安装完成之后，在命令行敲出<code>node -v</code>，如果出现对应版本号，则表示安装成功。<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_01.jpg" alt="installvue_01"><br><strong>2.</strong> npm是随同Node.js一起安装的包管理工具,直接在命令行敲出<code>npm -v</code>就可以查看是否安装成功。<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_02.jpg" alt="installvue_02"><br>npm包管理器虽然有了，但是由于npm下载需要依赖包的服务器地址在国外，导致很多资源访问会很慢。所以我们可以安装淘宝的国内镜像。<br><strong>3.</strong> 在命令行敲出<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>。<br>这样就可以使用 cnpm 命令来安装模块了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install [name]</span><br></pre></td></tr></table></figure></p>
<p><strong>4.</strong> 安装webpack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack -g</span><br></pre></td></tr></table></figure></p>
<p><strong>5.</strong> 安装vue脚手架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure></p>
<h3 id="初始化一个Vue-js环境"><a href="#初始化一个Vue-js环境" class="headerlink" title="初始化一个Vue.js环境"></a>初始化一个Vue.js环境</h3><p>在电脑上新建一个文件夹用来存放我们的代码。然后使用命令行进入这个文件夹<code>cd 目录路径</code>。<br>之后使用命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack name</span><br></pre></td></tr></table></figure></p>
<p>来初始化一个vue环境，这个命令的意思是初始化一个项目，其中webpack是构建工具，也就是整个项目是基于webpack的。在安装过程会有一些初始化的设置，我们可以采用默认配置，一路回车 。<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_04.png" alt="installvue_04"><br>从上图的我们还可以看到vue很贴心的告诉了我们快速开始(To get started)的命令<br><strong>安装项目依赖</strong><br>一定要从官方仓库安装，npm 服务器在国外所以这一步安装速度会很慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<p>不要从国内镜像cnpm安装(会导致后面缺了很多依赖库)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure></p>
<p>安装 vue 路由模块vue-router和网络请求模块vue-resource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-router vue-resource --save</span><br></pre></td></tr></table></figure></p>
<p>启动项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p>
<p>运行成功以后他会告诉你ip和端口号<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_05.png" alt="installvue_05"><br>访问这个地址<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_06.png" alt="installvue_06"><br>如果出现上图。恭喜你，已经可以开始Vue.js之旅了。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/installVue/">http://catalinali.top/2017/installVue/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> vue.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[走进Redis：Redis的安装、使用以及集群的搭建]]></title>
      <url>/2017/buildredis/</url>
      <content type="html"><![CDATA[<hr>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/redis_logo.jpeg" alt="redis_logo"></p>
<blockquote>
<p>今天学习了淘淘商城中的redis的使用，在这里把它记录下来。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、Redis的安装"><a href="#一、Redis的安装" class="headerlink" title="一、Redis的安装"></a>一、Redis的安装</h2><p>Redis的安装是很简单的,安装之前我们需要c语言的编译环境。如果没有gcc需要在线安装。<code>yum install gcc-c++</code>。</p>
<h3 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h3><p>第一步：redis的源码包上传到linux系统。<br>第二步：解压缩redis。<code>tar -zxvf redis-3.0.0.tar.gz</code><br>第三步：编译。进入redis源码目录。<code>make</code><br>第四步：安装。<code>make install PREFIX=/usr/local/redis</code>,PREFIX参数指定redis的安装目录。</p>
<h2 id="二、Redis的启动与基本操作"><a href="#二、Redis的启动与基本操作" class="headerlink" title="二、Redis的启动与基本操作"></a>二、Redis的启动与基本操作</h2><p><strong>1.运行redis</strong><br>在redis的安装目录下直接运行<code>./redis-server</code>就可以启动redis,但这是前端启动。如果我们想后台启动就需要：<br>①进入<em>redis-3.0.0.tar.gz</em>解压出来的文件夹，复制里面的redis.conf文件到安装目录下。然后将daemonize改为yes<img src="http://ou3np1yz4.bkt.clouddn.com/redis_1.jpg" alt="redis_1"><br>②执行<code>./redis-server redis.conf</code>运行redis。这样redis就后台运行了,我们可以使用<code>ps aux|grep redis</code>来查看redis的运行状态<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_2.png" alt="redis_2"><br>我们可以使用以下命令来进入操作redis：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli ##进入redis客户端</span><br><span class="line">./redis-cli -h 192.168.72.121 -p 6379 ##连接指定ip和端口的redis服务器</span><br><span class="line">./redis-cli shutdown ##关闭redis客户端</span><br></pre></td></tr></table></figure></p>
<p><strong>2.redis中的五种类型</strong><br>先来看几个操作数据库的基本命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KEYS *                   ##获得当前数据库的所有键</span><br><span class="line">EXISTS key [key ...]     ##判断键是否存在，返回个数，如果key有一样的也是叠加数</span><br><span class="line">DEL key [key ...]        ##删除键，返回删除的个数</span><br><span class="line">TYPE key                 ##获取减值的数据类型（string，hash，list，set，zset）</span><br><span class="line">FLUSHALL                 ##清空所有数据库</span><br><span class="line">Expire key second        ##设置key的过期时间</span><br><span class="line">Ttl key                  ##查看key的有效期</span><br><span class="line">Persist key              ##清除key的过期时间。Key持久化。</span><br></pre></td></tr></table></figure></p>
<p>redis中所有的数据都是Key-value类型的，其中有五种主要数据类型：字符串类型（string），散列类型（hash），列表类型（list），集合类型（set），有序集合类型（zset）。而在这五种类型中，我们最常用的是字符串类型，散列类型。这里简单介绍一下字符串类型和散列类型：<br>①<strong>字符串类型string</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET         ##赋值，用法： SET key value</span><br><span class="line">GET         ##取值，用法： GET key</span><br><span class="line">INCR        ##递增数字，仅仅对数字类型的键有用，相当于Java的i++运算，用法： INCR key</span><br><span class="line">INCRBY      ##增加指定的数字，仅仅对数字类型的键有用，相当于Java的i+=3，用法：INCRBY key increment，意思是key自增increment，increment可以为负数，表示减少。</span><br><span class="line">DECR        ##递减数字，仅仅对数字类型的键有用，相当于Java的i–，用法：DECR key</span><br><span class="line">DECRBY      ##减少指定的数字，仅仅对数字类型的键有用，相当于Java的i-=3，用法：DECRBY key decrement，意思是key自减decrement，decrement可以为正数，表示增加。</span><br><span class="line">INCRBYFLOAT ##增加指定浮点数，仅仅对数字类型的键有用，用法：INCRBYFLOAT key increment</span><br><span class="line">APPEND      ##向尾部追加值，相当于Java中的”hello”.append(“ world”)，用法：APPEND key value</span><br><span class="line">STRLEN      ##获取字符串长度，用法：STRLEN key</span><br><span class="line">MSET        ##同时设置多个key的值，用法：MSET key1 value1 [key2 value2 ...]</span><br><span class="line">MGET        ##同时获取多个key的值，用法：MGET key1 [key2 ...]</span><br></pre></td></tr></table></figure></p>
<p>②<strong>散列类型hash</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HSET        ##赋值，用法：HSET key field value</span><br><span class="line">HMSET       ##一次赋值多个字段，用法：HMSET key field1 value1 [field2 values]</span><br><span class="line">HGET        ##取值，用法：HSET key field</span><br><span class="line">HMGET       ##一次取多个字段的值，用法：HMSET key field1 [field2]</span><br><span class="line">HGETALL     ##一次取所有字段的值，用法：HGETALL key</span><br><span class="line">HEXISTS     ##判断字段是否存在，用法：HEXISTS key field</span><br><span class="line">HSETNX      ##当字段不存在时赋值，用法：HSETNX key field value</span><br><span class="line">HINCRBY     ##增加数字，仅对数字类型的值有用，用法：HINCRBY key field increment</span><br><span class="line">HDEL        ##删除字段，用法：HDEL key field</span><br><span class="line">HKEYS       ##获取所有字段名，用法：HKEYS key</span><br><span class="line">HVALS       ##获取所有字段值，用法：HVALS key</span><br><span class="line">HLEN        ##获取字段数量，用法：HLEN key</span><br></pre></td></tr></table></figure></p>
<p>其他的数据类型就不详细介绍了，相关资料可以点击<a href="https://www.baidu.com/s?wd=redis%E7%9A%84%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B&amp;rsv_spt=1&amp;rsv_iqid=0xe2ece0d100005fa4&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_n=2&amp;rsv_sug3=17&amp;rsv_sug1=14&amp;rsv_sug7=100&amp;rsv_t=eae6CtVWEeBxwTXJYEIsK1Rg%2BIZxWLgTM0hyCSOEYS2VOLZsg6CfpRxdvrRCXXlTZCe7&amp;rsv_sug2=0&amp;inputT=3842&amp;rsv_sug4=3842" target="_blank" rel="noopener">传送门</a></p>
<h2 id="三、Redis的持久化方案"><a href="#三、Redis的持久化方案" class="headerlink" title="三、Redis的持久化方案"></a>三、Redis的持久化方案</h2><p>Redis的所有数据都是保存到内存中的。<br>Rdb：快照形式，定期把内存中当前时刻的数据保存到磁盘。Redis默认支持的持久化方案,一直开启,不会被关闭。<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_3.png" alt="redis_Rdb"><br>通过上图我们可以看到,<strong>dump.rdb</strong>会在以下情况保存一次。</p>
<ul>
<li>900秒（15分钟）之内至少有1个KEY进行了改变</li>
<li>300秒（5分钟）之内至少有10个KEY进行了改变</li>
<li>60秒（1分钟）之内至少有10000个KEY进行了改变</li>
</ul>
<p>aof形式：append only file。把所有对redis数据库操作的命令，增删改操作的命令。保存到文件中。数据库恢复时把所有的命令执行一遍即可。要想开启aof模式需要在<strong>redis.conf</strong>配置文件中将appendonly改为yes<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_4.png" alt="redis_aof"></p>
<h2 id="四、Redis集群的搭建"><a href="#四、Redis集群的搭建" class="headerlink" title="四、Redis集群的搭建"></a>四、Redis集群的搭建</h2><h3 id="1-Redis集群特点"><a href="#1-Redis集群特点" class="headerlink" title="1.Redis集群特点"></a>1.Redis集群特点</h3><p>Redis集群搭建的方式有多种，例如使用zookeeper等，但从redis3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其redis-cluster架构图如下：<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_5.png" alt="redis_cluster"><br>其架构细节：<br>1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。<br>2、节点的fail是通过集群中超过半数的节点检测失效时才生效。<br>3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。<br>4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。<br>5、Redis集群预分好16384个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个槽中。</p>
<h3 id="2-Redis集群环境搭建"><a href="#2-Redis集群环境搭建" class="headerlink" title="2.Redis集群环境搭建"></a>2.Redis集群环境搭建</h3><p>Redis集群中至少应该有三个节点。要保证集群的高可用，需要每个节点有一个备份机。<br>Redis集群至少需要6台服务器。由于条件限制,这里采用与淘淘商城相同的方式搭建伪分布式。在一台虚拟机运行6个redis实例。需要修改redis的端口号7001-7006。<br><strong>第一步</strong>：创建6个redis实例，每个实例运行在不同的端口。需要修改redis.conf配置文件,将端口号修改成7001-7006。除此之外,还需要把cluster-enabled yes前的注释去掉。<br><strong>第二步</strong>：启动每个redis实例。这里我们可以自己写一个shell脚本,这里给出我的也就是淘淘商城中所使用的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd redis01</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis02</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis03</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis04</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis05</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis06</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></p>
<p>关闭集群的脚本也类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -p 7001 shutdown</span><br><span class="line">./redis-cli -p 7002 shutdown</span><br><span class="line">./redis-cli -p 7003 shutdown</span><br><span class="line">./redis-cli -p 7004 shutdown</span><br><span class="line">./redis-cli -p 7005 shutdown</span><br><span class="line">./redis-cli -p 7006 shutdown</span><br></pre></td></tr></table></figure></p>
<p>记得在运行脚本前要添加可执行（x）的权限：<code>chmod u+x fileName.sh</code><br><strong>第三步</strong>：使用ruby脚本搭建集群。<br>首先我们需要安装ruby运行环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br></pre></td></tr></table></figure></p>
<p>然后我们需要安装ruby脚本运行使用的包,将这个文件放在集群文件根目录下，然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-3.0.0.gem</span><br></pre></td></tr></table></figure></p>
<p>文件我上传在了<a href="http://download.csdn.net/download/a3212/10048482" target="_blank" rel="noopener">CSDN</a>。<br>这时我们就可以启动集群环境了,运行下面这条命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 192.168.72.121:7001 192.168.72.121:7002 192.168.72.121:7003 192.168.72.121:7004 192.168.72.121:7005  192.168.72.121:7006</span><br></pre></td></tr></table></figure></p>
<p>从这条命令我们可以看出使用6个节点来创建一个集群，集群中每个主节点有1个从节点。运行过程中输入一个yes就成功了。需要注意的是在真正搭建的时候一定要关闭防火墙。这时候我们查看进程<br><strong>第四步</strong>：连接Redis集群<br>因为每一个节点都是互联互通的,所以我们不论连哪个节点都是可以的。</p>
<h2 id="五、使用Java操作Redis"><a href="#五、使用Java操作Redis" class="headerlink" title="五、使用Java操作Redis"></a>五、使用Java操作Redis</h2><p>redis的客户端有很多,从<a href="http://www.redis.cn/clients.html#java" target="_blank" rel="noopener">官网</a>中我们可以看出来,不仅支持的语言众多,而且很多语言有不止一种连接方式。<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_6.png" alt="redis_client"><br>这里我们采用在JAVA中使用最广泛的Jedis作为实例。</p>
<h3 id="1-连接单机版"><a href="#1-连接单机版" class="headerlink" title="1.连接单机版"></a>1.连接单机版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 第一步：创建一个Jedis对象。需要指定服务端的ip及端口。</span></span><br><span class="line">	Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.25.153"</span>, <span class="number">6379</span>);</span><br><span class="line">	<span class="comment">// 第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。</span></span><br><span class="line">	String result = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">	<span class="comment">// 第三步：打印结果。</span></span><br><span class="line">	System.out.println(result);</span><br><span class="line">	<span class="comment">// 第四步：关闭Jedis</span></span><br><span class="line">	jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来很简单,不过通常在连接单机版的时候我们采用的是连接池的方式。</p>
<h3 id="2-连接单机版使用连接池"><a href="#2-连接单机版使用连接池" class="headerlink" title="2.连接单机版使用连接池"></a>2.连接单机版使用连接池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisPool</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 第一步：创建一个JedisPool对象。需要指定服务端的ip及端口。</span></span><br><span class="line">	JedisPool jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.25.153"</span>, <span class="number">6379</span>);</span><br><span class="line">	<span class="comment">// 第二步：从JedisPool中获得Jedis对象。</span></span><br><span class="line">	Jedis jedis = jedisPool.getResource();</span><br><span class="line">	<span class="comment">// 第三步：使用Jedis操作redis服务器。</span></span><br><span class="line">	jedis.set(<span class="string">"jedis"</span>, <span class="string">"test"</span>);</span><br><span class="line">	String result = jedis.get(<span class="string">"jedis"</span>);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">	<span class="comment">// 第四步：操作完毕后关闭jedis对象，连接池回收资源。</span></span><br><span class="line">	jedis.close();</span><br><span class="line">	<span class="comment">// 第五步：关闭JedisPool对象。</span></span><br><span class="line">	jedisPool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接集群的方式就又稍微不一样了。</p>
<h3 id="3-连接集群版"><a href="#3-连接集群版" class="headerlink" title="3.连接集群版"></a>3.连接集群版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   @Testjava</span><br><span class="line">public void testJedisCluster() throws Exception &#123;</span><br><span class="line">	// 第一步：使用JedisCluster对象。需要一个Set&lt;HostAndPort&gt;参数。Redis节点的列表。</span><br><span class="line">	Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7001));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7002));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7003));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7004));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7005));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7006));</span><br><span class="line">	JedisCluster jedisCluster = new JedisCluster(nodes);</span><br><span class="line">	// 第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。</span><br><span class="line">	jedisCluster.set(&quot;hello&quot;, &quot;100&quot;);</span><br><span class="line">	String result = jedisCluster.get(&quot;hello&quot;);</span><br><span class="line">	// 第三步：打印结果</span><br><span class="line">	System.out.println(result);</span><br><span class="line">	// 第四步：系统关闭前，关闭JedisCluster对象。</span><br><span class="line">	jedisCluster.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/buildredis/">http://catalinali.top/2017/buildredis/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx初探究：安装与简单使用]]></title>
      <url>/2017/helloNginx/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/nginx_logo1.jpg" alt="nginx_logo"></p>
<blockquote>
<p>在学习淘淘商城的过程中接触到了nginx,今天就把使用它的过程记录下来,作为留存。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、什么是Nginx"><a href="#一、什么是Nginx" class="headerlink" title="一、什么是Nginx"></a>一、什么是Nginx</h2><p>Nginx是一款高性能的http服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li>
<li>虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</li>
<li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li>
</ul>
<h2 id="二、nginx安装"><a href="#二、nginx安装" class="headerlink" title="二、nginx安装"></a>二、nginx安装</h2><h3 id="1-官网下载nginx源码。"><a href="#1-官网下载nginx源码。" class="headerlink" title="1.官网下载nginx源码。"></a>1.<a href="http://nginx.org/" target="_blank" rel="noopener">官网</a>下载nginx源码。</h3><h3 id="2-外部环境准备"><a href="#2-外部环境准备" class="headerlink" title="2.外部环境准备:"></a>2.外部环境准备:</h3><ul>
<li>需要安装gcc的环境:<code>yum install gcc-c++</code></li>
<li>第三方的开发包:<br>① PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>②zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></p>
<p>③OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure></p>
<h3 id="3-正式安装"><a href="#3-正式安装" class="headerlink" title="3.正式安装"></a>3.正式安装</h3><p>第一步：把nginx的源码包上传到linux系统<br>第二步：解压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxf nginx-1.8.0.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>第三步：使用configure命令创建一makeFile文件。<br>./configure \<br>–prefix=/usr/local/nginx \<br>–pid-path=/var/run/nginx/nginx.pid \<br>–lock-path=/var/lock/nginx.lock \<br>–error-log-path=/var/log/nginx/error.log \<br>–http-log-path=/var/log/nginx/access.log \<br>–with-http_gzip_static_module \<br>–http-client-body-temp-path=/var/temp/nginx/client \<br>–http-proxy-temp-path=/var/temp/nginx/proxy \<br>–http-fastcgi-temp-path=/var/temp/nginx/fastcgi \<br>–http-uwsgi-temp-path=/var/temp/nginx/uwsgi \<br>–http-scgi-temp-path=/var/temp/nginx/scgi<br>注意：以上都是一些安装时配置nginx的一些参数,具体含义可以自行百度。另外在启动nginx之前，上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/temp/nginx/client -p</span><br></pre></td></tr></table></figure></p>
<p>第四步：编译,运行<code>make</code>命令<br>第五步：安装运行<code>make install</code>命令<br>第六步：测试<br>进入安装目录下的<strong>sbin</strong>文件,运行<code>./nginx</code>后，打开浏览器访问主机ip。<br>注意：①默认是80端口。②是否关闭防火墙。<br><img src="http://ou3np1yz4.bkt.clouddn.com/nginx_1.png" alt="nginx_1"><br>如果出现上图，恭喜你，nginx安装成功。<br>相关命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop ##关闭nginx</span><br><span class="line">./nginx -s quit ##关闭nginx(推荐使用)</span><br><span class="line">./nginx -s reload ##重启nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="三、配置虚拟主机"><a href="#三、配置虚拟主机" class="headerlink" title="三、配置虚拟主机"></a>三、配置虚拟主机</h2><h3 id="1-通过端口号区分虚拟主机"><a href="#1-通过端口号区分虚拟主机" class="headerlink" title="1.通过端口号区分虚拟主机"></a>1.通过端口号区分虚拟主机</h3><p>打开nginx的配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>可以看到一个server节点,这个就是我们配置虚拟主机的关键,每一个此节点代表一台主机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;    ##端口号</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;    ##nginx安装目录下的html目录</span><br><span class="line">        index  index.html index.htm; ##每台主机对应的页面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们配置了多个server，就相当于配置了多个虚拟主机。这时我们就可以通过不同的端口号来进行访问。</p>
<h3 id="2-通过域名区分虚拟主机"><a href="#2-通过域名区分虚拟主机" class="headerlink" title="2.通过域名区分虚拟主机"></a>2.通过域名区分虚拟主机</h3><p>首先我们要知道当我们打开浏览器访问每一个域名的时候，每一个域名对应的是一个ip地址。并且一个ip地址可以被多个域名绑定。当我们在本地hosts文件（C:\Windows\System32\drivers\etc）中配置了域名与ip的对应的映射关系时，浏览器就不会再去走DNS服务器<br>为了方便测试，我们先在本地hosts文件配置一下测试所用数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.71.121 www.taobao.com</span><br><span class="line">192.168.21.121 www.baidu.com</span><br></pre></td></tr></table></figure></p>
<p>然后配置两个server节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.taobao.com; ##不同域名配置</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html-taobao; ##不同域名访问的不同文件夹</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.baidu.com; ##不同域名配置</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html-baidu; ##不同域名访问的不同文件夹</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在浏览器上访问这两个地址就可以访问到我们配置的两台虚拟主机。</p>
<h2 id="四、反向代理"><a href="#四、反向代理" class="headerlink" title="四、反向代理"></a>四、反向代理</h2><h3 id="1-什么是反向代理"><a href="#1-什么是反向代理" class="headerlink" title="1.什么是反向代理"></a>1.什么是反向代理</h3><p>两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容。<br>两个域名是www.sian.com.cn和www.sohu.com<br>nginx服务器使用虚拟机192.168.101.3</p>
<h3 id="2-实现反向代理"><a href="#2-实现反向代理" class="headerlink" title="2.实现反向代理"></a>2.实现反向代理</h3><p>第一步：安装两个tomcat，分别运行在8080和8081端口。<br>第二步：启动两个tomcat。<br>第三步：反向代理服务器的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat1 &#123;</span><br><span class="line">	server 192.168.25.148:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.sina.com.cn;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass   http://tomcat1;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    upstream tomcat2 &#123;</span><br><span class="line">	server 192.168.25.148:8081;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.sohu.com;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass   http://tomcat2;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>第四步：nginx重新加载配置文件<br>第五步：配置域名<br>在hosts文件中添加域名和ip的映射关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.71.121 www.sina.com.cn</span><br><span class="line">192.168.71.121 www.sohu.com</span><br></pre></td></tr></table></figure></p>
<h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><p>如果一个服务由多条服务器提供，需要把负载分配到不同的服务器处理，需要负载均衡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat2 &#123;</span><br><span class="line">server 192.168.71.121:8081;</span><br><span class="line">server 192.168.71.121:8082;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以根据服务器的实际情况调整服务器权重。权重越高分配的请求越多，权重越低，请求越少。默认是都是1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat2 &#123;</span><br><span class="line">server 192.168.71.121:8081;</span><br><span class="line">server 192.168.71.121:8082 weight=2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/helloNginx/">http://catalinali.top/2017/helloNginx/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记录：mysql中的case when|on duplicate key update|重复插入返回主键的用法]]></title>
      <url>/2017/recordsql/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/case_logo.jpg" alt="case_logo"><br>在平时的开发中不免接触到数据库,这里记录一些平时开发中遇到的细节问题，与大家共勉。</p>
<hr>
<a id="more"></a>
<h2 id="mysql中的条件控制：case函数"><a href="#mysql中的条件控制：case函数" class="headerlink" title="mysql中的条件控制：case函数"></a>mysql中的条件控制：case函数</h2><p>在操作数据库的开发中不免遇到一些类似if else的判断,这时候就用到了Case函数,首先我们用网上用了好多次的例子来看看它的用法:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case when sex = '1' then '男'  </span><br><span class="line">     when sex = '2' then '女'  </span><br><span class="line">     else '其他' <span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p> 利用这个格式我们可以就可以完成类似if else的操作,比如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">SUM</span>(</span><br><span class="line">    <span class="keyword">case</span> </span><br><span class="line">    <span class="keyword">when</span> V.IN_OUT = <span class="string">'2'</span> <span class="keyword">then</span> -AMOUNT</span><br><span class="line">    <span class="keyword">when</span> V.IN_OUT = <span class="string">'1'</span> <span class="keyword">then</span> AMOUNT <span class="keyword">end</span>) AMOUNT</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tb_financial</span><br></pre></td></tr></table></figure>
<p>怎么样,很简单吧！</p>
<h2 id="mysql中重复插入时更新"><a href="#mysql中重复插入时更新" class="headerlink" title="mysql中重复插入时更新"></a>mysql中重复插入时更新</h2><p>为了防止数据重复插入报错,我们可以让重复插入主键相同的数据时改为更新这条数据。<br>我们使用mysql官网的例子:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=c+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>按照<a href="https://dev.mysql.com/doc/refman/5.5/en/insert-on-duplicate.html" target="_blank" rel="noopener">官网</a>的说法,如果列a被声明为UNIQUE并包含该值 1，则这两个语句具有类似的效果。当列b也是唯一的时候,则相当于下面这条sql:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> a=<span class="number">1</span> <span class="keyword">OR</span> b=<span class="number">2</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是,并不建议ON DUPLICATE KEY UPDATE在具有<strong>多个唯一索引</strong>的表上使用。</p>
<h2 id="MyBatis-MySQL-返回插入的主键ID"><a href="#MyBatis-MySQL-返回插入的主键ID" class="headerlink" title="MyBatis+MySQL 返回插入的主键ID"></a>MyBatis+MySQL 返回插入的主键ID</h2><p>在使用Mybatis想返回插入的主键ID也很简单,只需要在insert的Mapper中添加useGeneratedKeys=”true”和keyProperty=”实体中主键属性名”两个属性:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id="InsertTBFinancial" useGeneratedKeys="true" keyProperty="id"&gt;</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Tb_financial</span><br><span class="line">			(<span class="keyword">id</span>,</span><br><span class="line">			 amount,</span><br><span class="line">			 <span class="keyword">comment</span>)</span><br><span class="line">		<span class="keyword">VALUES</span></span><br><span class="line">			(#&#123;<span class="keyword">id</span>&#125;,</span><br><span class="line">			 #&#123;amount&#125;,</span><br><span class="line">			 #&#123;<span class="keyword">comment</span>&#125;)</span><br><span class="line">  	&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样在调用此方法后实体中的主键值就会自动返回:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Financial Financial = <span class="keyword">new</span> Financial();  </span><br><span class="line">Financial.setId(<span class="string">"chenzhou"</span>);  </span><br><span class="line">Financial.setAmount(<span class="string">"xxxx"</span>);  </span><br><span class="line">Financial.setComment(<span class="string">"测试插入数据返回主键功能"</span>);  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"插入前主键为："</span>+user.getId());  </span><br><span class="line">userDao.insertAndGetId(user);<span class="comment">//插入操作  </span></span><br><span class="line">System.out.println(<span class="string">"插入后主键为："</span>+user.getId());</span><br></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/recordsql/">http://catalinali.top/2017/recordsql/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dubbo初体验:远程服务调用和管控台的搭建]]></title>
      <url>/2017/helloDubbo/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_logo.jpg" alt="hellodubbo_logo"></p>
<blockquote>
<p>Dubbo是一个阿里巴巴的分布式服务框架。虽然在很久以前阿里停止更新了,但是还是有很多公司在使用它。Dubbo致力于提供高性能和透明化的RPC远程服务调用方案以及SOA服务治理方案。通过他我们可以非常容易地通过Dubbo来构建分布式服务。哦，对了。好像最近阿里又开始更新了。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="Dubbo的架构"><a href="#Dubbo的架构" class="headerlink" title="Dubbo的架构"></a>Dubbo的架构</h2><p><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_1.png" alt="hellodubbo_1"><br><strong>调用关系说明：</strong></p>
<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。 </li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br><br><br>这张图和这段话你可能已经见过无数次了,但是我还是把它从<a href="http://dubbo.io/" target="_blank" rel="noopener">官网</a>复制了过来。原因就是这张图能很简洁的说么Dubbo的调用关系。如果你还没有使用过Dubbo,那这张图可以很快帮你理顺调用关系。</li>
</ul>
<h2 id="Hello-Dubbo"><a href="#Hello-Dubbo" class="headerlink" title="Hello Dubbo"></a>Hello Dubbo</h2><p>我们在使用过程中一般是采用XML配置,原因就是简单方便。在使用之前我们需要搭建Dubbo的注册中心。官方推荐的注册中心是zookeeper。如果你还没有搭建好zookeeper,那么可以看看我之前写的<a href="http://catalinali.top/2017/buildzookeeper/">小白从头到脚搭建zookeeper集群的过程</a>。<br><strong>1.Dubbo依赖</strong><br>如果你使用的是Maven项目,在使用Dubbo的地方加入下面的依赖即可:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.生产者</strong><br>首先展示生产者的接口,很简单的两个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生产者的实现类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleServiceImpl</span> <span class="keyword">implements</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>User类的话就是name、age、sex三个属性。<br><br>接下来就是生产者的Spring配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 具体的实现bean --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sampleService"</span> <span class="attr">class</span>=<span class="string">"top.catalinali.sample.provider.impl.SampleServiceImpl"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"sample-provider"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.71.121:2181?backup=192.168.71.122:2181,192.168.71.123:2181"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 声明需要暴露的服务接口  写操作可以设置retries=0 避免重复调用SOA服务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">retries</span>=<span class="string">"0"</span> <span class="attr">interface</span>=<span class="string">"top.catalinali.sample.provider.SampleService"</span> <span class="attr">ref</span>=<span class="string">"sampleService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.消费者</strong><br>首先消费者需要一个跟生产一模一样的接口类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"sample-consumer"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.71.121:2181?backup=192.168.71.122:2181,192.168.71.123:2181"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 生成远程服务代理，可以像使用本地bean一样使用demoService 检查级联依赖关系 默认为true 当有依赖服务的时候，需要根据需求进行设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"sampleService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">interface</span>=<span class="string">"top.catalinali.sample.provider.SampleService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Dubbo启动"><a href="#Dubbo启动" class="headerlink" title="Dubbo启动"></a>Dubbo启动</h2><p>首先我们先启动生产者启动:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">				<span class="keyword">new</span> String[] &#123; <span class="string">"sample-provider.xml"</span> &#125;);</span><br><span class="line">		context.start(); </span><br><span class="line">		System.in.read(); <span class="comment">// 为保证服务一直开着，利用输入流的阻塞来模拟</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动消费者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">				<span class="keyword">new</span> String[] &#123; <span class="string">"sample-consumer.xml"</span> &#125;);</span><br><span class="line">		context.start();</span><br><span class="line">			</span><br><span class="line">		SampleService sampleService = (SampleService) context.getBean(<span class="string">"sampleService"</span>);</span><br><span class="line">		String hello = sampleService.sayHello(<span class="string">"tom"</span>);</span><br><span class="line">		System.out.println(hello);</span><br><span class="line">		</span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_2.png" alt="hellodubbo_2"><br>项目结构图<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_4.png" alt="hellodubbo_3"></p>
<h2 id="Dubbo的管控台"><a href="#Dubbo的管控台" class="headerlink" title="Dubbo的管控台"></a>Dubbo的管控台</h2><p>Dubbo管控台搭建其实很容易,我们只需要一个在linux上的tomcat跑Dubbo即可,需要的环境:</p>
<ul>
<li>apache-tomcat-7.0.29.tar.gz</li>
<li>dubbo-admin-2.5.4.war</li>
</ul>
<p><strong>1.安装tomcat</strong><br>使用<code>tar -zxvf apache-tomcat-7.0.29.tar.gz</code>解压tar包<br><strong>2.解压dubbo的war包</strong><br>使用<code>unzip dubbo-admin-2.5.3.war -d dubbo-admin</code>解压dubbo-admin-2.5.4.war到tomcat目录下的webapps下。如果提示无unzip命令,使用yum安装<code>yum install -y unzip zip</code>此命令<br><em>注意：</em><br>如果zookeeper注册中心不在此服务器上,则需要打开dubbo-admin/WEB-INF/dubbo.properties文件,将红框改注册中心的ip地址。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_5.png" alt="hellodubbo_5"><br><strong>3.运行tomcat</strong><br>①进入tomcat下的bin目录下,执行<code>./startup.sh</code>脚本。<br>②使用<code>tail -f ../logs/catalina.out</code>查看日志。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_6.png" alt="hellodubbo_6"><br>③进入<em><a href="http://192.168.71.121:8080/dubbo-admin/" target="_blank" rel="noopener">http://192.168.71.121:8080/dubbo-admin/</a></em>就可以看到管控台了(IP地址改成你的服务器ip)<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_7.png" alt="hellodubbo_7"><br>也可以看到我们刚才所运行的服务<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_8.png" alt="hellodubbo_8"></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/helloDubbo/">http://catalinali.top/2017/helloDubbo/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Dubbo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白从头到脚搭建zookeeper集群的过程]]></title>
      <url>/2017/buildzookeeper/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_logo.jpg" alt="buildzk_logo"></p>
<blockquote>
<p>zookeeper的字面意思为动物园管理员,正如他的名字,各个子系统能正常为用户提供统一的服务。并且还可以作为Dubbo的注册中心来使用。今天进行了一番centos的安装到zookeeper集群的搭建,也遇到不少坑。特此记录下来搭建过程。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>VMware Workstation 11   </li>
<li>centos 6.4镜像</li>
<li>jdk-7u67-linux-x64.tar.gz</li>
<li>zookeeper-3.4.6.tar.gz</li>
<li>Xshell </li>
<li>Xftp</li>
</ul>
<h2 id="搭建linux环境"><a href="#搭建linux环境" class="headerlink" title="搭建linux环境"></a>搭建linux环境</h2><p>1.linux安装过程就不赘述了,网上有很多。可以参考<a href="http://blog.csdn.net/lzwglory/article/details/53468199" target="_blank" rel="noopener">这一篇</a>。需要注意的是安装过程中我们最好配置一下网络:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_8.png" alt="buildzk_8"><br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_9.png" alt="buildzk_9"><br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_10.png" alt="buildzk_10"><br>最后一步中红色方框的一样就好了,ip只需要最后一段不一样即可。另外我安装的也是minimal模式。<br>2.安装好centos以后我们要更改一下网络连接方式。如图:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_1.png" alt="buildzk_1"><br>3.这样我们就安装好了一台linux,由于我们要搭建集群,所以我们再克隆2台linux:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_2.jpg" alt="buildzk_2"><br>除了这一步,其他的一直下一步就好<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_3.jpg" alt="buildzk_3"><br>这时我们就得到了3台linux环境。可是由于是克隆的,所以后两台连ip地址都是一样的。所以我们需要更改一些配置来使得后2台也能有了自己的ip。参考<a href="http://www.linuxidc.com/Linux/2012-12/76248.htm" target="_blank" rel="noopener">这一篇</a>。<br>4.开启我们的三台linux环境,使用Xshell分别进行连接。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_4.png" alt="buildzk_4"><br>至此,linux环境就搭建成功了。</p>
<h2 id="搭建zookeeper集群"><a href="#搭建zookeeper集群" class="headerlink" title="搭建zookeeper集群"></a>搭建zookeeper集群</h2><p>1.由于zookeeper是Java编写的,运行在Java环境上，所以我们要先安装jdk。具体安装过程可以看我之前写的<a href="http://catalinali.top/2017/installjira/">centos7下破解安装JIRA 7.2</a>的开头部分。<br>2.使用tar -zxvf 将<code>zookeeper-3.4.6.tar.gz</code>解压到某一个位置。<br>3.将zookeeper-3.4.6/conf目录下面的zoo_sample.cfg修改为zoo.cfg。<br>4.使用vi/vim命令修改<code>zoo.cfg</code>的内容如下图:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_5.png" alt="buildzk_5"><br>其中上面的红框是zookeeper的<strong>数据日志目录</strong>,可以更改成自己的位置。下面的红框是集群中服务的列表。<br>5.分别操作linux进入刚才修改的<strong>数据日志目录</strong>,新建一个myid文件。内容分别是<strong>0</strong>、<strong>1</strong>、<strong>2</strong>。没有错,里面就一个数字，用来唯一标识这个服务。这个id是很重要的，一定要保证整个集群中唯一。zookeeper会根据这个id来取出server.x上的配置。比如当前id为1，则对应着zoo.cfg里的server.1的配置。<br>6.使用关闭<code>service iptables stop</code>暂时关闭防火墙,或者使用<code>chkconfig iptables off</code>永久禁用防火墙。然后进入zookeeper下的bin目录,使用./zkServer.sh start同时对三个linux进行操作。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_6.png" alt="buildzk_6"><br>这时候我们再使用<code>./zkServer.sh status</code>来查看状态如果出现下图,恭喜你搭建成功<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_7.png" alt="buildzk_7"><br>其中leader是主节点,follow是从节点。<br>但是大多数情况我们却出现<strong>It is probably not running</strong>。这时可以参考这篇<a href="http://blog.csdn.net/henni_719/article/details/53331724" target="_blank" rel="noopener">文章</a>去解决问题。</p>
<h2 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h2><p>首先感谢上文参考的所有文章！！<br>其次感谢这个开发的网络世界,让我们可以找到想找的所有资料！！！</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/buildzookeeper/">http://catalinali.top/2017/buildzookeeper/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解jdbcTemplate和namedParameterJdbcTemplate]]></title>
      <url>/2017/useJDBC/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_logo.jpg" alt="jdbcTemplate_logo"></p>
<blockquote>
<p>我们开发DAO层时用的最多的就是ORM框架(Mybatis,hibernate)了。在有些特殊的情况下,ORM框架的搭建略显笨重,这时最好的选择就是Spring中的jdbcTemplate了。本文对jdbcTemplate进行详解，并且会对具名参数namedParameterJdbcTemplate进行讲解。</p>
</blockquote>
<hr>
<a id="more"></a>
<h1 id="jdbcTemplate讲解"><a href="#jdbcTemplate讲解" class="headerlink" title="jdbcTemplate讲解"></a>jdbcTemplate讲解</h1><h3 id="jdbcTemplate提供的主要方法"><a href="#jdbcTemplate提供的主要方法" class="headerlink" title="jdbcTemplate提供的主要方法:"></a>jdbcTemplate提供的主要方法:</h3><ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h3 id="jdbcTemplate环境搭建"><a href="#jdbcTemplate环境搭建" class="headerlink" title="jdbcTemplate环境搭建:"></a>jdbcTemplate环境搭建:</h3><p>1 在spring配置文件中加上jdbcTemplate的bean:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注入jdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意:在这之前我们需要先配置好数据库数据源dateSource。<br>2.在使用jdbcTemplate类中使用@Autowired进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br></pre></td></tr></table></figure></p>
<h3 id="jdbcTemplate方法测试"><a href="#jdbcTemplate方法测试" class="headerlink" title="jdbcTemplate方法测试:"></a>jdbcTemplate方法测试:</h3><p>我们准备一个数据库<br><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_1.png" alt="jdbcTemplate_1"><br>准备数据库对应的实体pojo,实体的名称都要对应数据库的字段名称：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">            <span class="string">"id="</span> + id +</span><br><span class="line">            <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1.查询单个对象queryForObject:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select id,username,password from user where id=?"</span>;</span><br><span class="line"></span><br><span class="line">    BeanPropertyRowMapper&lt;User&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class);</span><br><span class="line">    User user = jdbcTemplate.queryForObject(sql, rowMapper,<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果: User{id=1, username=’123’, password=’123’}<br><strong>2.查询多个对象query:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMutiQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select id,username,password from user"</span>;</span><br><span class="line"></span><br><span class="line">    BeanPropertyRowMapper&lt;User&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class);</span><br><span class="line">    List&lt;User&gt; users = jdbcTemplate.query(sql, rowMapper);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果:<br>User{id=1, username=’123’, password=’123’}<br>User{id=2, username=’1234’, password=’1234’}<br><strong>3.查询count、avg、sum等函数返回唯一值:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCountQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select count(*) from user"</span>;</span><br><span class="line"></span><br><span class="line">    BeanPropertyRowMapper&lt;User&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class);</span><br><span class="line">    Integer result = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果:2<br><strong>4.增删改方法测试:</strong><br><strong>新增:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCreate()&#123;</span><br><span class="line">    String sql = &quot;insert into user (username,password) values (?,?)&quot;;</span><br><span class="line">    int create = jdbcTemplate.update(sql, new Object[]&#123;255, 255&#125;);</span><br><span class="line">    System.out.println(create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为1,去数据库查看也确实插入这条。<br><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_2.png" alt="jdbcTemplate_2"><br><strong>修改:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"update user set username=? , password=? where id=?"</span>;</span><br><span class="line">    <span class="keyword">int</span> update = jdbcTemplate.update(sql, <span class="keyword">new</span> Object[]&#123;<span class="number">256</span>, <span class="number">256</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为1,并且确实数据已经修改<br><strong>删除:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"delete from user where id=?"</span>;</span><br><span class="line">    <span class="keyword">int</span> delete = jdbcTemplate.update(sql, <span class="keyword">new</span> Object[]&#123;<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(delete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5.批量操作:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Object[]&gt; batchArgs=<span class="keyword">new</span> ArrayList&lt;Object[]&gt;();</span><br><span class="line">    batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="number">777</span>,<span class="number">888</span>&#125;);</span><br><span class="line">    batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="number">666</span>,<span class="number">888</span>&#125;);</span><br><span class="line">    batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="number">555</span>,<span class="number">888</span>&#125;);</span><br><span class="line">    String sql = <span class="string">"insert into user (username,password) values (?,?)"</span>;</span><br><span class="line">    jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上方法基本满足了日常我们多DAO层进行的操作,不过当你进行CRUD操作时如果传入的参数不确定,这时候你可能会想起ORM框架的便利。没关系！Spring也为我们提供了这样的操作NamedParameterJdbcTemplate。</p>
<h1 id="NamedParameterJdbcTemplate讲解"><a href="#NamedParameterJdbcTemplate讲解" class="headerlink" title="NamedParameterJdbcTemplate讲解"></a>NamedParameterJdbcTemplate讲解</h1><p>在经典的 JDBC 用法中, SQL 参数是用占位符 ? 表示,并且受到位置的限制. 定位参数的问题在于, 一旦参数的顺序发生变化, 就必须改变参数绑定.<br>在 Spring JDBC 框架中, 绑定 SQL 参数的另一种选择是使用具名参数(named parameter).<br><strong>那么什么是具名参数？</strong><br>具名参数: SQL 按名称(以冒号开头)而不是按位置进行指定. 具名参数更易于维护, 也提升了可读性. 具名参数由框架类在运行时用占位符取代<br>具名参数只在 NamedParameterJdbcTemplate 中得到支持。NamedParameterJdbcTemplate可以使用全部jdbcTemplate方法,除此之外,我们来看看使用它的具名参数案例:<br><strong>具名新增：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"insert into user (username,password) values (:username,:password)"</span>;</span><br><span class="line">    User u = <span class="keyword">new</span> User();</span><br><span class="line">    u.setUsername(<span class="string">"555"</span>);</span><br><span class="line">    SqlParameterSource sqlParameterSource=<span class="keyword">new</span> BeanPropertySqlParameterSource(u);</span><br><span class="line">    namedParameterJdbcTemplate.update(sql,sqlParameterSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看结果<br><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_3.png" alt="jdbcTemplate_3"><br>这样我们就可以根据pojo类的属性值使用JDBC来操作数据库了。<br><strong>获取新增的主键:</strong><br>NamedParameterJdbcTemplate还新增了KeyHolder类,使用它我们可以获得主键,类似Mybatis中的useGeneratedKeys。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKeyHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">     String sql = <span class="string">"insert into user (username,password) values (:username,:password)"</span>;</span><br><span class="line">     User u = <span class="keyword">new</span> User();</span><br><span class="line">     u.setUsername(<span class="string">"555"</span>);</span><br><span class="line">     SqlParameterSource sqlParameterSource=<span class="keyword">new</span> BeanPropertySqlParameterSource(u);</span><br><span class="line">     KeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder();</span><br><span class="line">     namedParameterJdbcTemplate.update(sql, sqlParameterSource, keyHolder);</span><br><span class="line">     <span class="keyword">int</span> k = keyHolder.getKey().intValue();</span><br><span class="line">     System.out.println(k);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果就是新增的主键。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cnblogs.com/caoyc/p/5630622.html" target="_blank" rel="noopener">Spring JdbcTemplate详解</a></li>
<li><a href="https://my.oschina.net/happyBKs/blog/497798" target="_blank" rel="noopener">Spring框架笔记（二十五）——NamedParameterJdbcTemplate与具名参数</a></li>
<li><a href="http://blog.csdn.net/qq_20545159/article/details/48287621" target="_blank" rel="noopener">使用Spring的NamedParameterJdbcTemplate完成DAO操作</a></li>
</ul>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/useJDBC/">http://catalinali.top/2017/useJDBC/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> jdbcTemplate </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jdbcTemplate </tag>
            
            <tag> namedParameterJdbcTemplate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring中的ApplicationContextAware接口的使用]]></title>
      <url>/2017/UseApplicationContextAware/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/appContext_logo.jpg" alt="appContext_logo"></p>
<blockquote>
<p>最近在看项目代码时发现一个类在项目各个地方都能进行调用,仔细研究后发现这个类实现了ApplicationContextAware这个接口,这个接口可以很方便的获取到Spring的上下文applicationContext。现在就跟我来一起看看如何使用吧。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>我们先新建一个测试类AppCache,在这个类中我定义了一个静态的DictService属性。而DictService类我也提前写好了,里面只输出了一句话用作测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: 测试ApplicationContextAware接口</span></span><br><span class="line"><span class="comment"> * Copyright:   Copyright (c)2017</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DictServiceImpl</span> <span class="keyword">implements</span> <span class="title">DictService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello ApplicationContextAware"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用测试类AppCache实现这个接口,填写它的setApplicationContext方法。Spring容器在加载的时候会调用一次setApplicationContext,并将上下文ApplicationContext传递给这个方法。我们拿到上下文后就可以做很多事情了。这里我使用它来获取了DictService这个bean。然后创建了一个静态的sayHello测试方法调用了DictService中的sayHello。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: 测试ApplicationContextAware接口</span></span><br><span class="line"><span class="comment"> * Copyright:   Copyright (c)2017</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCache</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DictService dictService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        dictService = applicationContext.getBean(DictService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dictService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要把测试类AppCache注入到Spring容器中,在Spring的配置文件中添加测试类的bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--继承ApplicationContextAware接口的类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"appController"</span> <span class="attr">class</span>=<span class="string">"top.catalinali.controller.AppCache"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们新建一个Junit测试类,来调用自己定义的AppCache中的方法sayHello。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: 测试ApplicationContextAware接口</span></span><br><span class="line"><span class="comment"> * Copyright:   Copyright (c)2017</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestApp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AppCache.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/appContext_1.png" alt="appContext_1"><br>可以看到我们成功输出了Hello ApplicationContextAware这句话。用这样的方法,我们就可以在项目的各个位置来调用AppCache中的方法。除此之外我们也可以使用上下文进行一些别的事情,大家就可以自由发挥啦！</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实我们进入ApplicationContextAware接口内部可以看到他只有一个抽象的setApplicationContext方法,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且他又继承了一个Aware接口。而且这个接口是空的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="这就很有意思了-具体原因就留给大家来讨论吧。"><a href="#这就很有意思了-具体原因就留给大家来讨论吧。" class="headerlink" title="这就很有意思了,具体原因就留给大家来讨论吧。"></a>这就很有意思了,具体原因就留给大家来讨论吧。</h2><blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/UseApplicationContextAware/">http://catalinali.top/2017/UseApplicationContextAware/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7下破解安装JIRA 7.2]]></title>
      <url>/2017/installjira/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_1.jpg" alt="hello_jira"></p>
<blockquote>
<p>JIRA是Atlassian公司出品的项目与事务跟踪工具,是一款Code Review利器。实习的时候帮公司安装了一下jira，发现网上的资料参差不齐，现在抽空把搭建的过程一步步记录下来。有兴趣的朋友可以参考下。</p>
</blockquote>
<hr>
<a id="more"></a>
<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><ul>
<li><p><strong>jdk的搭建</strong><br>jira 7.2的运行需要jdk1.8的依赖，首先去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">oracle官网</a>下载linux版本的jdk，然后我们开始进行安装。</p>
<ol>
<li>找到一个目录解压jdk:<code>tar -zxvf jdk-8u144-linux-i586.tar.gz</code><br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_01.png" alt="hellojira_01"></li>
<li>在usr下创建一个目录,然后将解压的文件放进去:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/java</span><br><span class="line">mv  jdk1.8.0_102 /usr/java/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>配置环境变量,<code>vim /etc/profile</code>,然后在最后面加入下列代码:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_102/</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>4.更新profile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_2.png" alt="hellojira_2"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p> 如果是给公司安装的话,你可能会发现服务器上不止一个版本的jdk,而且<em>/etc/profile</em>下的环境变量也不是1.8的，这时候该怎么办呢？<br>你可以在jira的运行目录下找到程序启动的<strong>.sh</strong>文件,使用vim编辑器在此文件的最上方添加你要使用的jdk的环境变量,让其从这个路径下寻找jdk。</p>
<ul>
<li>数据库mysql的搭建<br>我使用的是<em>centos7</em>,好多配置跟之前的不太一样。也踩了不少坑,这里就简单说一下我的安装过程吧。<br>首先我使用网上大多数人的答案:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql</span><br><span class="line">yum install mysql-server</span><br><span class="line">yum install mysql-devel</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果发现安装上的压根不是mysql,而是一个mariadb的鬼玩意。于是我去查资料发现centos7的默认数据库由mysql改为了mariadb。于是我又查了各种资料进行mysql的安装,简单说一下步骤:</p>
<p><strong>1.首先下载mysql的repo源</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>2.安装mysql-community-release-el7-5.noarch.rpm包</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>3.安装mysql</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
<p>这样mysql就安装好了,不过这是centos7下的方法,如果大家用的别的环境就不适用了。<br><strong>4.mysql安装好后是没有密码的,我们需要登录mysql然后设置密码:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">use mysql;</span><br><span class="line">update user set password=password(‘123456‘) where user=‘root‘;</span><br></pre></td></tr></table></figure>
<p><strong>5.设置远程连接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;          #使用&apos;mysql&apos;这个数据库</span><br><span class="line">Grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123456&apos; with grant option;   #赋权限</span><br><span class="line">flush privileges;   #刷新权限</span><br></pre></td></tr></table></figure>
<p>这时候我们使用这个账号就可以远程访问了,比如使用桌面的sqlyog进行连接。如果连接不上有可能是3306端口没有放开,下面说一下centos7下的开放端口的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state #查看运行状态</span><br><span class="line">firewall-cmd --add-port=3306/tcp --permanent #开放3306端口</span><br><span class="line">firewall-cmd --reload #生效刚才的端口设置</span><br></pre></td></tr></table></figure>
<p><strong>6.创建一个jira使用的mysql账号</strong><br>回到正题,mysql已经安装好了。现在我们来为jira创建一个mysql用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &apos;jira&apos;@&apos;%&apos; IDENTIFIED BY &apos;jira&apos;;</span><br></pre></td></tr></table></figure>
<p>创建一个jira数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database jira default character set utf8 collate utf8_bin;</span><br></pre></td></tr></table></figure>
<p>给jira用户赋权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT all on jiradb.* to &apos;jira&apos;@&apos;%&apos; identified by &apos;jira&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>这时候我们可以使用<code>show grants for jira@localhost;</code>来查看一下权限。</p>
<h1 id="二、破解安装jira"><a href="#二、破解安装jira" class="headerlink" title="二、破解安装jira"></a>二、破解安装jira</h1><p>这时候我们就可以安装并破解jira了<br><strong>1.下载linux版本的jira</strong><br>首先去<a href="https://www.atlassian.com/software/jira/download" target="_blank" rel="noopener">官网</a>下载linux版本的jira<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_03.png" alt="hellojira_03"><br>并且把破解包下载下来链接：<a href="http://pan.baidu.com/s/1bMfksQ" target="_blank" rel="noopener">http://pan.baidu.com/s/1bMfksQ</a> 密码：lsc7<br><strong>2.开始安装jira</strong><br>将安装包放入linux随意一个目录下后,使用如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> chmod 755 atlassian-jira-software-7.4.2-x64.bin #修改权限</span><br><span class="line"></span><br><span class="line">./atlassian-jira-software-7.4.2-x64.bin</span><br></pre></td></tr></table></figure>
<p>安装过程有一些选项,如果选不对就会出现下图情景,我们可以看到jira安装的端口是8080,安装的路径是/opt/atlassian/jira和/var/atlassian/application-data/jira目录下:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_04.png" alt="hellojira_04.png"><br>因为8080端口比较常用,所以我们把他更换一下:<code>vim /opt/atlassian/jira/conf/server.xml</code><br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_4.png" alt="hellojira_4.png"><br>这里我把红框中的端口改为了8090<br><strong>3.破解jira</strong><br>解压破解包,找到一下两个文件:</p>
<pre><code>atlassian-extras-3.1.2.jar    #jira破解文件
mysql-connector-java-5.1.39-bin.jar   #mysql驱动
</code></pre><p>和两个文件复制到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下。这时候需要注意,jira破解文件是需要替换里面的原文件,但由于他的版本比较旧,所以就需要大家先找到原本目录下的atlassian-extras-3.x.jar文件。将它删除,然后把我们的破解文件换成它的名字。<br><strong>4.启动jira</strong><br>进入/opt/atlassian/jira/bin目录下运行<em>start-jira.sh</em><br>打开桌面上的浏览器,访问<a href="http://localhost:8090" target="_blank" rel="noopener">http://localhost:8090</a>。就可以看到启动画面,如果不能访问,尝试用上面的方法放开一下8090端口:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_6.png" alt="hellojira_6"><br>点击continue后开始选择配置数据库:<br>输入正确的数据库信息后可以先test一下,如果test成功的话,执行下一步会jira会自动的向数据库中创建表。<br>这里需要注意的就是Mode选项。private是只有管理员可以注册账号，public是用户可以自己注册。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_10.png" alt="hellojira_10"><br>下面的步骤需要获取license:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_11.png" alt="hellojira_11"><br>需要我们去官网注册一个账号来获取license:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_13.png" alt="hellojira_13"><br>确定后会自动跳转回来:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_14.png" alt="hellojira_14"><br>之后就简单多了:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_15.png" alt="hellojira_14"><br>点击<em>Next</em><br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_16.png" alt="hellojira_14"><br>选择<em>Finish</em>,之后选择一些语言就好了:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_17.png" alt="hellojira_14"></p>
<p>jira到这里就算是安装完成了,看着步骤多其实没有什么难点。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.ilanni.com/?p=12119" target="_blank" rel="noopener">烂泥：jira7.2安装、中文及破解</a></li>
<li><a href="http://10551335.blog.51cto.com/10541335/1749945" target="_blank" rel="noopener">Centos 6.7下 jira7.1.1+confluence5.96+mysql结合（破解）</a></li>
<li><a href="http://blog.csdn.net/dunhanson/article/details/52997803" target="_blank" rel="noopener">CentOS yum 安装、卸载MariaDB数据库</a></li>
<li><a href="http://www.cnblogs.com/julyme/p/5969626.html" target="_blank" rel="noopener">centos7下使用yum安装mysql</a></li>
<li><a href="http://blog.csdn.net/sodino/article/details/52356472" target="_blank" rel="noopener">【Linux】CentOS 7通过Firewall开放防火墙端口</a></li>
</ul>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/installjira/">http://catalinali.top/2017/installjira/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> jira </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jira </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记录：使用IDEA搭建Maven+SSM的过程]]></title>
      <url>/2017/IDEABuildSSM/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_15.jpg" alt="hellossm_15"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>IntelliJ IDEA被认为是当前 Java 开发效率最快的 IDE 工具。份额已经逐渐超越Eclipse。一直使用Eclipse的我也不禁想尝尝鲜，之前简单的使用它搭建了一下SSM环境，现在把他记录下来。</p>
</blockquote>
<a id="more"></a>
<h1 id="新建一个Maven项目"><a href="#新建一个Maven项目" class="headerlink" title="新建一个Maven项目"></a>新建一个Maven项目</h1><p>打开IDEA,选择新建一个项目<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_1.png" alt="hellossm_1"><br>如图:首先我们选择一个maven Project,然后要创建模板勾选Create from archetype。由于我们准备新建一个web工程所以选择maven-archetype-webapp。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_2.png" alt="hellossm_2"><br>下一步:填写GroupId,ArtifactId。填写的标准就不用多说了吧。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_3.png" alt="hellossm_3"><br>下一步:选择使用的maven的本地位置,这个根据实际情况选择就好。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_4.png" alt="hellossm_4"><br>下一步:这一步会填写项目名称,根据实际来就好了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_5.png" alt="hellossm_5"><br>然后点击Finish,一个空的web工程就建好了。</p>
<h1 id="搭建SSM环境"><a href="#搭建SSM环境" class="headerlink" title="搭建SSM环境"></a>搭建SSM环境</h1><p><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_6.png" alt="hellossm_6"><br>IDEA里的java文件只能在Source Boot类型的文件夹下创建,所以我们要新建一个文件夹，然后将它的类型改为Source Boot:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_7.png" alt="hellossm_7"><br>这时候我们就可以新建需要的类了。ssm的配置还是那老一套，由于篇幅问题这里就不贴出来了。配置完的大体结构是这样的。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_8.png" alt="hellossm_8"></p>
<h1 id="运行web工程"><a href="#运行web工程" class="headerlink" title="运行web工程"></a>运行web工程</h1><p>选择如图位置：<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_9.png" alt="hellossm_9"><br>然后选择如图:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_10.png" alt="hellossm_10"><br>这里主要选择本地tomcat的位置<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_11.png" alt="hellossm_11"><br>然后我们切换到第二栏Deployment:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_12.png" alt="hellossm_12"><br>选择如图的选项,注意这里一定要选择带exploded的这个:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_13.png" alt="hellossm_13"><br>选择OK，然后install–&gt;运行tomcat。如果出现如图，则表示成功:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_14.png" alt="hellossm_14"></p>
<h1 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h1><p>IntelliJ IDEA现在已经被基本被认为是当前 Java 开发效率最快的 IDE 工具。对于用惯了Eclipse的我来说显然快要跟不上时代了,这篇文章只是简单的记录了一下搭建的过程,目的是快速熟悉一下IDEA的运行方式。然而关于SSM配置内容却只字未提。一个是因为关于SSM整合的文章现在网上多的是,大家只要一搜就好了。再一个是因为配置都是一大段一大段的,全部粘上来未免太占篇幅。<br>最后贴一个IDEA的<a href="https://youmeek.gitbooks.io/intellij-idea-tutorial/content/" target="_blank" rel="noopener">教程</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/IDEABuildSSM/">http://catalinali.top/2017/IDEABuildSSM/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SSM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SSM </tag>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo骚操作：主题配置|搜索|评论|SEO|统计|图床]]></title>
      <url>/2017/secondBuildHexo/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/front-pic2.jpg" alt="front-pic2"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>相信各位在看过上一篇blog<a href="http://catalinali.top/2017/firstBuildHexo/">手把手教你使用hexo搭建属于你的个人博客</a>后已经初步搭建了属于自己的博客，不过细心的你可能已经发现这样的博客还是缺点什么，现在就来说说Hexo的骚操作:添加主题、统计、评论、SEO等等等等。</p>
</blockquote>
<hr>
<a id="more"></a>
<p>承接上篇最后说过的:根目录下的<code>_config.yml</code>叫做<strong>站点配置文件</strong>，主题下文件夹的<code>_config.yml</code>叫做<strong>主题配置文件</strong>。好了,现在进入正题，今天我们要对Hexo进行一些脱胎换骨的操作，让你从内到外了解Hexo，要完成的操作如下：</p>
<ul>
<li>添加个性化主题</li>
<li>在github保存Hexo</li>
<li>添加评论系统</li>
<li>添加搜索与统计</li>
<li>添加图床</li>
</ul>
<h2 id="一、添加个性化主题"><a href="#一、添加个性化主题" class="headerlink" title="一、添加个性化主题"></a>一、添加个性化主题</h2><p>Hexo默认的主题可能满足不了你的胃口，我们这里选择换一个更加个性化的主题，首先先去挑一个你心仪的主题:<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">传送门</a>。大家也可以自行寻找一些主题。这里使用人气最高的Next主题为例：<br><strong>1.安装主题</strong><br>打开<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">github下载地址</a>，clone下载地址<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_1.png" alt="buildHexo2_1"><br>进入你的Hexo根目录右键选择Git Bash Here,在命令行中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure></p>
<p>这时在我们的<code>theme</code>文件夹下就会有一个名next的主题文件夹。<br><strong>2.配置主题</strong><br>进入<strong>站点配置文件</strong>,找到theme选项，后面填写你要使用的主题名字。这里再次强调一下,_config.yml使用的是<code>YAML</code>语法。选项后面要先加一个空格才能填值，遇到无法解决的问题不妨对格式进行<a href="http://www.yamllint.com/" target="_blank" rel="noopener">校验</a>。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_2.png" alt="buildHexo2_2"><br>这时候就可以使用调试模式来查看一下主题了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清除缓存</span><br><span class="line">hexo g #自动生成静态页面,hexo generate的缩写</span><br><span class="line">hexo s --debug #调试模式,在浏览器进入http://localhost:4000/进行访问</span><br></pre></td></tr></table></figure></p>
<p>发现没有什么问题就可以使用<code>hexo d</code>进行发布了,Next主题有他的<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a>,一些基本的设置都可以在上面找的，这里就不赘述了。</p>
<h2 id="二、在github保存Hexo"><a href="#二、在github保存Hexo" class="headerlink" title="二、在github保存Hexo"></a>二、在github保存Hexo</h2><p>当你慢慢了解Hexo以后，不知你是否会有这样的想法:当我换了一台电脑，我该怎样继续更新的我blog。查阅了众多资料后找到了我心中答案:<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">传送门</a>。我们要用的就是知乎中1楼的这个高亮答案。过程他已经说的很清楚了，但是这里我要说几个我遇到的坑:</p>
<ul>
<li>在明白了答主的步骤后，我们发现刚才的主题是用git拉下来的,那么Next主题文件夹下就会有一个<strong>.git</strong>的隐藏文件夹,这个文件会影响我们对博客文件的提交，所以我们要首要的一步是删除Next文件夹下隐藏的<strong>.git</strong>文件夹</li>
<li>这篇文章楼下答主<a href="https://www.zhihu.com/people/KOKO-55/answers" target="_blank" rel="noopener"><strong>KOKO</strong></a>所说的内容。在我们拉下来仓库以后会生成一个.git文件夹。这个文件夹记录了我们所对应github的分支。然而在进行了hexo命令操作以后会覆盖这个.git文件夹。所以应该提前将这个文件夹备份一下,然后回过头来进行覆盖。</li>
</ul>
<h2 id="三、为Hexo添加评论系统"><a href="#三、为Hexo添加评论系统" class="headerlink" title="三、为Hexo添加评论系统"></a>三、为Hexo添加评论系统</h2><p>官方文档里推荐了好多个评论系统,一路用过来发现DISQUS被墙了,网易云跟帖跟多说关闭服务了。现在还比较好用的就剩下来必力跟畅言了,并且我们选择的Next昨天还很贴心的集成了这两个评论系统。</p>
<ul>
<li>添加来必力<br>1.注册<a href="https://livere.com/" target="_blank" rel="noopener">来必力</a>,注册过程中可能会冒出一些棒子语言，让我们使用直觉注册好后点击我的页面–&gt;代码管理–&gt;data-uid<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_3.png" alt="buildHexo2_3"><br>2.复制我们的这个id,粘贴到主题配置文件<code>livere_uid</code>选项后面<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_4.png" alt="buildHexo2_4"><br>这时你再重新部署你的Hexo,是不是已经有了来必力评论系统</li>
<li>添加畅言<br>畅言的UI感觉比来必力清爽一些，但是注册的过程需要ICP备案号,这个比较麻烦<br>1.注册<a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言</a>,进入账户管理–&gt;后台总览–&gt;畅言秘钥<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_5.png" alt="buildHexo2_5"><br>2.复制畅言秘钥，粘贴到主题配置文件<code>changyan</code>后面<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_6.png" alt="buildHexo2_6"></li>
</ul>
<h2 id="四、为Hexo搜索与统计"><a href="#四、为Hexo搜索与统计" class="headerlink" title="四、为Hexo搜索与统计"></a>四、为Hexo搜索与统计</h2><p>搜索与统计都比较简单，<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">官方文档</a>有详尽的明细,统计推荐不蒜子，简单粗暴。<br>搜索的话我使用的是本地搜索，即Local Search。他的原理是在你本地生成一个xml文件,搜索的时候对这个文件进行检索。下面说说安装步骤<br>1.执行下面2个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p>
<p>2.打开站点配置文件，新增以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<p>3.打开主题配置文件，启用本地搜索功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p>
<h2 id="五、为Hexo添加图床"><a href="#五、为Hexo添加图床" class="headerlink" title="五、为Hexo添加图床"></a>五、为Hexo添加图床</h2><p>以后写博客避免不了常常使用图片,可是Github Pages是有容量限制的,总不能全部都作为静态文件进行上传吧。这里推荐一个好评的<a href="https://portal.qiniu.com/signup?code=3letjvek8jgia" target="_blank" rel="noopener">七牛云</a>图床。七牛云不是免费的，但每个用户有10GB免费存储，每月10GB免费下载流量,对于博客使用来说够了。使用方法:<br>1.打开链接并注册,单机 对象存储–&gt;创建空间。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_7.png" alt="buildHexo2_7"><br>2.当我们使用图片时。需要先上传到七牛,然后复制外链,之后就可以在MarkDown文章中使用了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_8.png" alt="buildHexo2_8"><br>3.每次这样获取图片链接,相信你一定会很烦的。这里有一个针对七牛的小工具<a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">Mpic</a>。简化了这一步骤,相信你一定会爱上他的。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/secondBuildHexo/">http://catalinali.top/2017/secondBuildHexo/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你使用hexo搭建属于你的个人博客]]></title>
      <url>/2017/firstBuildHexo/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/front-pic1.jpg" alt="front-pic-1"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>   每当看到别人精美的个人博客时，不知你是否有一点点的羡慕。别急，现在我就来手把手教你搭建自己的个人博客。<br>    在技术日趋成熟的今天，有着很多种快速生成博客的框架:Hexo,Jekyll,Wordpress等等。今天我们就用<code>Hexo</code>来带着大家完成自己的博客 </p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo?"></a>什么是Hexo?</h2><p>Hexo<a href="https://hexo.io/" target="_blank" rel="noopener">官网</a>中说是这么描述的：<strong>A fast, simple &amp; powerful blog framework</strong>,即:一个快速、简单且强大的博客快速生产工具。它的简单体现在你完全有可能在30分钟内就生成属于你的个人博客。而它的强大体现在你对细节的调整上完全有可能花上一天的时间。</p>
<h2 id="一、巧妇难为无米之炊-准备搭建环境"><a href="#一、巧妇难为无米之炊-准备搭建环境" class="headerlink" title="一、巧妇难为无米之炊:准备搭建环境"></a>一、巧妇难为无米之炊:准备搭建环境</h2><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><p>Node.js 的实质是一个JavaScript运行环境,这里我们主要使用它来生成我们博客的静态页面。从<a href="http://nodejs.cn/" target="_blank" rel="noopener">官网</a>下载最新的安装包进行默认安装就好。安装过程略。</p>
<h3 id="2-安装git环境"><a href="#2-安装git环境" class="headerlink" title="2.安装git环境"></a>2.安装git环境</h3><p>git是最流行的分布式版本控制系统，我们使用它主要是与github进行交互。安装<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">git</a>使用默认选项安装即可，安装过程略。如果你还对git不是特别熟悉，推荐一个学习git的教程:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">传送门</a></p>
<h3 id="3-注册github"><a href="#3-注册github" class="headerlink" title="3.注册github"></a>3.注册github</h3><p><a href="https://github.com/" target="_blank" rel="noopener">github</a>就不用说了吧，它是一个面向开源及私有软件项目的托管平台。几乎所有的程序员都听说过它的大名。就正常注册一个账号就好了。<br>注册号以后首先给我们的账号添加本机的SSH，具体方法及原因在<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="noopener">这篇文章</a>已经有了详细说明，并且方法也很简单</p>
<h2 id="二、上正菜：开始搭建博客"><a href="#二、上正菜：开始搭建博客" class="headerlink" title="二、上正菜：开始搭建博客"></a>二、上正菜：开始搭建博客</h2><p>环境都准备好后，我们就可以开始安装博客了:<br><strong>1.创建文件夹</strong><br>    在本地新建一个文件夹用于存放我们的博客，并且右键菜单选择Git Bash Here,然后在Git Bash里输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure></p>
<p>然后回车，如图：</p>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_1.png" alt="buildHexo_1"><br>我在执行这个的时候出现了下图的警告,但是并不影响我们的安装，不用理会它。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_5.png" alt="buildHexo_5"><br>如果没有输出err之类的错误并且目录下多了一个node_modules文件夹，那这步就算成功了<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_6.png" alt="buildHexo_6"></p>
<p><strong>2.执行hexo命令</strong><br>依次执行以下3个命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init  --初始化hexo环境,这时会在目录下自动生成hexo的文件</span><br><span class="line">npm install --安装npm依赖包</span><br><span class="line">hexo generate --生成静态页面</span><br><span class="line">hexo server --生成本地服务</span><br></pre></td></tr></table></figure></p>
<p>好了，这时候我们打开浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>看看可不可以访问。如果默认的hexo博客出现，那么恭喜你，你已经搭建好了自己的博客，接下来我们就要将它发布到网上。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_11.png" alt="buildHexo_11"><br><strong>3.可能遇到的报错</strong>:</p>
<ul>
<li><p><strong>日志报错</strong><br>这个报错一般是由于在命令执行中用户使用Ctrl+C强制中断了命令的执行，导致log中记录已经执行，但实际没有执行完成。解决办法:删除图中路径下的.log文件<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_7.png" alt="buildHexo_7"></p>
</li>
<li><p><strong>在非空文件夹下执行<code>hexo init</code>命令</strong><br><code>hexo init</code>这个命令是自动生成hexo目录时使用的命令，使用他有一个前提是必须是空文件夹，如果出现了这个错误，把所有文件删除就行。如果还是报错，别着急，看看是不是有隐藏文件没有删除。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_8.png" alt="buildHexo_8"></p>
</li>
<li><p><strong>hexo命令未找到</strong><br>有的同学可能会出现在执行hexo命令时出现<code>conmand not found</code>的提示，这是由于hexo没有配到环境变量中，只需要手动配置一下就好了，这里演示一下win7的配置方式，其他系统也差不多，自行<a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a>就好:<br>1.找到并进入根目录下<strong>node_modules</strong>文件夹,这时我们发现里面有很多文件夹，找到<code>hexo</code>文件夹,这里我们可以看到一个<code>bin</code>文件夹，进到<code>bin</code>目录下，复制当前路径:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_9.png" alt="buildHexo_9"><br>2.右键我的电脑–&gt;高级系统设置–&gt;高级–&gt;环境变量。在系统变量那栏找到Path并双击这行,在弹出的<code>编辑系统变量</code>这栏的变量值的<strong>最后</strong>先输入一个分号<code>；</code>表示与前一个变量隔开,然后再把刚才复制的hexo路径添加到分号后面。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_10.png" alt="buildHexo_10"></p>
</li>
</ul>
<h2 id="三、万事具备，只欠东风：将本地博客发布到网络上"><a href="#三、万事具备，只欠东风：将本地博客发布到网络上" class="headerlink" title="三、万事具备，只欠东风：将本地博客发布到网络上"></a>三、万事具备，只欠东风：将本地博客发布到网络上</h2><p>这时候就要用到了我们的github：<br><strong>1.创建远程仓库</strong><br>新建一个跟自己账号<strong>名字</strong>一样的空仓库，如图：<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_2.png" alt="buildHexo_2"><br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_3.png" alt="buildHexo_3"><br><strong>2.连接本地与远程github仓库</strong><br>打开本地博客的文件夹，打开<strong>_config.yml</strong>进行编辑<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_4.png" alt="buildHexo_4"><br>翻到文件最下方，将deploy的选项改成以下的形式，并将yournmae修改为你自己的名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p>
<p>然后在GitBash中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>这时候，我们再最后执行一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>就可以在浏览器中访问<a href="http://yourname.github.io/来进入你的博客啦" target="_blank" rel="noopener">http://yourname.github.io/来进入你的博客啦</a><br>大功告成！！</p>
<h2 id="四、一鼓作气：详细了解Hexo"><a href="#四、一鼓作气：详细了解Hexo" class="headerlink" title="四、一鼓作气：详细了解Hexo"></a>四、一鼓作气：详细了解Hexo</h2><p>博客已经可以访问了，但我相信大家对Hexo还是一头雾水，现在我们来深入学习一下Hexo:<br><strong>1.Hexo的基本命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo generate --生成个人博客所需的静态页面</span><br><span class="line">hexo server --本地预览</span><br><span class="line">hexo deploy --部署我们的个人博客</span><br><span class="line">hexo clean --清除缓存</span><br></pre></td></tr></table></figure></p>
<p>这几个命令都能用首字母缩写完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g --generate </span><br><span class="line">hexo s --server </span><br><span class="line">hexo d --deploy</span><br></pre></td></tr></table></figure></p>
<p><strong>2.写文章的需要用到下面的命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; --新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; --新建页面</span><br></pre></td></tr></table></figure></p>
<p>编辑我们的博客的时候可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></p>
<p>然后访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>来进入调试模式，更改了配置或文章后随时刷新页面来查看效果。<br>Hexo的文章支持的是<code>MarkDown</code>语法。网上有很多资料，这里提供一个<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">传送门</a>。</p>
<p><strong>3.我们每次部署的步骤是</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>后两步可以简写为<code>hexo g -d</code>，另外我们也可以使用<code>hexo help</code>来查看hexo命令帮助</p>
<p><strong>4.目录结构说明</strong><br>hexo init 出来的文件各自的作用如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`-----------</span><br><span class="line">|  +-- .deploy       #hexo deploy生成的文件</span><br><span class="line">|  +-- node_modules  #npm组件</span><br><span class="line">|  +-- public        #生成的静态网页文件</span><br><span class="line">|  +--scaffolds      #模板</span><br><span class="line">|  +-- source        #博客正文和其他源文件</span><br><span class="line">|  |   +-- _posts    #我们自己写的文章以md结尾</span><br><span class="line">|  +-- themes        #主题</span><br><span class="line">|  +-- _config.yml   #全局配置文件</span><br><span class="line">|  `-- package.json  #定义了hexo所需要的各种模块</span><br></pre></td></tr></table></figure></p>
<p><strong>5.配置文件</strong><br>搭建好博客后，我们的各种细节配置基本都是在配置文件中完成的，Hexo中的配置文件一共分2中，在文件夹跟目录下的<code>_config.yml</code>叫做<strong>站点配置文件</strong>,同样的文件名我们可以在<code>theme</code>文件夹下的主题文件夹里面也找的。而主题文件夹下的<code>_config.yml</code>叫做主题配置文件。这里说明一下站点配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site #站点信息</span><br><span class="line">title:  #标题</span><br><span class="line">subtitle:  #副标题</span><br><span class="line">description:  #站点描述，给搜索引擎看的</span><br><span class="line">author:  #作者</span><br><span class="line">email:  #电子邮箱</span><br><span class="line">language: zh-CN #语言</span><br><span class="line"># URL #链接格式</span><br><span class="line">url:  #网址</span><br><span class="line">root: / #根目录</span><br><span class="line">permalink: :year/:month/:day/:title/ #文章的链接格式</span><br><span class="line">tag_dir: tags #标签目录</span><br><span class="line">archive_dir: archives #存档目录</span><br><span class="line">category_dir: categories #分类目录</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">permalink_defaults:</span><br><span class="line"># Directory #目录</span><br><span class="line">source_dir: source #源文件目录</span><br><span class="line">public_dir: public #生成的网页文件目录</span><br><span class="line"># Writing #写作</span><br><span class="line">new_post_name: :title.md #新文章标题</span><br><span class="line">default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</span><br><span class="line">titlecase: false #标题转换成大写</span><br><span class="line">external_link: true #在新选项卡中打开连接</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">highlight: #语法高亮</span><br><span class="line">  enable: true #是否启用</span><br><span class="line">  line_number: true #显示行号</span><br><span class="line">  tab_replace:</span><br><span class="line"># Category &amp; Tag #分类和标签</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"># Archives</span><br><span class="line">2: 开启分页</span><br><span class="line">1: 禁用分页</span><br><span class="line">0: 全部禁用</span><br><span class="line">archive: 2</span><br><span class="line">category: 2</span><br><span class="line">tag: 2</span><br><span class="line"># Server #本地服务器</span><br><span class="line">port: 4000 #端口号</span><br><span class="line">server_ip: localhost #IP 地址</span><br><span class="line">logger: false</span><br><span class="line">logger_format: dev</span><br><span class="line"># Date / Time format #日期时间格式</span><br><span class="line">date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"># Pagination #分页</span><br><span class="line">per_page: 10 #每页文章数，设置成 0 禁用分页</span><br><span class="line">pagination_dir: page</span><br><span class="line"># Disqus #Disqus评论，替换为多说</span><br><span class="line">disqus_shortname:</span><br><span class="line"># Extensions #拓展插件</span><br><span class="line">theme: landscape-plus #主题</span><br><span class="line">exclude_generator:</span><br><span class="line">plugins: #插件，例如生成 RSS 和站点地图的</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"># Deployment #部署，将 lmintlcx 改成用户名</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: github创库地址.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>有时候我们部署了以后自己博客的链接打不开,查看生成的静态文件也没有index.html,或者是各种奇怪的报错。这时候有可能是我们的站点配置文件<code>_config.yml</code>格式出现了问题。这时候不妨去一些YAML格式检测网站去检测一下格式是否正确:<a href="http://www.yamllint.com/" target="_blank" rel="noopener">传送门</a>。</p>
<h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>完成上面的操作,你就已经一只脚踏进了<code>hexo</code>的大门,这时的你肯定还有很多疑问,比如博客的头像怎么更换，博客的主题怎么配置等等等等。这里先留下一个悬念,有兴趣的同学可以先行查询一些资料^_^</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/firstBuildHexo/">http://catalinali.top/2017/firstBuildHexo/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
