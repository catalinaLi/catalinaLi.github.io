<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[解析Vue.js的MVVM模式]]></title>
      <url>/2018/getMVVM/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/getMVVM_logo.png" alt="getMVVM_logo"></p>
<blockquote>
<p>近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="一、MVP模式"><a href="#一、MVP模式" class="headerlink" title="一、MVP模式"></a>一、MVP模式</h2><p>我们以前使用JQuery操作Dom的模式就是遵循了MVP模式,我们先来看一下MVP模式的图示：</p>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/getMVVM_1.png" alt="getMVVM_1"></p>
<ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Presenter）：业务逻辑</li>
<li>模型（Model）：数据保存</li>
</ul>
<p>MVP有以下特点：</p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<p>在我们常规的DOM操作中，Model层的数据一般通过AJAX获取，Presenter层通常就是我们的js逻辑而相应的View就是我们用户看到的界面。</p>
<h2 id="二、MVVM模式"><a href="#二、MVVM模式" class="headerlink" title="二、MVVM模式"></a>二、MVVM模式</h2><p>MVVM是Model-View-ViewModel的简写。它本质上就是MVP的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。</p>
<p>我们先来看一下图示：</p>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/getMVVM_2.png" alt="getMVVM_2"></p>
<p>它与MVP的区别在于它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Vue.js 正是采用了这种模式：</p>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/getMVVM_3.png" alt="getMVVM_3"><br>Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对比较轻量级的JS 库，API 简洁，很容易上手。</p>
<p>小伙伴们，快来试试Vue.js吧！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/getMVVM/">http://catalinali.top/2018/getMVVM/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[（转载）Java设计模式之代理模式]]></title>
      <url>/2018/proxyPattern/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/proxyPattern_logo.jpg" alt="volatile_logo"></p>
<blockquote>
<p>设计模式是语言的表达方式，它能让语言轻便而富有内涵、易读却功能强大。代理模式在Java中十分常见，有为扩展某些类的功能而使用静态代理，也有如Spring实现AOP而使用动态代理，更有RPC实现中使用的调用端调用的代理服务。代理模型除了是一种设计模式之外，它更是一种思维，所以探讨并深入理解这种模型是非常有必要的。</p>
</blockquote>
<a id="more"></a>
<p>本文转载自</p>
<ul>
<li><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">Java的三种代理模式</a></li>
<li><p><a href="https://blog.csdn.net/minidrupal/article/details/28588507" target="_blank" rel="noopener">浅析JAVA设计模式之代理模式(七)</a></p>
<p> 代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。</p>
<p> 代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象</p>
<p> 代理的实现可以分为静态代理和动态代理，动态代理又分为JDK动态代理和CGlib动态代理，下面我们依次来说明一下这三种方式：</p>
</li>
</ul>
<h2 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h2><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.</p>
<p>下面举个案例来解释:<br>模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.<br>需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法.<br>代码示例:<br>接口:IUserDao.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口</span><br><span class="line"> */</span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line"></span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目标对象:UserDao.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口实现</span><br><span class="line"> * 目标对象</span><br><span class="line"> */</span><br><span class="line">public class UserDao implements IUserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;----已经保存数据!----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理对象:UserDaoProxy.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代理对象,静态代理</span><br><span class="line"> */</span><br><span class="line">public class UserDaoProxy implements IUserDao&#123;</span><br><span class="line">    //接收保存目标对象</span><br><span class="line">    private IUserDao target;</span><br><span class="line">    public UserDaoProxy(IUserDao target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;开始事务...&quot;);</span><br><span class="line">        target.save();//执行目标对象的方法</span><br><span class="line">        System.out.println(&quot;提交事务...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类:App.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //目标对象</span><br><span class="line">        UserDao target = new UserDao();</span><br><span class="line"></span><br><span class="line">        //代理对象,把目标对象传给代理对象,建立代理关系</span><br><span class="line">        UserDaoProxy proxy = new UserDaoProxy(target);</span><br><span class="line"></span><br><span class="line">        proxy.save();//执行的是代理的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态代理总结:<br>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>2.缺点:<br>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p>
<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式.</p>
<h2 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h2><p>动态代理有以下特点:<br>1.代理对象,不需要实现接口<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>3.动态代理也叫做:JDK代理,接口代理</p>
<p>JDK中生成代理对象的API<br>代理类所在包:java.lang.reflect.Proxy<br>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</span><br></pre></td></tr></table></figure></p>
<p>注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:</p>
<ul>
<li>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的</li>
<li>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型</li>
<li>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入<br>代码示例:<br>接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法</li>
</ul>
<p>代理工厂类:ProxyFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建动态代理对象</span><br><span class="line"> * 动态代理不需要实现接口,但是需要指定接口类型</span><br><span class="line"> */</span><br><span class="line">public class ProxyFactory&#123;</span><br><span class="line"></span><br><span class="line">    //维护一个目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public ProxyFactory(Object target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //给目标对象生成代理对象</span><br><span class="line">    public Object getProxyInstance()&#123;</span><br><span class="line">        return Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;开始事务2&quot;);</span><br><span class="line">                        //执行目标对象方法</span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(&quot;提交事务2&quot;);</span><br><span class="line">                        return returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类:App.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 目标对象</span><br><span class="line">        IUserDao target = new UserDao();</span><br><span class="line">        // 【原始的类型 class cn.itcast.b_dynamic.UserDao】</span><br><span class="line">        System.out.println(target.getClass());</span><br><span class="line"></span><br><span class="line">        // 给目标对象，创建代理对象</span><br><span class="line">        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();</span><br><span class="line">        // class $Proxy0   内存中动态生成的代理对象</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line"></span><br><span class="line">        // 执行方法   【代理对象】</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:<br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理</p>
<h2 id="二、CGLIB代理"><a href="#二、CGLIB代理" class="headerlink" title="二、CGLIB代理"></a>二、CGLIB代理</h2><h3 id="CGLIB概述"><a href="#CGLIB概述" class="headerlink" title="CGLIB概述"></a>CGLIB概述</h3><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p>
<p>CGLIB也提供了一个处理器接口（这里成为回调接口）net.sf.cglib.proxy.MethodInterceptor（相当于JDK代理的InvocationHandler接口），它自定义了一个intercept方法（相当于JDK代理的invoke方法），用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数是代理类对象，第二个参数是委托类被调用的方法的类对象</span></span><br><span class="line"><span class="comment">// 第三个是该方法的参数，第四个是生成在代理类里面，除了方法名不同，其他都和被代理方法一样的（参数，方法体里面的东西）一个方法的类对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodproxy)</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure></p>
<p>然后CGLIB也提供了一个生成代理类的类net.sf.cglib.proxy.Enhancer（相当于JDK代理的java.lang.reflect.Proxy），它提供了一组静态方法来为一组接口动态地生成代理类及其对象。本文创建代理用到的Enhancer的静态方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object proxy,Method method, Object[] args,  MethodProxy methodproxy) throws Throwable</span><br><span class="line">       //为指定类装载器、接口及调用处理器生成动态代理类实例</span><br><span class="line">       public static  Object create(Class class ,Callback callback h)&#123;&#125;</span><br><span class="line">       public static  Object create(Class class,Class[] interfaces,Callback h)&#123;&#125;</span><br><span class="line">       public static Object create(Classclass, Class[] interfaces, CallbackFilter filter, Callback[] hs)</span><br><span class="line">       public Object create(Class[] argumentTypes, Object[] arguments)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p> 这个create方法相当于JDK代理的newProxyInstance方法，该方法的参数具体含义如下：</p>
<ul>
<li>Class class：指定一个被代理类的类对象。</li>
<li>Class[]interfaces：如果要代理接口，指定一组被代理类实现的所有接口的类对象。</li>
<li>Callback h：指定一个实现了处理器接口（这里称回调接口）的对象。</li>
<li>CallbackFilter filter：指定一个方法过滤器。</li>
<li>Callback[]hs：指定一组实现了处理器接口的对象。</li>
<li>Class[] argumentTypes：指定某个构造器的参数类型</li>
<li>Object[] arguments：指定某个gouz</li>
</ul>
<h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ol>
<li>通过实现 MethodInterceptor接口创建自己的处理器；</li>
<li>通过给Enhancer类的create()方法传进被代理类的类对象、实现了MethodInterceptor接口的处理器对象，得到一个代理类对   象。</li>
<li>其中Enhancer类通过反射机制获得代理类的构造函数，有一个参数类型是处理器接口类型。</li>
<li>Enhancer类再通过构造函数对象创建动态代理类实例，构造时处理器对象作为参数被传入。</li>
<li><p>当客户端调用了代理类的方法时，该方法调用了处理器的intercept()方法并给intercept()方法传进委托类方法的类对象，intercept方法再调用委托类的真实方法。<br>(1)建一个reallyCglibProxy包，所有程序都放在该包下，我在Spring的包库里面找到两个包：asm.jar和cblib-2.1.3.jar，最好在Spring里面同时拷贝这两个包到项目的类库下，不要分别从网上下载，可能会冲突。<br>(2)建一个被代理类（RealSubject.java）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">//被代理类</span><br><span class="line">public class RealSubject &#123;</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(&quot;被代理的人郭襄&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）建一个用户自定义的处理器类LogHandler.java，需要实现处理接口，在intercept（）方法里写上被代理类的方法调用前后要进行的动作。这个intercept（）方法我们不用直接调用，是让将来自动生成的代理类去调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import jdkDynamicProxy.LonHanderReflectTool;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line">//相当于实现jdk的InvocationHandler接口</span><br><span class="line">public class LogHandler implements MethodInterceptor&#123;</span><br><span class="line">	private Object delegate; //被代理类的对象</span><br><span class="line">	//绑定被代理类的对象</span><br><span class="line">	public Object bind(Object delegate)throws Exception&#123;</span><br><span class="line">		this.delegate=delegate;</span><br><span class="line">	return Enhancer.create(delegate.getClass(),this);</span><br><span class="line">	&#125;  </span><br><span class="line">	//相当于InvocationHandler接口里面的invoke()方法</span><br><span class="line">	@Override</span><br><span class="line">	public Object intercept(Object proxy, Method method, Object[] args,</span><br><span class="line">			MethodProxy methodproxy) throws Throwable &#123;</span><br><span class="line">		Object result=null;</span><br><span class="line">		System.out.println(&quot;我是代理人郭靖，开始代理&quot;);</span><br><span class="line">		</span><br><span class="line">		//method.invoke()或者methodproxy.invoke()都可以</span><br><span class="line">		result=method.invoke(delegate,args);</span><br><span class="line">		//result=methodproxy.invoke(delegate,args);</span><br><span class="line">		System.out.println(&quot;我是代理人郭靖，代理完毕&quot;);</span><br><span class="line"> </span><br><span class="line">		//调用工具类反射jdk的Proxy生成的代理类，可参考《五》中这个工具类</span><br><span class="line">		LonHanderReflectTool.ReflectClass(proxy.getClass().getName());</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>(4)编写测试客户端（TestReallyCglibProxy.java）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">public class TestReallyCglibProxy &#123;</span><br><span class="line">	public static void main(String[] args)throws Exception &#123;</span><br><span class="line">		RealSubject sub1=new RealSubject();</span><br><span class="line">		LogHandler hander=new LogHandler();</span><br><span class="line">		RealSubject sub2=(RealSubject)hander.bind(sub1);</span><br><span class="line">		sub2.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是代理人郭靖，开始代理</span><br><span class="line"></span><br><span class="line">被代理的人郭襄</span><br><span class="line"></span><br><span class="line">我是代理人郭靖，代理完毕</span><br></pre></td></tr></table></figure></p>
<p>从结果可以看出，成功自动生成了代理类RealSubject$$EnhancerByCGLIB$$48574fb2，并成功实现了代理的效果，而且还代理了RealSubject类从父类继承的finalize、equals、toString、hashCode、clone这几个方法。</p>
<h3 id="CBLIB方法过滤器"><a href="#CBLIB方法过滤器" class="headerlink" title="CBLIB方法过滤器"></a>CBLIB方法过滤器</h3><p>如果现在有个要求，被代理类的print方法不用处理。当最简单的方式是修改方法拦截器（即intercept方法），在里面进行判断，如果是print()方法就不做任何逻辑处理，直接调用，这样子使得编写拦截器（相当于JDK代理里的处理器）逻辑变复杂，不易维护。我们可以使用CGLIB提供的方法过滤器（CallbackFilter），使得被代理类中不同的方法，根据我们的逻辑要求，调用不同的处理器，从而使用不同的拦截方法（处理器方法）。<br>基本步骤如下:<br>（1）修改一下被代理类（RealSubject.java），增加一个方法print2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">//被代理类</span><br><span class="line">public class RealSubject &#123;</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(&quot;被代理的人郭襄&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void print2() &#123;</span><br><span class="line">		System.out.println(&quot;我是print2方法哦&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）新建一个用户自定义的方法过滤器类MyProxyFilter.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line"> </span><br><span class="line">import net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"> </span><br><span class="line">import net.sf.cglib.proxy.NoOp;</span><br><span class="line"> </span><br><span class="line">//自定义方法过滤器类</span><br><span class="line"> </span><br><span class="line">public class MyProxyFilterimplements CallbackFilter &#123;</span><br><span class="line"> </span><br><span class="line">    public int accept(Method method) &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">    *这句话可发现，所有被代理的方法都会被过滤一次。Enhancer的源代码中看到下面一段代码</span><br><span class="line">    while(it1.hasNext())&#123;</span><br><span class="line">    MethodInfomethod=(MethodInfo)it1.next();</span><br><span class="line">    MethodactualMethod=(it2!=null)?(Method)it2.next():null;</span><br><span class="line">    intindex=filter.accept(actualMethod);</span><br><span class="line">    if(index&gt;=callbackTypes.length)&#123;</span><br><span class="line">    thrownewIllegalArgumentException(&quot;Callbackfilterreturnedanindexthatistoolarge:&quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line">    上段代码可以看到所有的被代理的方法，本例子中就是print、print2、从父类继承的finalize、equals、toString、</span><br><span class="line">    hashCode、clone这几个方法）都被调用accept方法进行过滤，给每个方法返回一个整数，</span><br><span class="line">    本例子是0或者1，从而选择不同的处理器。</span><br><span class="line">    */</span><br><span class="line"> </span><br><span class="line">System.out.println(method.getDeclaringClass()+&quot;类的&quot;+method.getName()+&quot;方法被检查过滤！&quot;);</span><br><span class="line"> </span><br><span class="line">    /* </span><br><span class="line">    如果调用是print方法，则要调用0号位的拦截器去处理</span><br><span class="line">         */</span><br><span class="line"> </span><br><span class="line">    if(&quot;print&quot;.equals(method.getName()))   </span><br><span class="line"> </span><br><span class="line">    //0号位即LogHandler里面 new Callback[]&#123;this,NoOp.INSTANCE&#125;中的this，它在这个数组第0位置</span><br><span class="line"> </span><br><span class="line">return 1; </span><br><span class="line"> </span><br><span class="line">    /*     </span><br><span class="line">      1号位即LogHandler里面 new Callback[]&#123;this,NoOp.INSTANCE&#125;中的NoOp.INSTANCE，它在这个数组第1位置。</span><br><span class="line">    NoOp.INSTANCE是指不做任何事情的拦截器。</span><br><span class="line">在这里就是任何人都有权限访问print方法，即这个方法没有代理，直接调用</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">return 0;   </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）修改一下用户自定义的处理器类LogHandler.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import jdkDynamicProxy.LonHanderReflectTool;</span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">import net.sf.cglib.proxy.NoOp;</span><br><span class="line">//相当于实现jdk的InvocationHandler接口</span><br><span class="line">public class LogHandler implements MethodInterceptor&#123;</span><br><span class="line">	private Object delegate; //被代理类的对象</span><br><span class="line">	//绑定被代理类的对象</span><br><span class="line">	public Object bind(Object delegate)throws Exception&#123;</span><br><span class="line">		this.delegate=delegate;</span><br><span class="line">	/**</span><br><span class="line">	 *传进不同的拦截器（相当于JDK代理里面的处理器）,NoOp.INSTANCE是cglib已经写好的不做任何事情的拦截器，传进去的new Callback[]是一个数组，现在数组有两个拦截器对象，分别是this,和NoOp.INSTANCE，它们分别在数组的第0位和第一位对应着自定义过滤器MyProxyFilter里的accept方法返回的整数，如果是0就调用this拦截器，如果是1就调用NoOp.INSTANCE所以自定义过滤器MyProxyFilter里的accept方法返回的整数最大就是拦截器数组的长度，比如本例子当中，只能是0或者1，不能是2，因为这个数组只有两个元素，最大位置就是1号位。</span><br><span class="line">	 */</span><br><span class="line">	return Enhancer.create(delegate.getClass(), null, new MyProxyFilter(), new Callback[]&#123;this,NoOp.INSTANCE&#125;);	</span><br><span class="line">	&#125;  </span><br><span class="line">	//相当于InvocationHandler接口里面的invoke()方法</span><br><span class="line">	</span><br><span class="line">	public Object intercept(Object proxy, Method method, Object[] args,</span><br><span class="line">			MethodProxy methodproxy) throws Throwable &#123;</span><br><span class="line">		Object result=null;</span><br><span class="line">		System.out.println(&quot;我是代理人郭靖，开始代理&quot;);</span><br><span class="line">		</span><br><span class="line">		//method.invoke()或者methodproxy.invoke()都可以</span><br><span class="line">		result=method.invoke(delegate,args);</span><br><span class="line">		//result=methodproxy.invoke(delegate,args);</span><br><span class="line">		System.out.println(&quot;我是代理人郭靖，代理完毕&quot;);</span><br><span class="line"> </span><br><span class="line">		//调用工具类反射jdk的Proxy生成的代理类，可参考《五》中这个工具类</span><br><span class="line">		//LonHanderReflectTool.ReflectClass(proxy.getClass().getName());</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4) 修改测试客户端（TestReallyCglibProxy.java）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package reallyCglibProxy;</span><br><span class="line">publicclass TestReallyCglibProxy &#123;</span><br><span class="line">	publicstaticvoid main(String[] args)throws Exception &#123;</span><br><span class="line">		RealSubject sub1=new RealSubject();</span><br><span class="line">		LogHandler hander=new LogHandler();</span><br><span class="line">		RealSubject sub2=(RealSubject)hander.bind(sub1);</span><br><span class="line">		sub2.print();</span><br><span class="line">        sub2.print2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class reallyCglibProxy.RealSubject类的print2方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class reallyCglibProxy.RealSubject类的print方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的finalize方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的equals方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的toString方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的hashCode方法被检查过滤！</span><br><span class="line"></span><br><span class="line">class java.lang.Object类的clone方法被检查过滤！</span><br><span class="line"></span><br><span class="line">被代理的人郭襄</span><br><span class="line"></span><br><span class="line">我是代理人郭靖，开始代理</span><br><span class="line"></span><br><span class="line">我是print2方法哦</span><br><span class="line"></span><br><span class="line">我是代理人郭靖，代理完毕</span><br></pre></td></tr></table></figure></p>
<p>   从结果可以看出，print方法没有被代理，print2方法被代理了，有了方法过滤器，被代理类被代理的方法（本文例子中就是print、print2、从父类继承的finalize、equals、toString、hashCode、clone这几个方法）都被调用accept方法进行过滤，给每个方法返回一个整数，本例子是0或者1，从而选择不同的处理器。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">Java的三种代理模式</a></li>
<li><a href="https://blog.csdn.net/minidrupal/article/details/28588507" target="_blank" rel="noopener">浅析JAVA设计模式之代理模式(七)</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/proxyPattern/">http://catalinali.top/2018/proxyPattern/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> design-patterns </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design-patterns </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA并发编程(六)：线程本地变量ThreadLocal与TransmittableThreadLocal]]></title>
      <url>/2018/helloThreadLocal/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/ThreadLocal_logo.jpg" alt="volatile_logo"></p>
<blockquote>
<p>我们知道有时候一个对象的共享变量会被多个线程所访问，这时就会有线程安全问题。当然我们可以使用synchorinized 关键字来为此变量加锁，进行同步处理。从而限制只能有一个线程来使用此变量，但是加锁会大大影响程序执行效率，此外我们还可以使用ThreadLocal来解决对某一个变量的访问冲突问题。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、ThreadLocal-概述"><a href="#一、ThreadLocal-概述" class="headerlink" title="一、ThreadLocal 概述"></a>一、ThreadLocal 概述</h2><p>当使用ThreadLocal维护变量的时候 它为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。<br>ThreadLocal 的几个方法： ThreadLocal 可以存储任何类型的变量对象， get返回的是一个Object对象，但是我们可以通过泛型来制定存储对象的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123; &#125; // 用来获取ThreadLocal在当前线程中保存的变量副本</span><br><span class="line">public void set(T value) &#123; &#125; //set()用来设置当前线程中变量的副本</span><br><span class="line">public void remove() &#123; &#125; //remove()用来移除当前线程中变量的副本</span><br><span class="line">protected T initialValue() &#123; &#125; //initialValue()是一个protected方法，一般是用来在使用时进行重写的</span><br></pre></td></tr></table></figure></p>
<p>Thread 在内部是通过ThreadLocalMap来维护ThreadLocal变量表， 在Thread类中有一个threadLocals 变量，是ThreadLocalMap类型的，它就是为每一个线程来存储自身的ThreadLocal变量的， ThreadLocalMap是ThreadLocal类的一个内部类，这个Map里面的最小的存储单位是一个Entry， 它使用ThreadLocal作为key， 变量作为 value，这是因为在每一个线程里面，可能存在着多个ThreadLocal变量</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找<br>我们来看一个使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    public void set() &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">        stringLocal.set(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public long getLong() &#123;</span><br><span class="line">        return longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        test.set();</span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.set();</span><br><span class="line">                System.out.println(test.getLong());</span><br><span class="line">                System.out.println(test.getString());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">         </span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">main </span><br><span class="line">9 </span><br><span class="line">Thread-0 </span><br><span class="line">1 </span><br><span class="line">main</span><br></pre></td></tr></table></figure></p>
<h2 id="二、父子线程传递InheritableThreadLocal"><a href="#二、父子线程传递InheritableThreadLocal" class="headerlink" title="二、父子线程传递InheritableThreadLocal"></a>二、父子线程传递InheritableThreadLocal</h2><p>以上方案在父子线程中就有了局限性，如果子线程想要拿到父线程的中的ThreadLocal值怎么办呢？比如会有以下的这种代码的实现。由于ThreadLocal的实现机制,在子线程中get时,我们拿到的Thread对象是当前子线程对象,那么他的ThreadLocalMap是null的,所以我们得到的value也是null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final ThreadLocal threadLocal=new ThreadLocal()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object initialValue() &#123;</span><br><span class="line">                return &quot;xiezhaodong&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                threadLocal.get();//NULL</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>JDK已经为这种情况提供了实现方案:InheritableThreadLocal。大致的解释了一下InheritableThreadLocal为什么能解决父子线程传递Threadlcoal值的问题。<br>1）在创建InheritableThreadLocal对象的时候赋值给线程的t.inheritableThreadLocals变量<br>2）在创建新线程的时候会check父线程中t.inheritableThreadLocals变量是否为null，如果不为null则copy一份ThradLocalMap到子线程的t.inheritableThreadLocals成员变量中去<br>3）因为复写了getMap(Thread)和CreateMap()方法,所以get值得时候，就可以在getMap(t)的时候就会从t.inheritableThreadLocals中拿到map对象，从而实现了可以拿到父线程ThreadLocal中的值</p>
<p>所以,在最开始的代码示例中，如果把ThreadLocal对象换成InheritableThreadLocal对象，那么get到的字符会是“xiezhaodong”而不是NULL</p>
<h2 id="二、线程池传递TransmittableThreadLocal"><a href="#二、线程池传递TransmittableThreadLocal" class="headerlink" title="二、线程池传递TransmittableThreadLocal"></a>二、线程池传递TransmittableThreadLocal</h2><p>我们在使用线程的时候往往不会只是简单的new Thrad对象，而是使用线程池，当然线程池的好处多多。这里不详解，既然这里提出了问题，那么线程池会给InheritableThreadLocal带来什么问题呢？我们列举一下线程池的特点：</p>
<p>1）为了减小创建线程的开销，线程池会缓存已经使用过的线程<br>2）生命周期统一管理,合理的分配系统资源</p>
<p>对于第一点，如果一个子线程已经使用过，并且会set新的值到ThreadLocal中，那么第二个task提交进来的时候还能获得父线程中的值吗？答案是不能，如果我们能够，在使用完这个线程的时候清除所有的localMap，在submit新任务的时候在重新重父线程中copy所有的Entry。然后重新给当前线程的t.inhertableThreadLocal赋值。这样就能够解决在线程池中每一个新的任务都能够获得父线程中ThreadLocal中的值而不受其他任务的影响，因为在生命周期完成的时候会自动clear所有的数据。Alibaba的一个库解决了这个问题<a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">github:alibaba/transmittable-thread-local</a><br><strong>如何使用</strong><br>这个库最简单的方式是这样使用的,通过简单的修饰，使得提交的runable拥有了上一节所述的功能。具体的API文档详见github，这里不再赘述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TransmittableThreadLocal&lt;String&gt; parent = new TransmittableThreadLocal&lt;String&gt;();</span><br><span class="line">parent.set(&quot;value-set-in-parent&quot;);</span><br><span class="line"></span><br><span class="line">Runnable task = new Task(&quot;1&quot;);</span><br><span class="line">// 额外的处理，生成修饰了的对象ttlRunnable</span><br><span class="line">Runnable ttlRunnable = TtlRunnable.get(task); </span><br><span class="line">executorService.submit(ttlRunnable);</span><br><span class="line"></span><br><span class="line">// Task中可以读取, 值是&quot;value-set-in-parent&quot;</span><br><span class="line">String value = parent.get();</span><br></pre></td></tr></table></figure></p>
<p><strong>原理简述</strong><br>这个方法TtlRunnable.get(task)最终会调用构造方法，返回的是该类本身，也是一个Runable,这样就完成了简单的装饰。最重要的是在run方法这个地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final class TtlRunnable implements Runnable &#123;</span><br><span class="line">    private final AtomicReference&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;&gt; copiedRef;</span><br><span class="line">    private final Runnable runnable;</span><br><span class="line">    private final boolean releaseTtlValueReferenceAfterRun;</span><br><span class="line"></span><br><span class="line">    private TtlRunnable(Runnable runnable, boolean releaseTtlValueReferenceAfterRun) &#123;</span><br><span class="line">    //从父类copy值到本类当中</span><br><span class="line">        this.copiedRef = new AtomicReference&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;&gt;(TransmittableThreadLocal.copy());</span><br><span class="line">        this.runnable = runnable;//提交的runable,被修饰对象</span><br><span class="line">        this.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * wrap method &#123;@link Runnable#run()&#125;.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; copied = copiedRef.get();</span><br><span class="line">        if (copied == null || releaseTtlValueReferenceAfterRun &amp;&amp; !copiedRef.compareAndSet(copied, null)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;TTL value reference is released after run!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //装载到当前线程</span><br><span class="line">        Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = TransmittableThreadLocal.backupAndSetToCopied(copied);</span><br><span class="line">        try &#123;</span><br><span class="line">            runnable.run();//执行提交的task</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        //clear</span><br><span class="line">            TransmittableThreadLocal.restoreBackup(backup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的使用线程池的例子当中，如果换成这种修饰的方式进行操作，B任务得到的肯定是父线程中ThreadLocal的值，解决了在线程池中InheritableThreadLocal不能解决的问题。<br><strong>如何更新父线程ThreadLocal值？</strong><br>如果线程之间出了要能够得到父线程中的值，同时想更新值怎么办呢？在前面我们有提到，当子线程copy父线程的ThreadLocalMap的时候是浅拷贝的,代表子线程Entry里面的value都是指向的同一个引用，我们只要修改这个引用的同时就能够修改父线程当中的值了,比如这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              System.out.println(&quot;========&quot;);</span><br><span class="line">              Span span=  inheritableThreadLocal.get();</span><br><span class="line">              System.out.println(span);</span><br><span class="line">              span.name=&quot;liuliuliu&quot;;//修改父引用为liuliuliu</span><br><span class="line">              inheritableThreadLocal.set(new Span(&quot;zhangzhangzhang&quot;));</span><br><span class="line">              System.out.println(inheritableThreadLocal.get());</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样父线程中的值就会得到更新了。能够满足父线程ThreadLocal值的实时更新，同时子线程也能共享父线程的值。不过场景倒是不是很常见的样子。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></li>
<li><a href="https://blog.csdn.net/a837199685/article/details/52712547" target="_blank" rel="noopener">ThreadLocal父子线程传递实现方案</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloThreadLocal/">http://catalinali.top/2018/helloThreadLocal/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> juc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> juc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA并发编程(五)：创建线程的第三种方式：实现Callable接口]]></title>
      <url>/2018/helloCallable/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/helloCallable_logo.jpg" alt="volatile_logo"></p>
<blockquote>
<p>众所周知创建线程的方式有两种：1.继承Thread类。2.实现Runnable接口。从jdk1.5开始，提供了另一种创建线程的方式。今天我们就来看看这第三种方式：实现Callable接口</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Callable与Runnable"><a href="#一、Callable与Runnable" class="headerlink" title="一、Callable与Runnable"></a>一、Callable与Runnable</h2><p>我们直接来看一个使用Callable创建线程的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">		FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(result).start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Integer sum = result.get();  <span class="comment">//FutureTask 可用于 闭锁</span></span><br><span class="line">			System.out.println(sum);</span><br><span class="line">			System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个例子可以看出，Callable与Runnable的主要区别在于Callable可以拿到任务执行后的返回值。Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></p>
<p>第一个submit方法里面的参数类型就是Callable。<br>一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p>
<h2 id="二、Future和FutureTask"><a href="#二、Future和FutureTask" class="headerlink" title="二、Future和FutureTask"></a>二、Future和FutureTask</h2><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>　　Future类位于java.util.concurrent包下，它是一个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p>
<ul>
<li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>
<li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就会抛出异常，如果捕获了直接返回null。<br>也就是说Future提供了三种功能<br>1）判断任务是否完成；<br>2）能够中断任务；<br>3）能够获取任务执行结果<br>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有FutureTask。</li>
</ul>
<p>我们先来看一下FutureTask的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>
<p> 　　FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p>　　FutureTask提供了2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　事实上，FutureTask是Future接口的一个唯一实现类。<br>　　下面来一个FutureTaskde使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line">        <span class="comment">/*Task task = new Task();</span></span><br><span class="line"><span class="comment">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">        Thread thread = new Thread(futureTask);</span></span><br><span class="line"><span class="comment">        thread.start();*/</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java并发编程：Callable、Future和FutureTask</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloCallable/">http://catalinali.top/2018/helloCallable/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> juc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> juc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转载）JAVA并发编程(四)：线程池的使用]]></title>
      <url>/2018/helloThreadPool/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/ThreadPool_logo.jpg" alt="volatile_logo"></p>
<blockquote>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p>
</blockquote>
<a id="more"></a>
<p>本文转载自<a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></p>
<h2 id="一、Java中的ThreadPoolExecutor类"><a href="#一、Java中的ThreadPoolExecutor类" class="headerlink" title="一、Java中的ThreadPoolExecutor类"></a>一、Java中的ThreadPoolExecutor类</h2><p>　java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。<br>　　在ThreadPoolExecutor类中提供了四个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。<br> 　　下面解释下一下构造器中各个参数的含义：</p>
<ul>
<li><p>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
</li>
<li><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
</li>
<li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               //天</span><br><span class="line">TimeUnit.HOURS;             //小时</span><br><span class="line">TimeUnit.MINUTES;           //分钟</span><br><span class="line">TimeUnit.SECONDS;           //秒</span><br><span class="line">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class="line">TimeUnit.MICROSECONDS;      //微妙</span><br><span class="line">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></table></figure>
</li>
<li><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br><span class="line">PriorityBlockingQueue;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>
<ul>
<li>threadFactory：线程工厂，主要用来创建线程；</li>
<li>handler：表示当拒绝处理任务时的策略，有以下四种取值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。<br>　　我们接着看ExecutorService接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　到这里，大家应该明白了ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。<br>　　Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；<br>　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；<br>　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；<br>　　然后ThreadPoolExecutor继承了类AbstractExecutorService。<br>　　在ThreadPoolExecutor类中有几个非常重要的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute()</span><br><span class="line">submit()</span><br><span class="line">shutdown()</span><br><span class="line">shutdownNow()</span><br></pre></td></tr></table></figure></p>
<p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。<br>　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。<br>　　shutdown()和shutdownNow()是用来关闭线程池的。<br>　　还有很多其他的方法：<br>　　比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。</p>
<h2 id="二、深入剖析线程池实现原理"><a href="#二、深入剖析线程池实现原理" class="headerlink" title="二、深入剖析线程池实现原理"></a>二、深入剖析线程池实现原理</h2><p>在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：<br>　　<strong>1.线程池状态<br>　　2.任务的执行<br>　　3.线程池中的线程初始化<br>　　4.任务缓存队列及排队策略<br>　　5.任务拒绝策略<br>　　6.线程池的关闭<br>　　7.线程池容量的动态调整</strong></p>
<h3 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1.线程池状态"></a>1.线程池状态</h3><p>在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile int runState;</span><br><span class="line">static final int RUNNING    = 0;</span><br><span class="line">static final int SHUTDOWN   = 1;</span><br><span class="line">static final int STOP       = 2;</span><br><span class="line">static final int TERMINATED = 3;</span><br></pre></td></tr></table></figure></p>
<p>　  runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；<br>　　下面的几个static final变量表示runState可能的几个取值。<br>　　当创建线程池后，初始时，线程池处于RUNNING状态；<br>　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p>
<h3 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2.任务的执行"></a>2.任务的执行</h3><p>在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;              <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小</span></span><br><span class="line">                                                              <span class="comment">//、runState等）的改变都要使用这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure></p>
<pre><code>每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。
</code></pre><p>　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：<br>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。<br>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；<br>　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；<br>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；<br>　　然后就将任务也分配给这4个临时工人做；<br>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。<br>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。<br>　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。<br>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。<br>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。<br>　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。<br>　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。<br>　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：<br>　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；<br>　　接着是这句，这句要好好理解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))</span><br></pre></td></tr></table></figure></p>
<p>　　由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。<br>　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderCorePoolSize(command)</span><br></pre></td></tr></table></figure></p>
<pre><code>如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。
</code></pre><p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (runState == RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure></p>
<p>如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderMaximumPoolSize(command)</span><br></pre></td></tr></table></figure></p>
<p>如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。回到前面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (runState == RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure></p>
<p>这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (runState != RUNNING || poolSize == 0)</span><br></pre></td></tr></table></figure></p>
<p>这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureQueuedTaskHandled(command)</span><br></pre></td></tr></table></figure></p>
<p>进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);        <span class="comment">//创建线程去执行firstTask任务   </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = addThread(firstTask);</span><br></pre></td></tr></table></figure></p>
<p> 　　这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。<br>　　我们来看一下addThread方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Thread addThread(Runnable firstTask) &#123;</span><br><span class="line">    Worker w = new Worker(firstTask);</span><br><span class="line">    Thread t = threadFactory.newThread(w);  //创建一个线程，执行任务   </span><br><span class="line">    if (t != null) &#123;</span><br><span class="line">        w.thread = t;            //将创建的线程的引用赋值为w的成员变量       </span><br><span class="line">        workers.add(w);</span><br><span class="line">        int nt = ++poolSize;     //当前线程数加1       </span><br><span class="line">        if (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = nt;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。<br>　　下面我们看一下Worker类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker implements Runnable &#123;</span><br><span class="line">    private final ReentrantLock runLock = new ReentrantLock();</span><br><span class="line">    private Runnable firstTask;</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line">    Thread thread;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        this.firstTask = firstTask;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isActive() &#123;</span><br><span class="line">        return runLock.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    void interruptIfIdle() &#123;</span><br><span class="line">        final ReentrantLock runLock = this.runLock;</span><br><span class="line">        if (runLock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">        if (thread != Thread.currentThread())</span><br><span class="line">        thread.interrupt();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                runLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void interruptNow() &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void runTask(Runnable task) &#123;</span><br><span class="line">        final ReentrantLock runLock = this.runLock;</span><br><span class="line">        runLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (runState &lt; STOP &amp;&amp;</span><br><span class="line">                Thread.interrupted() &amp;&amp;</span><br><span class="line">                runState &gt;= STOP)</span><br><span class="line">            boolean ran = false;</span><br><span class="line">            beforeExecute(thread, task);   //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据</span><br><span class="line">            //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           </span><br><span class="line">            try &#123;</span><br><span class="line">                task.run();</span><br><span class="line">                ran = true;</span><br><span class="line">                afterExecute(task, null);</span><br><span class="line">                ++completedTasks;</span><br><span class="line">            &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">                if (!ran)</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable task = firstTask;</span><br><span class="line">            firstTask = null;</span><br><span class="line">            while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">                runTask(task);</span><br><span class="line">                task = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workerDone(this);   //当任务队列中没有任务时，进行清理工作       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new Thread(w);</span><br></pre></td></tr></table></figure></p>
<p>相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = null;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        workerDone(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> state = runState;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Runnable r;</span><br><span class="line">            <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                r = workQueue.poll();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) <span class="comment">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span></span><br><span class="line">                <span class="comment">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span></span><br><span class="line">                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">if</span> (workerCanExit()) &#123;    <span class="comment">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span></span><br><span class="line">                <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                    interruptIdleWorkers();   <span class="comment">//中断处于空闲状态的worker</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Else retry</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> state = runState;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Runnable r;</span><br><span class="line">            <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                r = workQueue.poll();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) <span class="comment">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span></span><br><span class="line">                <span class="comment">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span></span><br><span class="line">                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">if</span> (workerCanExit()) &#123;    <span class="comment">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span></span><br><span class="line">                <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                    interruptIdleWorkers();   <span class="comment">//中断处于空闲状态的worker</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Else retry</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。<br>　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。<br>　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。<br>　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private boolean workerCanExit() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    boolean canExit;</span><br><span class="line">    //如果runState大于等于STOP，或者任务缓存队列为空了</span><br><span class="line">    //或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1</span><br><span class="line">    try &#123;</span><br><span class="line">        canExit = runState &gt;= STOP ||</span><br><span class="line">            workQueue.isEmpty() ||</span><br><span class="line">            (allowCoreThreadTimeOut &amp;&amp;</span><br><span class="line">             poolSize &gt; Math.max(1, corePoolSize));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return canExit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void interruptIdleWorkers() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers)  //实际上调用的是worker的interruptIfIdle()方法</span><br><span class="line">            w.interruptIfIdle();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void interruptIfIdle() &#123;</span><br><span class="line">    final ReentrantLock runLock = this.runLock;</span><br><span class="line">    if (runLock.tryLock()) &#123;    //注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的</span><br><span class="line">                                //如果成功获取了锁，说明当前worker处于空闲状态</span><br><span class="line">        try &#123;</span><br><span class="line">    if (thread != Thread.currentThread())  </span><br><span class="line">    thread.interrupt();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  　　这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。<br> 　　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfUnderMaximumPoolSize(Runnable firstTask) &#123;</span><br><span class="line">    Thread t = null;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (t == null)</span><br><span class="line">        return false;</span><br><span class="line">    t.start();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。<br>　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：<br>　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；<br>　　2）其次，要知道Worker是用来起到什么作用的；<br>　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：<br>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</p>
<h3 id="3-线程池中的线程初始化"><a href="#3-线程池中的线程初始化" class="headerlink" title="3.线程池中的线程初始化"></a>3.线程池中的线程初始化</h3><p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p>
<p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
<p>prestartCoreThread()：初始化一个核心线程；<br>prestartAllCoreThreads()：初始化所有核心线程<br>　　下面是这2个方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean prestartCoreThread() &#123;</span><br><span class="line">    return addIfUnderCorePoolSize(null); //注意传进去的参数是null</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int prestartAllCoreThreads() &#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">    while (addIfUnderCorePoolSize(null))//注意传进去的参数是null</span><br><span class="line">        ++n;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 　　注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = workQueue.take();</span><br></pre></td></tr></table></figure></p>
<p>即等待任务队列中有任务。</p>
<h3 id="4-任务缓存队列及排队策略"><a href="#4-任务缓存队列及排队策略" class="headerlink" title="4.任务缓存队列及排队策略"></a>4.任务缓存队列及排队策略</h3><p>　　在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。<br>　　workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：<br>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；<br>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；<br>　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</runnable></p>
<h3 id="5-任务拒绝策略"><a href="#5-任务拒绝策略" class="headerlink" title="5.任务拒绝策略"></a>5.任务拒绝策略</h3><p>　　当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></p>
<h3 id="6-线程池的关闭"><a href="#6-线程池的关闭" class="headerlink" title="6.线程池的关闭"></a>6.线程池的关闭</h3><p>　　ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li><p>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p>
<h3 id="7-线程池容量的动态调整"><a href="#7-线程池容量的动态调整" class="headerlink" title="7.线程池容量的动态调整"></a>7.线程池容量的动态调整</h3><p>　　ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize():</p>
</li>
<li><p>setCorePoolSize：设置核心池大小</p>
</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小<br>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。
　<h2 id="三、使用示例"><a href="#三、使用示例" class="headerlink" title="三、使用示例"></a>三、使用示例</h2></li>
</ul>
<p>前面我们讨论了关于线程池的实现原理，这一节我们来看一下它的具体使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                 <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">             MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">             executor.execute(myTask);</span><br><span class="line">             System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">             executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</span><br><span class="line">         &#125;</span><br><span class="line">         executor.shutdown();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行task "</span>+taskNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"task "</span>+taskNum+<span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">正在执行task 0</span><br><span class="line">线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 1</span><br><span class="line">线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 2</span><br><span class="line">线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 3</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 4</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 10</span><br><span class="line">线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 11</span><br><span class="line">线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 12</span><br><span class="line">线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 13</span><br><span class="line">线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span><br><span class="line">正在执行task 14</span><br><span class="line">task 3执行完毕</span><br><span class="line">task 0执行完毕</span><br><span class="line">task 2执行完毕</span><br><span class="line">task 1执行完毕</span><br><span class="line">正在执行task 8</span><br><span class="line">正在执行task 7</span><br><span class="line">正在执行task 6</span><br><span class="line">正在执行task 5</span><br><span class="line">task 4执行完毕</span><br><span class="line">task 10执行完毕</span><br><span class="line">task 11执行完毕</span><br><span class="line">task 13执行完毕</span><br><span class="line">task 12执行完毕</span><br><span class="line">正在执行task 9</span><br><span class="line">task 14执行完毕</span><br><span class="line">task 8执行完毕</span><br><span class="line">task 5执行完毕</span><br><span class="line">task 7执行完毕</span><br><span class="line">task 6执行完毕</span><br><span class="line">task 9执行完毕</span><br></pre></td></tr></table></figure></p>
<p>从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。<br>　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span><br><span class="line">Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池</span><br><span class="line">Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池</span><br></pre></td></tr></table></figure></p>
<p>下面是这三个静态方法的具体实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。<br>　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；<br>　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；<br>　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。<br>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。<br>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p>
<h2 id="四、如何合理配置线程池的大小"><a href="#四、如何合理配置线程池的大小" class="headerlink" title="四、如何合理配置线程池的大小"></a>四、如何合理配置线程池的大小</h2><p>　  本节来讨论一个比较重要的话题：如何合理配置线程池大小，仅供参考。<br>　　一般需要根据任务的类型来配置线程池大小：<br>　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1<br>　　如果是IO密集型任务，参考值可以设置为2*NCPU<br>　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloThreadPool/">http://catalinali.top/2018/helloThreadPool/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> juc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> juc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA并发编程(三)：同步的辅助类之闭锁（CountDownLatch）与循环屏障（CyclicBarrier）]]></title>
      <url>/2018/helloLatch/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/helloLatch_logo.jpg" alt="volatile_logo"></p>
<blockquote>
<p>jdk1.5的concurrent包为我们提供了很多有用的辅助类，今天我们来学习一下</p>
</blockquote>
<a id="more"></a>
<h2 id="一、闭锁CountDownLatch"><a href="#一、闭锁CountDownLatch" class="headerlink" title="一、闭锁CountDownLatch"></a>一、闭锁CountDownLatch</h2><p>CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。它的作用是，在完成某些运算时，只有其他所有线程的运算全部完成，当前线程的运算才继续执行。<br>CountDownLatch类只提供了一个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;  &#125;;  //参数count为计数值</span><br></pre></td></tr></table></figure></p>
<p>然后下面这3个方法是CountDownLatch类中最重要的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123; &#125;;   //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">public void countDown() &#123; &#125;;  //将count值减1</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看看下面的这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class TestCountDownLatch &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final CountDownLatch latch = new CountDownLatch(50);</span><br><span class="line">		LatchDemo ld = new LatchDemo(latch);</span><br><span class="line"></span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">			new Thread(ld).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			latch.await();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		long end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;耗费时间为：&quot; + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LatchDemo implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">	public LatchDemo(CountDownLatch latch) &#123;</span><br><span class="line">		this.latch = latch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			for (int i = 0; i &lt; 50000; i++) &#123;</span><br><span class="line">				if (i % 2 == 0) &#123;</span><br><span class="line">					System.out.println(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			latch.countDown();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过CountDownLatch，我们就可以计算一批线程的执行时间。从这个例子中我们也可以看出：CountDownLatch中维护了一个int类型的变量。当前线程调用await()方法来使用这个辅助类，在这个变量成为0之后当前线程就会继续执行下去了。所以我们在构造器里填入的变量要跟等待的线程数量相同。</p>
<h2 id="二、CyclicBarrier"><a href="#二、CyclicBarrier" class="headerlink" title="二、CyclicBarrier"></a>二、CyclicBarrier</h2><pre><code>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。
</code></pre><p>CyclicBarrier提供2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。<br>　　然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123; &#125;;</span><br><span class="line">public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p> 　　第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p>
<p>　　第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 4;</span><br><span class="line">        CyclicBarrier barrier  = new CyclicBarrier(N);</span><br><span class="line">        for(int i=0;i&lt;N;i++)</span><br><span class="line">            new Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Writer extends Thread&#123;</span><br><span class="line">        private CyclicBarrier cyclicBarrier;</span><br><span class="line">        public Writer(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            this.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);      //以睡眠来模拟写入数据操作</span><br><span class="line">                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;catch(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure></p>
<h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><ul>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器是可以重用的。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="noopener">Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</a></li>
<li><a href="http://ifeve.com/concurrency-cyclicbarrier/" target="_blank" rel="noopener">并发工具类（二）同步屏障CyclicBarrier</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloLatch/">http://catalinali.top/2018/helloLatch/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> juc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> juc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA并发编程(二)：理解CAS机制]]></title>
      <url>/2018/helloCAS/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/helloCAS_logo.jpg" alt="volatile_logo"></p>
<blockquote>
<p>也许大家已经听说过，锁分两种，一个叫悲观锁，一种称之为乐观锁。Synchronized就是悲观锁的一种，也称之为独占锁，加了synchronized关键字的代码基本上就只能以单线程的形式去执行了，它会导致其他需要该资源的线程挂起，直到前面的线程执行完毕释放所资源。而另外一种乐观锁是一种更高效的机制，它的原理就是每次不加锁去执行某项操作，如果发生冲突则失败并重试，直到成功为止，其实本质上不算锁，所以很多地方也称之为自旋。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、并发编程中的原子性问题"><a href="#一、并发编程中的原子性问题" class="headerlink" title="一、并发编程中的原子性问题"></a>一、并发编程中的原子性问题</h2><p>在上篇<a href="http://catalinali.top/2018/helloVolatile/">JAVA并发编程(一)：理解volatile关键字</a>的结尾留了一个原子性的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写”</span></span><br><span class="line"><span class="comment"> * 		  int i = 10;</span></span><br><span class="line"><span class="comment"> * 		  i = i++; //10</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		  int temp = i;</span></span><br><span class="line"><span class="comment"> * 		  i = i + 1;</span></span><br><span class="line"><span class="comment"> * 		  i = temp;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(getSerialNumber());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> serialNumber++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果并不总是0-10。要想解决这个问题，你可能会说加Synchronized同步锁：加了同步锁之后，serialNumber++操作变成了原子性操作，所以最终的输出一定是0-9，代码实现了线程安全。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (TestAtomicDemo.class) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是众所周知的是Synchronized同步锁比较耗费性能，在某些情况下并不是一个好的选择，那有没有什么好的办法呢？在JDK1.5之后，java.util.concurrent.atomic包下为我们封装了常用的原子变量，他们底层就是使用了<strong>CAS</strong>（compare and swap）算法来保证原子性，我们将上面例子中的serialNumber改为使用AtomicInteger修饰，然后运行发现也可以得到正确的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	private volatile int serialNumber = 0;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serialNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="二、什么是CAS？"><a href="#二、什么是CAS？" class="headerlink" title="二、什么是CAS？"></a>二、什么是CAS？</h2><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。<br>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。<br>来看一个例子：<br>我们现在有两个线程：<br>1.在内存地址V当中，存储着值为10的变量。<br>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。<br>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。<br>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。<br>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。<br>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。<br>7.线程1进行SWAP，把地址V的值替换为B，也就是12。<br>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<h2 id="三、CAS的缺点"><a href="#三、CAS的缺点" class="headerlink" title="三、CAS的缺点"></a>三、CAS的缺点</h2><p>CAS机制这么巧妙，是不是在任何地方都比同步锁要好？然而并不是这样的，CAS机制有以下几个问题：</p>
<ul>
<li><strong>CPU开销较大</strong><br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
<li><strong>不能保证代码块的原子性</strong><br>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</li>
<li><p><strong>ABA问题</strong><br>什么是ABA呢？简单说就是一个值从A改成了B，又从B改成了A。<br>1.假设内存中有一个值为A的变量，存储在地址V当中。<br>2.此时有三个线程想使用CAS的方式更新这个变量值，每个线程的执行时间有略微的偏差。线程1和线程2已经获得当前值，线程3还未获得当前值。<br>3.接下来，线程1先一步执行成功，把当前值成功从A更新为B；同时线程2因为某种原因被阻塞住，没有做更新操作；线程3在线程1更新之后，获得了当前值B。<br>4.再之后，线程2仍然处于阻塞状态，线程3继续执行，成功把当前值从B更新成了A。<br>5.最后，线程2终于恢复了运行状态，由于阻塞之前已经获得了“当前值”A，并且经过compare检测，内存地址V中的实际值也是A，所以成功把变量值A更新成了B。<br>6.这个过程中，线程2获取到的变量值A是一个旧值，尽管和当前的实际值相同，但内存地址V中的变量已经经历了A-&gt;B-&gt;A的改变。<br>从表面看起来运行结果好像没什么问题，但是结合实际情况就会出现问题了。比如取款时有可能发生两个线程同时扣款成功的情况。所以，真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。<br>在Java当中，AtomicStampedReference类就实现了用版本号做比较的CAS机制。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2></li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192625&amp;idx=1&amp;sn=cbabbd806e4874e8793332724ca9d454&amp;chksm=8c99f36bbbee7a7d169581dedbe09658d0b0edb62d2cbc9ba4c40f706cb678c7d8c768afb666&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">漫画：什么是 CAS 机制？</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloCAS/">http://catalinali.top/2018/helloCAS/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> juc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> juc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA并发编程(一)：理解volatile关键字]]></title>
      <url>/2018/helloVolatile/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/volatile_logo.png" alt="volatile_logo"></p>
<blockquote>
<p>Java中volatile这个热门的关键字，在面试中经常会被提及，在各种技术交流群中也经常被讨论：volatile关键字在java多线程中有着比较重要作用，volatile主要作用是可以保持变量在多线程中是实时可见的,是java中提供的最轻量的同步机制。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、JAVA内存模型概述"><a href="#一、JAVA内存模型概述" class="headerlink" title="一、JAVA内存模型概述"></a>一、JAVA内存模型概述</h2><p>在了解volatile关键字之前，我们先来认识一下Java的内存模型。<br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意如图所示<br><img src="http://ou3np1yz4.bkt.clouddn.com/volatile_1.png" alt="volatile_1"><br>如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。<br>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>2）线程B到主内存中去读取线程A之前已更新过的共享变量。<br>这个模型在单线程中没有什么问题，但是在多线程中就会产生一些数据的“脏读”等问题。<br>举个简单的例子：在java中，使用两个线程执行下面这个语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>我们期望的是在两个线程执行完之后获得i的结果是2，但事实真的会这样的吗？<br>我们反复执行后可以发现：结果可能是2，也可能是1。<br>每条线程执行时需要将i的值从主内存中读取到工作内存中。其中存在这么一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的工作内存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。当出现这种情况后返回的结果就成了1了。<br>这就是缓存一致性的问题，在解决这个问题前我们要先了解一下并发编程的三个概念：原子性，有序性，可见性。</p>
<h2 id="二、并发编程中的三个概念"><a href="#二、并发编程中的三个概念" class="headerlink" title="二、并发编程中的三个概念"></a>二、并发编程中的三个概念</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>定义：原子操作意 为“不可被中断的一个或一系列操作。<br>比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。如果一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。<br>如果要实现更大范围操作的原子性，可以通过<strong>锁</strong>和<strong>CAS算法</strong>来实现。</p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>定义：可见性是指当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure></p>
<p>由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>定义：即程序执行的顺序按照代码的先后顺序执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。<br>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。<br>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：<br><img src="http://ou3np1yz4.bkt.clouddn.com/volatile_2.png" alt="volatile_2"><br>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line"></span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"></span><br><span class="line"> //线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">   sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。<br>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h2 id="三、深入理解volatile关键字"><a href="#三、深入理解volatile关键字" class="headerlink" title="三、深入理解volatile关键字"></a>三、深入理解volatile关键字</h2><p>　在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的 synchronized。如果volatile变量修饰符使用恰当 的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h3 id="1-volatile的作用"><a href="#1-volatile的作用" class="headerlink" title="1.volatile的作用"></a>1.volatile的作用</h3><p>　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>　　1）保证了内存的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>　　2）禁止进行指令重排序。</p>
<h3 id="1-volatile不能保证原子性"><a href="#1-volatile不能保证原子性" class="headerlink" title="1.volatile不能保证原子性"></a>1.volatile不能保证原子性</h3><p>我们来看下面这一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写”</span></span><br><span class="line"><span class="comment"> * 		  int i = 10;</span></span><br><span class="line"><span class="comment"> * 		  i = i++; //10</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		  int temp = i;</span></span><br><span class="line"><span class="comment"> * 		  i = i + 1;</span></span><br><span class="line"><span class="comment"> * 		  i = temp;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(getSerialNumber());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> serialNumber++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反复运行这段代码，发现结果并不是每次都是0-9,而是有可能会有重复结果出现。<br>自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行：<br>线程1对变量进行读取操作之后，被阻塞了的话，并没有对serialNumber值进行修改。虽然volatile能保证线程2对变量serialNumber的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。那么原子性问题究竟应该怎么解决呢？我们在下篇文章中会给出详细解答。</p>
<h2 id="四、volatile关键字的应用场景"><a href="#四、volatile关键字的应用场景" class="headerlink" title="四、volatile关键字的应用场景"></a>四、volatile关键字的应用场景</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>1）对变量的写操作不依赖于当前值<br>2）该变量没有包含在具有其他变量的不变式中</p>
<p>下面列举几个Java中使用volatile的几个场景。<br><strong>1.状态标记量</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">根据状态标记，终止线程。</span><br></pre></td></tr></table></figure></p>
<p><strong>2.单例模式中的double check</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么要使用volatile 修饰instance？<br>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:<br>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.baidu.com/s?wd=java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF&amp;rsv_spt=1&amp;rsv_iqid=0xc652b9a6000070c7&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;oq=java%25E5%25B9%25B6%25E5%258F%2591%25E7%25BC%2596%25E7%25A8%258B%25E7%259A%2584%25E8%2589%25BA%25E6%259C%25AFpdf&amp;inputT=1301&amp;rsv_t=9400ch8xJFe67WDXfsXzKSARdHHTqMDsYP9q4z0hVkvXwCg7TDPQj8n8kCqdXIhmXqYR&amp;rsv_pq=cec2174c00008def&amp;rsv_sug3=20&amp;rsv_sug4=1301" target="_blank" rel="noopener">《java并发编程的艺术》</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></li>
<li><a href="https://blog.csdn.net/it_dx/article/details/70045286?locationNum=4&amp;fps=1" target="_blank" rel="noopener">Java中volatile关键字详解（2）？真正了解volatile</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/helloVolatile/">http://catalinali.top/2018/helloVolatile/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> juc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> juc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(六)：服务降级（Hystrix）]]></title>
      <url>/2018/startHystrix/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hystrix_logo.jpg" alt="hystrix_logo"></p>
<blockquote>
<p>在微服务架构中，我们将系统拆分为很多个服务，各个服务之间通过注册与订阅的方式相互依赖，由于各个服务都是在各自的进程中运行，就有可能由于网络原因或者服务自身的问题导致调用故障或延迟，随着服务的积压，可能会导致服务崩溃。为了解决这一系列的问题，断路器等一系列服务保护机制出现了。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Hystrix简介"><a href="#一、Hystrix简介" class="headerlink" title="一、Hystrix简介"></a>一、Hystrix简介</h2><p>Netflix提供了一个叫Hystrix的类库，它实现了断路器模式。在微服务架构中，通常一个微服务会调用多个其他的微服务。一个相对低层级的服务失败可能造成上层应用的级联失败，服务访问量越大失败率越高。当断路打开的时候，这个调用就被终止了。打开的断路可以阻止级联失败。<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_1.png" alt="Hystrix_1"><br>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_2.png" alt="Hystrix_2"></p>
<h2 id="二、Hystrix使用"><a href="#二、Hystrix使用" class="headerlink" title="二、Hystrix使用"></a>二、Hystrix使用</h2><p>这里我们使用之前的Client项目进行演示。<br><strong>1.在服务调用方添加pom</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.添加@EnableCircuitBreaker注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="comment">//@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时我们发现我们的启动类上添加了很多的注解，所以Spring Cloud将这些注解封装了一下，提供了一个@SpringCloudApplication的注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public @interface SpringCloudApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.对要服务进行降级</strong><br>之前的例子里我们有一个<em>restHello</em>的接口,这个接口调用的Discovery的<em>hello</em>接口。<br>我们现在在他上面添加一个@HystrixCommand注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod  = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/restHello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用fallbackMethod属性指定一个fallback方法，在需要降级的时候调用这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">helloFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"哎呀，服务器开小差了！请稍后再试。"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们将服务端和客户端都启动进行访问<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_3.png" alt="Hystrix_3"><br>这时候我们将服务端Discover关掉然后再访问这个地址，他就会去访问降级的地址<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_4.png" alt="Hystrix_4"><br>这样我们就实现了服务降级。但是这样需要没一个接口都添加这个注解，有没有更快一点的方法呢？</p>
<p><strong>4.配置默认服务降级注解</strong><br>在类上添加@DefaultProperties注解配置默认的降级方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientController</span> </span>&#123;</span><br><span class="line">        <span class="comment">//@HystrixCommand(fallbackMethod  = "helloFallback")</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/restHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helloFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"哎呀，服务器开小差了！请稍后再试。"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们再进行刚才的操作，可以发现是同样的效果^_^<br><img src="http://ou3np1yz4.bkt.clouddn.com/Hystrix_4.png" alt="Hystrix_4"></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startHystrix/">http://catalinali.top/2018/startHystrix/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(五)：路由网关（Zuul）]]></title>
      <url>/2018/startZuul/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_logo.png" alt="zuul_logo"></p>
<blockquote>
<p>在微服务的架构下，各个服务一般会有各自的网络地址，在这样的情况下外部客户端的调用可能会形成杂乱无章的局面。这时候我们就可以使用微服务网关Zuul这个组件，我们让所有的客户端请求全部请求Zuul，再由Zuul统一的去请求各个服务。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Zuul简介"><a href="#一、Zuul简介" class="headerlink" title="一、Zuul简介"></a>一、Zuul简介</h2><p>Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：</p>
<ul>
<li>身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</li>
<li>审查与监控：</li>
<li>动态路由：动态将请求路由到不同后端集群</li>
<li>压力测试：逐渐增加指向集群的流量，以了解性能</li>
<li>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li>静态响应处理：边缘位置进行响应，避免转发到内部集群</li>
<li>多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化</li>
</ul>
<p>Spring Cloud对Zuul进行了整合和增强。目前，Zuul使用的默认是Apache的HTTP Client，也可以使用Rest Client，可以设置ribbon.restclient.enabled=true.。</p>
<h2 id="二、创建一个api-gateway工程"><a href="#二、创建一个api-gateway工程" class="headerlink" title="二、创建一个api-gateway工程"></a>二、创建一个api-gateway工程</h2><p>这里我们使用IntelliJ IDEA进行展示。<br><strong>1.首先创建一个Zuul项目</strong><br>使用IDEA创建一个项目<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_2.jpg" alt="eureka_2"><br>中间有一步我们选择Zuul选项和SpringBoot版本，如图<br><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_1.png" alt="eureka_2"><br>然后下一步就可以创建好了<br><strong>2.添加@EnableZuulProxy注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGetwayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGetwayApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在配置文件中添加config的配置，具体可以见<a href="http://catalinali.top/2018/startconfig/">小白学SpringCloud(三)：统一配置中心(config)</a>。然后就可以使用Zuul工程的路由了，依次运行Eureka、Config、Client客户端、Zuul。<br>我们先来随便访问一下client端的env接口<br><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_2.png" alt="zuul_2"><br>然后我们通过<em>zuul服务的端口+项目名/接口名</em>这种方式来访问一下这个接口<br><img src="http://ou3np1yz4.bkt.clouddn.com/zuul_3.png" alt="zuul_3"><br>可以看到,同样访问到了结果。<br>另外，我们也可以在配置文件中更加细粒度控制路由路径：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示只要HTTP请求是 /client1开始的，就会转发到服务id为client1的服务上面</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    client1:</span></span><br><span class="line"><span class="attr">      path:</span><span class="string">/client1/**</span>  <span class="string">//</span> <span class="string">路由路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">client1</span> <span class="string">//</span> <span class="string">服务id</span></span><br><span class="line"><span class="attr">    client2:</span></span><br><span class="line"><span class="attr">      path:</span><span class="string">/client2/**</span>  <span class="string">//</span> <span class="string">路由路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">client2</span> <span class="string">//</span> <span class="string">服务id</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，使用Zuul默认不会将Cookie的信息带入服务端，所以我们需要在配置文件中进行配置,将敏感头设置为空即可：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  sensitiveHeaders:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二、服务过滤"><a href="#二、服务过滤" class="headerlink" title="二、服务过滤"></a>二、服务过滤</h2><p>zuul不仅只是路由，并且还能过滤，做一些安全验证。我们来新建一个Filter并且继承ZuulFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_DECORATION_FILTER_ORDER;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: lllx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created on 17:54 2018/7/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modefied</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*返回一个字符串代表过滤器的类型</span></span><br><span class="line"><span class="comment">    pre：路由之前</span></span><br><span class="line"><span class="comment">    routing：路由之时</span></span><br><span class="line"><span class="comment">    post： 路由之后</span></span><br><span class="line"><span class="comment">    error：发送错误调用</span></span><br><span class="line"><span class="comment">    我们可以通过导入FilterConstants这个常量类中的属性来返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤的顺序，Zuul中也自定义了很多过滤器，调用的顺序即通过这个方法返回的大小，越小越靠前。我们可以通过FilterConstants这个常量类中定义好的过滤器-1来返回</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_DECORATION_FILTER_ORDER -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = requestContext.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从url参数获取如果没有token这个参数就不允许请求</span></span><br><span class="line">        String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            requestContext.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过这样的方式去自定义一个个的过滤器。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startZuul/">http://catalinali.top/2018/startZuul/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(四)：消息总线（Spring Cloud Bus）]]></title>
      <url>/2018/startbus/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/bus_logo.jpg" alt="bus_logo"></p>
<blockquote>
<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。上篇我们有说到Spring Cloud为我们提供了在不重启项目的情况下切换配置的功能，就要用到它，让我们来看看怎么实现的吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、安装MQ"><a href="#一、安装MQ" class="headerlink" title="一、安装MQ"></a>一、安装MQ</h2><p>Spring Cloud Bus支持常见的Rabbitmq、kafka、Activemq等。我们这里使用Rabbitmq来作为演示。Rabbitmq的安装这里就不作演示了，大家可以使用docker来安装使用，很方便。给大家一个度娘的<a href="https://www.baidu.com/s?wd=docker%E5%AE%89%E8%A3%85activemq&amp;rsv_spt=1&amp;rsv_iqid=0xf5578fe4000354b9&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;oq=docker%2520%25E5%25AE%2589%25E8%25A3%2585activemq&amp;inputT=1021&amp;rsv_t=11e21%2FaLzaFQGzuvMvLtKuHmxzuLUWS0TB6d8t9pETvwOEs%2B0fjRN9KsfhoNwJv1cAky&amp;rsv_pq=ef4e2567000322af&amp;sug=activemq&amp;rsv_sug3=21&amp;rsv_sug1=17&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=1751" target="_blank" rel="noopener">传送门</a>。</p>
<h2 id="二、Config-Server配置"><a href="#二、Config-Server配置" class="headerlink" title="二、Config Server配置"></a>二、Config Server配置</h2><p>这里我们还是以廖师兄的图为例，先来看看自动更新配置的原理(图中product、order均为客户端)。<br><img src="http://ou3np1yz4.bkt.clouddn.com/bus_1.png" alt="bus_1"><br>当我们在远端Git修改了配置之后，如果我们访问Config Server的<code>/bus-refresh</code>接口，Config Server就会把更改的配置发送给MQ，之后MQ就会把要改变的配置推送给各个客户端，这样就实现了自动更换配置的功能，现在我们来试一试吧。记住在这之前要先启动Rabbitmq。<br><strong>1.</strong>添加pom引用<br>老规矩，先来添加pom引用，要注意的是Config的Server和Client端都要添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong>修改配置文件<br>首先我们要先添加rabbitmq的配置，我们可以直接配置在远程git上面，这样服务端和客户端就都有这份配置了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="string">.xxx.xxx</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们也要显示的使我们的服务暴漏<code>/bus-refresh</code>接口。在Spring2.0中把这个接口都移动到了<em>actuator</em>下面。这个只需要在Config端进行配置就好了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">bus-refresh</span> <span class="comment">#也可以改为"*"来暴露所有接口</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们逐一启动我们的Eureka、Config和Client项目，同时在启动Config Server的时候可以看到我们对外暴露的接口<br><img src="http://ou3np1yz4.bkt.clouddn.com/bus_2.png" alt="bus_2"><br>这样我们就完成配置了，现在我们修改一下远端配置中的<code>env</code>的值，然后访问一下这个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8764/actuator/bus-refresh</span><br></pre></td></tr></table></figure></p>
<p>这时候我们发现在不重启项目的情况下，我们的配置已经修改了。<br><strong>3.</strong>配置Webhook<br>刚才我们已经实现了自动替换项目配置，但是我们每次更改配置都要手动访问<code>/bus-refresh</code>接口，有没有简单的方式呢?答案当然是有的。现在大部分远端Git都提供了webhook功能，即我们每更改一次配置，就自动向某一接口发送一次请求。这不就是我们想要的吗？</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startbus/">http://catalinali.top/2018/startbus/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(三)：统一配置中心(config)]]></title>
      <url>/2018/startconfig/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/config_logo.png" alt="config_logo"></p>
<blockquote>
<p>在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成。如果我们每个服务都有一个独立的配置的话，这样很不方便我们维护。Spring Cloud中为我们提供了一个config组件为我们解决了这个问题，并且更改了配置并不需要我们重启。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Config概述"><a href="#一、Config概述" class="headerlink" title="一、Config概述"></a>一、Config概述</h2><p>同Eureka一样，config也分为server端和client端，我们先来看看server端的原理。这里引用一张廖师兄的图（注：图中的order、product都是客户端）<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_1.png" alt="config_1"><br>从这张图我们可以看出，Config Server是以远端Git作为依托（SVN也可以,这里使用Github作为演示），从远端Git仓库中拉取配置并同步到本地Git上。当客户端需要配置的时候就可以从Server端进行配置的拉取。</p>
<h2 id="二、Config-Server配置"><a href="#二、Config-Server配置" class="headerlink" title="二、Config Server配置"></a>二、Config Server配置</h2><p><strong>1.</strong>创建Config工程<br>跟前文一样，我们使用IDEA的Spring Initializr创建我们的Config工程，如图:除了图中圈起来的config Server要勾上，Eureka Discover也要勾上。<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_2.png" alt="config_2"></p>
<p><strong>2.</strong>创建远程仓库<br>首先我们先创建一个远程Git仓库，这里以Github为例，这里我已经创建好了一个公开仓库<a href="https://github.com/catalinaLi/config_repo" target="_blank" rel="noopener">https://github.com/catalinaLi/config_repo</a><br>然后在里面先添加一份配置<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_6.png" alt="config_3"><br><strong>3.</strong>配置Config工程<br>将我们的Config工程注册到Eureka注册中心：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8764</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/catalinaLi/config_repo</span> <span class="comment">#config_Server仓库地址</span></span><br><span class="line">          <span class="comment">#如果我们配置的是私有仓库，则还需要远程仓库的账号和密码</span></span><br><span class="line">          <span class="comment">#username: yourusername  </span></span><br><span class="line">          <span class="comment">#password: yourpassword</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="string">dev</span></span><br></pre></td></tr></table></figure></p>
<p>然后在启动类上添加注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.</strong> Config Server配置<br>接下来就可以通过网络来访问我们的配置了，首先启动注册中心Eureka，然后启动我们的Config。这时候我们通过浏览器访问<a href="http://localhost:8764/client-dev.yml" target="_blank" rel="noopener">http://localhost:8764/client-dev.yml</a>就可以看到我们的配置了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/config_5.png" alt="config_5"><br>这里是Spring Cloud对配置请求的路径做了映射,通常为：</p>
<ul>
<li>/{name}-{profiles}.yml</li>
<li>/{label}/{name}-{profiles}.yml</li>
</ul>
<p>这两种方式大家可以挑选一个适合你的。<br>后缀名也可以不是yml，你可以试试properties，json。Spring Cloud会自动帮你转换。</p>
<h2 id="三、Config-Client配置"><a href="#三、Config-Client配置" class="headerlink" title="三、Config Client配置"></a>三、Config Client配置</h2><p>这里我们使用上一篇文章<a href="http://catalinali.top/2018/startfeignRest/">小白SpringCloud(二)：服务间的调用</a>中的Client项目来进行改造<br><strong>1.添加pom引用</strong><br>在FeignClient的pom文件中添加Config Client引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.修改配置文件</strong><br>首先我们要把配置文件的名字改为<strong>bootstrap.yml</strong>，改成这个名字Spring Cloud就会先去Config Server拉取配置。<br>然后我们要在bootstrap.yml中定义我们要拉取的文件名称，还记得刚才说的Spring Cloud对请求的路径做的映射方式吗(/{name}-{profiles}.yml)？在这里我们配置<em>name</em>、<em>profiles</em>和<em>Config项目的名称</em></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#name</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">config</span> <span class="comment">#Eureka Config's name</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span> <span class="comment">#profiles</span></span><br></pre></td></tr></table></figure>
<p>这时候，我们的Client就可以正常启动啦，怎么样简单吧。</p>
<h2 id="二、Config-Server的高可用"><a href="#二、Config-Server的高可用" class="headerlink" title="二、Config Server的高可用"></a>二、Config Server的高可用</h2><p>统一配置中心的高可用很简单，只需要我们多启动几个相同的实例就好了。Config Client在启动的时候会根据负载均衡去访问Config Server中的某一台.</p>
<p>还记得导语中说的更改配置可以不用重新启动项目吗？这里需要用到另外一个组件，我们在下篇文章进行讲解。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startconfig/">http://catalinali.top/2018/startconfig/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(二)：服务间的调用]]></title>
      <url>/2018/startfeignRest/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_logo.png" alt="feign&amp;Rest_logo"></p>
<blockquote>
<p>SpringCloud服务间的调用有两种方式：RestTemplate和FeignClient。不管是什么方式，他都是通过REST接口调用服务的http接口，参数和结果默认都是通过jackson序列化和反序列化。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、Ribbon简介"><a href="#一、Ribbon简介" class="headerlink" title="一、Ribbon简介"></a>一、Ribbon简介</h2><p>在说这两种方式之前，我们先来简单的看一下Ribbon。</p>
<blockquote>
<p>Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.</p>
</blockquote>
<p>这是官网对Ribbon的简介，简单的说Ribbon是一个负载均衡客户端，SpringCloud的两种服务间调用方式背后都用了Ribbon。</p>
<h2 id="二、使用RestTemplate进行服务调用"><a href="#二、使用RestTemplate进行服务调用" class="headerlink" title="二、使用RestTemplate进行服务调用"></a>二、使用RestTemplate进行服务调用</h2><p>代码Demo接上篇<a href="http://catalinali.top/2018/startEureka/">SpringCloud(一)：服务的注册与发现（Eureka）</a><br><strong>1.</strong>我们首先启动端口为8761的eureka工程，把SpringCloud的服务注册中心启动。</p>
<p><strong>2.</strong>打开我们的Discovery工程。这时候Discovery工程相当于服务端，我们来为它写一个提供服务的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello! 我是"</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后将配置文件中的端口改为8762和8763分别启动。<br>如果你使用的是IDEA的话，只需要去掉下图中红框框住的部分就可以将同一工程启动多个实例<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_1.png" alt="Rest_1"><br>这时，我们就拥有了端口为8762和8763的两个Discovery集群，Eureka中可以看到<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_2.png" alt="feign&amp;Rest_2"><br><strong>3.</strong>我们再新建一个Eureka-Discovery工程（可以参照上一篇文章），首先为他配置好Eureka-Client的配置。在配置文件中为它指定端口为8764：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8764</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#客户端名称</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们为它添加一个RestTemplate的配置Bean，可以参照如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后我们就可以在需要调用的地方用如下方式进行调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cliHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CliHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数为：服务端的应用名称/调用接口的Mapping</span></span><br><span class="line">        <span class="comment">//第二个参数为返回的类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://discovery/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如图：<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_3.png" alt="feign&amp;Rest_3"><br>这里因为Ribbon的默认负载均衡方式为轮询，所以我们可以看到端口8762和8763依次出现。如果有想改变负载均衡方式的小伙伴可以下去自行研究一下，这里就不过多赘述了。</p>
<h2 id="三、使用Feign进行服务调用"><a href="#三、使用Feign进行服务调用" class="headerlink" title="三、使用Feign进行服务调用"></a>三、使用Feign进行服务调用</h2><p><strong>1.添加Feign的pom引用</strong><br>在FeignClient的pom文件中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是版本一定要跟我的一致，否则添加的依赖有可能会不一样<br><strong>2.为启动类添加注解</strong><br>这一步很简单，只需要在在启动类上添加<code>@EnableFeignClients</code>注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class ClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.定义一个Feign接口</strong><br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name是服务端的名称</span></span><br><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"discovery"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url是调用服务的url值</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.调用</strong><br>在配置了Feign接口后，我们就可以直接进行注入调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/feignHello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">feignHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloClient.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的结果跟RestTemplate也相同<br><img src="http://ou3np1yz4.bkt.clouddn.com/feign&amp;Rest_3.png" alt="feign&amp;Rest_3_1"><br>从这里我们可以看到，使用Feign是伪分布式的调用方式。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startfeign&amp;Rest/">http://catalinali.top/2018/startfeign&amp;Rest/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白学SpringCloud(一)：服务的注册与发现（Eureka）]]></title>
      <url>/2018/startEureka/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_logo1.jpg" alt="eureka_logo"></p>
<a id="more"></a>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>首先我们先引用Dubbo官网的一段话</p>
<ul>
<li>单一应用架构<br>  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>  此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</li>
<li>垂直应用架构<br>  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>  此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</li>
<li>分布式服务架构<br>  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中 心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</li>
<li>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA) 是关键。</li>
</ul>
<p>结合现在大火的微服务，SpringCloud成了炙手可热的微服务架构方案，这里我们介绍一个他的核心组件：Eureka ,eureka是一个服务注册和发现模块。类似于Dubbo的管控台。它分为两个模块:客户端和服务端</p>
<h2 id="二、创建一个Eureka-Server"><a href="#二、创建一个Eureka-Server" class="headerlink" title="二、创建一个Eureka Server"></a>二、创建一个Eureka Server</h2><p>这里我们使用IntelliJ IDEA进行展示。这里SpringBoot我们统一使用2.0.2版本,SpringCloud使用Finchley.RELEASE版本<br><strong>1.首先创建一个Eureka Server</strong><br>使用IDEA创建一个项目<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_2.jpg" alt="eureka_2"><br>中间有一步我们选择Eureka Server选项和SpringBoot版本，如图<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_3.jpg" alt="eureka_2"><br>然后下一步就可以创建好了<br><strong>2.添加@EnableEurekaServer注解</strong><br>这个注解只需要在springboot工程的启动application类上就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们就可以启动了，运行EurekaApplication，然后就输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>就可以看到我们Eureka的页面了。但这时候我们观察console可以发现一直在报错，这是因为默认情况下Eureka Server也是一个Client,我们需要通过配置来解决这个问题<br><strong>3.添加配置</strong><br>eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个server。eureka server的配置文件appication.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka</span> <span class="comment">#应用的名称</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">    <span class="comment"># 通过添加配置我们这里忽略自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#表示是否注册自身到eureka服务器</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment">#表示是否从eureka服务器获取注册信息</span></span><br></pre></td></tr></table></figure></p>
<p>这时候再启动应用，就大功告成了<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_4.jpg" alt="eureka_4"></p>
<h2 id="三、创建一个Eureka-Client"><a href="#三、创建一个Eureka-Client" class="headerlink" title="三、创建一个Eureka Client"></a>三、创建一个Eureka Client</h2><p><strong>1.运行Eureka Server</strong><br>这里我们可以使用命令行在Eureka Server的目录位置使用<code>mvn clean package</code>来进行打包<br>然后使用<code>java -jar target/eureka-0.0.1-SNAPSHOT.jar</code>命令来进行启动jar包<br>也可以使用<code>nohup java -jar target/eureka-0.0.1-SNAPSHOT.jar &amp;</code>来后台启动这个jar。<br>最后刷新Eureka Server来判断是否启动成功<br><strong>2.创建一个Eureka Client</strong><br>这一步跟创建Server端的步骤是一样的，不同的是模板选择Discovery<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_5.jpg" alt="eureka_5"><br><strong>3.添加@EnableEurekaServer注解和服务端地址</strong><br>基本和服务端的做法一样，首先我们在DicoveryApplication.java的代码上添加@EnableDiscoveryClient注解。然后在application.yml上添加配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DicoveryApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DicoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span> <span class="comment">#服务端地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span> <span class="comment">#客户端端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">client</span> <span class="comment">#客户端名称</span></span><br></pre></td></tr></table></figure>
<p>注意了，这个版本我们需要在pom文件中添加<code>spring-boot-starter-web</code>的依赖，<br>这时候我们就可以启动我们的服务了，然后就可以在eureka的页面上看到我们刚才的Client了<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_6.jpg" alt="eureka_6"></p>
<h2 id="三、Eureka-Server的高可用"><a href="#三、Eureka-Server的高可用" class="headerlink" title="三、Eureka Server的高可用"></a>三、Eureka Server的高可用</h2><p>简单的说，实现Eureka Server的高可用就是让Eureka Server的实例互相注册。<br>让我们来看一下如何实现：<br>首先我们配置文件中这样写<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">discovery-cluster</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">discovery1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">discovery1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      default-zone:</span> <span class="attr">http://discovery2:8762/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">discovery2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">discovery2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      default-zone:</span> <span class="attr">http://discovery1:8761/eureka</span></span><br></pre></td></tr></table></figure></p>
<p>配置文件是通过两个Eureka Server互相注册，这里有三段配置，第一段配置为公共配置，配置了应用名称，第二段为名discovery1的配置，第三段为discovery2的配置。在项目启动可以通过–spring.profiles.active={配置名称} 来启动不同的配置。<br>下面我们来进行测试：<br>1）在discovery-cluster目录下，使用<code>mvn clean package</code>打包项目<br>2）使用下面命令启动两个Eureka Server节点<br><code>java -jar discovery-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=discovery1</code></p>
<p><code>java -jar discovery-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=discovery2</code><br>3）在浏览器上分别输入<a href="http://localhost:8761和http://localhost:8762查看注册的服务。" target="_blank" rel="noopener">http://localhost:8761和http://localhost:8762查看注册的服务。</a><br>这时候我们可以发现两个网址都可以访问Eueka页面<br><img src="http://ou3np1yz4.bkt.clouddn.com/eureka_7.jpg" alt="eureka_7"><br>这样我们就大功告成了，如我们我们的实例有3个，那就在配置文件中都写入<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">   client:</span></span><br><span class="line"><span class="attr">      service-url:</span></span><br><span class="line"><span class="attr">          default-zone:</span><span class="attr">http://discovery1:8761/eureka,http://discovery2:8762/eureka</span></span><br></pre></td></tr></table></figure></p>
<p>以上，就是Eureka的基本用法了！</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/startfeign&amp;Rest/">http://catalinali.top/2018/startfeign&amp;Rest/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在同一台电脑上使用github和gitlab]]></title>
      <url>/2018/noteGithubGitlab/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/gitlabgithub_logo.jpg" alt="gitlabgithub_logo"></p>
<blockquote>
<p>换了工作后使用的是gitlab，这样对github的使用会有影响。为了解决这个问题，搜了很多资料后完美解决。现在把它记录下来。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在同一台电脑上使用github和gitlab，主要的思想就是使用不同的仓库时，切换成不同的账号。不同账号的sshKey分别对应github和gitlab。接下来跟着我看看怎么做吧^_^</p>
<h2 id="一、生成ssh密钥"><a href="#一、生成ssh密钥" class="headerlink" title="一、生成ssh密钥"></a>一、生成ssh密钥</h2><p>这里我们要做的事情就是分别对githubn和gitlab生成对应的密钥（默认情况下本地生成的秘钥位于/Users/用户名/.ssh/），并且配置git访问不同host时访问不同的密钥，流程如下：<br><strong>1、</strong> 在gitbash中使用<code>ssh-keygen -t rsa -C &quot;公司邮箱地址&quot;</code>生成对应的gitlab密钥：<em>id_rsa</em>和<em>id_rsa.pub</em><br><strong>2、</strong> 将gitlab公钥即<em>id_rsa.pub</em>中的内容配置到公司的gitlab上<br><strong>3、</strong> 在gitbash中使用<code>ssh-keygen -t rsa -C &quot;github地址&quot; -f ~/.ssh/github_rsa</code>生成对应的github密钥：<em>github_rsa</em>和<em>github_rsa.pub</em><br><strong>4、</strong> 将github公钥即<em>github_rsa.pub</em>中的内容配置到自己的github上<br><strong>5、</strong> 进入密钥生成的位置，创建一个<code>config</code>文件，添加配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line"><span class="string">Host</span> <span class="string">gitlab</span></span><br><span class="line">	<span class="string">HostName</span> <span class="string">git.xxx.com</span> <span class="comment">#这里填你的gitlab的Host</span></span><br><span class="line">	<span class="string">User</span> <span class="string">git</span></span><br><span class="line">	<span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="comment"># githab</span></span><br><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">	<span class="string">HostName</span> <span class="string">github.com</span></span><br><span class="line">	<span class="string">User</span> <span class="string">git</span></span><br><span class="line">	<span class="string">IdentityFile</span> <span class="string">~/.ssh/github_rsa</span></span><br></pre></td></tr></table></figure>
<h2 id="二、测试连接"><a href="#二、测试连接" class="headerlink" title="二、测试连接"></a>二、测试连接</h2><p>在密钥的生成位置/Users/用户名/.ssh/下使用gitbash运行<code>ssh -T git@hostName</code>命令测试sshkey对gitlab与github的连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catalinaLi@catalinaLi MINGW64 ~/.ssh</span><br><span class="line">$ ssh -T git@gitlab</span><br><span class="line">Welcome to GitLab, catalinaLi!</span><br><span class="line"></span><br><span class="line">catalinaLi@catalinaLi MINGW64 ~/.ssh</span><br><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi catalinaLi! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>如果出现上图结果就说明连接成功，如果不是这样的话就仔细看看第一步哪里做错了。</p>
<h2 id="三、配置git仓库"><a href="#三、配置git仓库" class="headerlink" title="三、配置git仓库"></a>三、配置git仓库</h2><p>这里我们要用到git的config配置。git的config文件记录了用户的基本信息，我们的账号信息也在里面，这里我们要做的就行在不同的本地仓库配置不同的用户信息来访问不同的远程仓库。config文件通常有三个位置：</p>
<ul>
<li>system （系统级别）：<br>  位于Windows下在git的安装目录， 包含了适用于系统所有用户和所有库的值。如果你传递参数选项’–system’ 给 git config，它将明确的读和写这个文件。 </li>
<li>global（用户级别）:<br>  位于~/.gitconfig，具体到你的用户。你可以通过传递–global 选项使Git 读或写这个特定的文件。</li>
<li>local（仓库级别）：<br>  位于 .git/config，无论你当前在用的库是什么，特定指向该单一的库。每个级别重写前一个级别的值。</li>
</ul>
<p>简单了解后我们就可以来配置了</p>
<p><strong>1.</strong> 用户级别配置<br>因为公司的代码使用频率较高，所以我们将git配置文件的global（用户级别）设置为公司的gitlab账号,在gitlab中使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &apos;catalinaLi&apos; #公司账号名称</span><br><span class="line">$ git config --global user.email &apos;catalinaLi@companyName.com&apos; #公司账号邮箱</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 仓库级别配置<br>我们将local（仓库级别）配置成github的账号。此时我们需要先<strong>init</strong>一个git的仓库并进入里面后执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --local user.name &apos;username&apos; #github账号名称</span><br><span class="line">$ git config --local user.email &apos;username@gmail.com&apos; #github账号邮箱</span><br></pre></td></tr></table></figure>
<p>之后我们github的代码都应该在这个仓库下拉取。</p>
<p><strong>3.</strong> 克隆代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:catalinaLi/ideaTaotao.git</span><br></pre></td></tr></table></figure>
<p>在使用github克隆代码时，因为配置了config, 所以会通过配置的host自动查找到git@github.com。对于gitlab也是相同的道理</p>
<p>至此，在同一台电脑上使用gitlab与github已经成功了，尽情感受吧。另外，大家可以寻找<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=git%20config&amp;oq=git%25E5%259B%25BE%25E7%2589%2587&amp;rsv_pq=8af24b1f00001879&amp;rsv_t=f935uktxm1WFti3L2TeFRHq8XdFpo%2B3%2FcGp%2F14sVbaYetcqU4uCbhZ5DCCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;inputT=1397&amp;rsv_sug3=14&amp;rsv_sug1=18&amp;rsv_sug7=100&amp;bs=git%E5%9B%BE%E7%89%87" target="_blank" rel="noopener">度娘</a>来学习关于git的config的更多使用</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.arccode.net/config-multi-git-account-and-workspaces.html" target="_blank" rel="noopener">http://www.arccode.net/config-multi-git-account-and-workspaces.html</a><br><a href="https://segmentfault.com/a/1190000002994742" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002994742</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/noteGithubGitlab/">http://catalinali.top/2018/noteGithubGitlab/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[笔记：使用hexo，如果换了电脑怎么更新博客]]></title>
      <url>/2018/noteHexoBak/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/note_hexo_install_logo.jpg" alt="note_hexo_install_logo"></p>
<blockquote>
<p>最近换了工作，忙着熟悉业务，好久没写博客了。换了新环境，好多东西都要重装。Hexo博客就是其中之一，这里我从万能的知乎上找了一个感觉很赞的方法，现在把文章搬运过来。话不多说，我们快来看看他是怎么做吧。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。但是考虑到如果每个GitHub Pages都需要额外的一个仓库存放这些文件，就显得特别冗余了。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。</p>
<h2 id="二、搭建的流程"><a href="#二、搭建的流程" class="headerlink" title="二、搭建的流程"></a>二、搭建的流程</h2><p><strong>1.</strong> 创建仓库，<a href="http://catalinaLi.github.io；" target="_blank" rel="noopener">http://catalinaLi.github.io；</a><br><strong>2.</strong> 创建两个分支：master 与 hexo；<br><strong>3.</strong> 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br><strong>4.</strong> 使用git clone git@github.com:catalinaLi/catalinaLi.github.io.git拷贝仓库；<br><strong>5.</strong> 在本地<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br><strong>6.</strong> 修改_config.yml中的deploy参数，分支应为master；<br><strong>7.</strong> 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；<br><strong>8.</strong> 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！</p>
<h2 id="三、日常的改动流程"><a href="#三、日常的改动流程" class="headerlink" title="三、日常的改动流程"></a>三、日常的改动流程</h2><p>在本地对博客进行修改、添加新博文、修改样式等等可以参照以下流程：<br><strong>1.</strong> 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；<br><strong>2.</strong> 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>
<h2 id="四、拉取备份"><a href="#四、拉取备份" class="headerlink" title="四、拉取备份"></a>四、拉取备份</h2><p>本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：<br><strong>1.</strong> 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；<br><strong>2.</strong> 在本地新拷贝的<a href="http://catalinaLi.github.io" target="_blank" rel="noopener">http://catalinaLi.github.io</a> 文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></li>
</ul>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/noteHexoBak/">http://catalinali.top/2018/noteHexoBak/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> note </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信开发之微信网页授权获取openid]]></title>
      <url>/2018/wechatOAuth/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_logo.jpg" alt="wechatOAuth_logo"></p>
<blockquote>
<p>不知觉间已经接触了几次微信支付开发，而要进行微信支付就需要用户的唯一标识:openid。还记得第一次获取用户openid的时候就踩了很多坑。这两天又接触了一下，想着索性就把他记录下来，也便于以后查阅</p>
</blockquote>
<a id="more"></a>
<h2 id="一、准备工具"><a href="#一、准备工具" class="headerlink" title="一、准备工具"></a>一、准备工具</h2><p>不管开发什么，官方的文档应该是第一个想到的这里把官方文档贴出来：<strong><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信网页授权文档</a></strong><br>除此之外，我们还需要一个<strong>内网穿透</strong>的工具在开发环境下让微信能访问到我们的域名。我使用的是natapp。此类工具网上有很多，大家可以自行寻找。<br>这里我们使用微信提供的<strong><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">测试账号</a></strong>来作为演示</p>
<h2 id="二、开始开发"><a href="#二、开始开发" class="headerlink" title="二、开始开发"></a>二、开始开发</h2><p>内网穿透就不在这里演示了，下面我们直入主题：<br><strong>1.填写网页授权域名</strong><br>在这篇文档的一开始就埋了一个坑<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_1.png" alt="wechatOAuth_1"><br>这段话就是说，我们在开发前需要在图片中框红的位置填入我们所要开发的域名。这里我们使用的是测试环境，所以需要在测试账号管理页面的这个位置填入我们自己的域名,这里要注意填入域名的规则。<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_2.png" alt="wechatOAuth_2"><br><strong>2.文档阅读</strong><br>接着阅读文档我们可以发现网页授权有两种scope,<br>snsapi_base和snsapi_userinfo。两种scope都可以获取到opeid，不同的是snsapi_userinfo除了openid外还可以获取到用户的基本信息，但是需要用户手动进行确认。<br>再往下阅读我们可以看到官方文档的授权步骤</p>
<ul>
<li>第一步：用户同意授权，获取code</li>
<li>第二步：通过code换取网页授权access_token以及openid</li>
<li>第三步：刷新access_token（如果需要）</li>
<li>第四步：拉取用户信息(需scope为 snsapi_userinfo)</li>
</ul>
<p>我们只需要openid，所以我们只开发到第二步就好了。下面我们就按着官方步骤来开发。</p>
<p><strong>3.获取code</strong><br>查看文档后我们发现我们需要拼接一个url并且访问它。url的参数文档中写的很清楚了。看他的例子也能看个清楚。这里比较重要的是redirect_uri。这个参数所填的是一个链接。我们访问url后会自动转发到这个链接并且将我们需要的code以及拼接url中的state的值作为参数。这个redirect_uri的值要填入的是我们代码中的controller的位置。<br>所以这里我们需要一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: wechat OAuth2.0</span></span><br><span class="line"><span class="comment"> * Author:		lllx</span></span><br><span class="line"><span class="comment"> * Version:		1.0</span></span><br><span class="line"><span class="comment"> * Created at:	2018/2/1</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/weixin"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code,@<span class="title">RequestParam</span><span class="params">(<span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"auth开始了。。。。"</span>);</span><br><span class="line">        log.info(<span class="string">"code=&#123;&#125;"</span>,code);</span><br><span class="line">        log.info(<span class="string">"state=&#123;&#125;"</span>,state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我拼接的url，这里大家要注意根据自己的情况进行拼接。拼接成功后需要在<strong>微信app</strong>中进行访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxx&amp;redirect_uri=http://xxx/sell/weixin/auth&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect</span><br></pre></td></tr></table></figure></p>
<p>访问后的结果<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_3.png" alt="wechatOAuth_3"><br>这样我们就拿到了code<br><strong>4.获取openid</strong><br>继续查看文档，发现我们只需要使用获取到的code再访问另一个url就可以获取到我们想要的了。接着上面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: wechat OAuth2.0</span></span><br><span class="line"><span class="comment"> * Author:		lllx</span></span><br><span class="line"><span class="comment"> * Version:		1.0</span></span><br><span class="line"><span class="comment"> * Created at:	2018/2/1</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/weixin"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code,@<span class="title">RequestParam</span><span class="params">(<span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"auth开始了。。。。"</span>);</span><br><span class="line">        log.info(<span class="string">"code=&#123;&#125;"</span>,code);</span><br><span class="line">        log.info(<span class="string">"state=&#123;&#125;"</span>,state);</span><br><span class="line">        String url = <span class="string">"https://api.weixin.qq.com/sns/oauth2/access_token?appid=xxxx&amp;secret=xxxx&amp;code="</span>+code+<span class="string">"&amp;grant_type=authorization_code"</span>;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String result = restTemplate.getForObject(url, String.class);</span><br><span class="line">        log.info(<span class="string">"result=&#123;&#125;"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时我们再次访问第三步拼接的url就可以看到如下结果。<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_4.png" alt="wechatOAuth_4"><br>将结果格式化一下我们可以就看到我们想要的openid<br><img src="http://ou3np1yz4.bkt.clouddn.com/wechatOAuth_5.png" alt="wechatOAuth_5"></p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>流程看起来还是很简单的。但以上只是一个最简单、最直接的手工获取openid的例子。真正在使用过程中需要结合自身的业务流程来进行开发，这时可能就有些麻烦了。此时我们也可以借助一些网上第三方sdk来开发。例如:weixin-java-tools。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/wechatOAuth/">http://catalinali.top/2018/wechatOAuth/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> wechat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wechat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用IDEA搭建第一个SpringBoot程序]]></title>
      <url>/2018/startSpringBoot/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_logo.jpg" alt="startSpringBoot_logo"></p>
<blockquote>
<p>近来在研究SpringBoot的使用，现在把使用IDEA搭建一个SpringBoot的HelloWorld程序记录下来</p>
</blockquote>
<a id="more"></a>
<h2 id="新建一个SpringBoot环境"><a href="#新建一个SpringBoot环境" class="headerlink" title="新建一个SpringBoot环境"></a>新建一个SpringBoot环境</h2><p>打开你的IntelliJ IDEA，然后选择Create New Project。如图，我们要选择一个Spring Initializr<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_1.png" alt="startSpringBoot_1"><br>之后我们填入自己的Group与Artifact(项目名字)后选择Next<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_2.png" alt="startSpringBoot_2"><br>由于我们是Web项目，所以我们先勾选最基本的Web选项，其他的待我们用到了再勾选。<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_3.png" alt="startSpringBoot_3"><br>接下来是选择项目存放的位置<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_4.png" alt="startSpringBoot_4"><br>选择Finish之后静静等待IEAD加载索引搭建工程。OK，一个完整的SpringBoot项目的结构我们已经搭建好了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_5.png" alt="startSpringBoot_5"><br>上图我用红框圈住的可以删掉，保持项目的简洁。这样，一个可供使用的SpringBoot环境就搭好了。</p>
<h2 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h2><p>使用SpringBoot可以让你快速搭建一个SpringWeb项目，它使用“习惯优于配置”的理念让你的项目快速运行起来。使用SpringBoot可以很容易创建一个独立运行（运行jar，内嵌Servlet容器）、准生产级别的基于Spring框架的项目。使用SpringBoot你可以不用或者是很少的配置。<br>使用SpringBoot的优点：</p>
<ul>
<li>快速构建项;</li>
<li>对主流开发框架的无配罝集成；</li>
<li>项目可独立运行，无须外部依赖Servlet容器；</li>
<li>提供运行时的应用监控；</li>
<li>极大地提髙了开发、部署效率；</li>
<li>与云计算的天然集成。<h2 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h2>我们来写一个SpringBoot的HelloWorld<br>打开项目自动生成的DemoApplication类，修改代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"hello world！"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后右键选择Run<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_7.png" alt="startSpringBoot_7"><br>然后打开浏览器访问<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a>就可以看到我们写的HelloWorld<br><img src="http://ou3np1yz4.bkt.clouddn.com/startSpringBoot_8.png" alt="startSpringBoot_8"><br><strong>代码说明：</strong><br>1、@SpringBootApplication：Spring Boot项目的核心注解，主要目的是开启自动配置。；<br>2、@Configuration：这是一个配置Spring的配置类；<br>3、@Controller：标明这是一个SpringMVC的Controller控制器；<br>4、main方法：在main方法中启动一个应用，即：这个应用的入口；</p>
<p>这次只是记录了一下搭建SpringBoot的HelloWorld过程。具体的SpringBoot知识还需要大家去深入学习</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/startSpringBoot/">http://catalinali.top/2017/startSpringBoot/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JSONP解决ajax跨域]]></title>
      <url>/2018/useJSONP/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/jsonp_logo.jpg" alt="jsonp_logo"></p>
<blockquote>
<p>在日常开发中，不免遇到跨域的问题。在这里我们介绍使用Jsonp来解决ajax跨域的问题。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域?"></a>什么是跨域?</h2><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。简单的理解就是开发时当客户端所在的工程与服务端的ip不同或者端口不同时进行请求，就产生了跨域，进而不能请求数据。</p>
<h2 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP?"></a>什么是JSONP?</h2><p>官方的说法是:JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。<br>我们都知道，JSON是一种数据交换格式。而JSONP是一种的数据调用方式。它利用&lt;script&gt;标签可以跨域的特性，将需要跨域获取的数据包在&lt;script&gt;标签中来达到目的。当我们需要使用JSONP时，客户端调用服务端时传递一个callback，这样服务端根据callback的有无就可以判断是否需要使用JSONP。可以简单的理解为带callback的json就是jsonp。</p>
<h2 id="JSONP的使用"><a href="#JSONP的使用" class="headerlink" title="JSONP的使用"></a>JSONP的使用</h2><p>AJAX的使用与平常无异，只需要将dataType改为jsonp即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	url : url,</span><br><span class="line">	dataType : <span class="string">"jsonp"</span>,</span><br><span class="line">	type : <span class="string">"GET"</span>,</span><br><span class="line">	success : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">              ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>服务端接收到以后，只需要手动判断一下有无callback再手动拼一对括号即可,这里以java为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"xxx"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testJsonp</span><span class="params">(String callback)</span> </span>&#123;</span><br><span class="line">	Student result = <span class="keyword">new</span> Student();</span><br><span class="line">	<span class="comment">//响应结果之前，判断是否为jsonp请求</span></span><br><span class="line">	<span class="keyword">if</span> (StringUtils.isNotBlank(callback)) &#123;</span><br><span class="line">		<span class="comment">//把结果封装成一个js语句响应</span></span><br><span class="line">		<span class="keyword">return</span> callback + <span class="string">"("</span> + JsonUtils.objectToJson(result)  + <span class="string">");"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> JsonUtils.objectToJson(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Spring 4.1以上的版本也可以使用MappingJacksonValue来响应<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"xxx"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">testJsonp</span><span class="params">(String callback)</span> </span>&#123;</span><br><span class="line">    Student result = <span class="keyword">new</span> Student();</span><br><span class="line">	<span class="comment">//响应结果之前，判断是否为jsonp请求</span></span><br><span class="line">	<span class="keyword">if</span> (StringUtils.isNotBlank(callback)) &#123;</span><br><span class="line">		<span class="comment">//把结果封装成一个js语句响应</span></span><br><span class="line">		MappingJacksonValue mappingJacksonValue = <span class="keyword">new</span> MappingJacksonValue(result);</span><br><span class="line">		mappingJacksonValue.setJsonpFunction(callback);</span><br><span class="line">		<span class="keyword">return</span> mappingJacksonValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么样，简单几步就可以跨域来访问服务端了。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2018/useJSONP/">http://catalinali.top/2018/useJSONP/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> jsonp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jsonp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ActiveMQ从入门到实践]]></title>
      <url>/2017/useMQ/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/mq_logo.jpg" alt="mq_logo"><br><a id="more"></a></p>
<h2 id="一、什么是ActiveMQ"><a href="#一、什么是ActiveMQ" class="headerlink" title="一、什么是ActiveMQ"></a>一、什么是ActiveMQ</h2><p>首先我们应该先了解J2EE中的一个重要规范：JMS(The Java Message Service)Java消息服务。而JMS的客户端之间可以通过JMS服务进行异步的消息传输。它主要有两种模型：点对点和发布订阅模型。</p>
<p><strong>点对点的模型特点：</strong>：</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)。</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列。</li>
<li>接收者在成功接收消息之后需向队列应答成功。</li>
</ul>
<p><strong>发布订阅模型特点：</strong></p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li>
<li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li>
</ul>
<p>JMS还定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java原始值的数据流</li>
<li>MapMessage–一套名称-值对</li>
<li>TextMessage–一个字符串对象</li>
<li>ObjectMessage–一个序列化的 Java对象</li>
<li>BytesMessage–一个字节的数据流</li>
</ul>
<p>其中我们用的最多的就是TextMessage字符串对象</p>
<p>消息中间件作为JMS的实现，在J2EE的企业应用中扮演着特殊的角色。ActiveMQ是一个易于使用的消息中间件。作为JMS的实现，消息中间件的使用步骤都大同小异，下面我们以ActiveMQ为例来介绍一下其使用。</p>
<h2 id="二、ActiveMQ的基本使用"><a href="#二、ActiveMQ的基本使用" class="headerlink" title="二、ActiveMQ的基本使用"></a>二、ActiveMQ的基本使用</h2><p><strong>ActiveMQ的安装：</strong><br>ActiveMQ安装很简单，只需从其<a href="http://activemq.apache.org/" target="_blank" rel="noopener">官网</a>下载至linux环境，解压并进入bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./activemq start #启动</span><br><span class="line">./activemq stop #停止</span><br><span class="line">./activemq status #查看状态</span><br></pre></td></tr></table></figure></p>
<p>使用启动命令运行就好了。然后我们打开浏览器进入管理后台<a href="http://yourip:8161/admin/" target="_blank" rel="noopener">http://yourip:8161/admin/</a><br>输入默认的账号密码：admin。就可以看到管控台了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_1.jpg" alt="mq_1"><br>然后我们使用java操作ActiveMQ,mq的使用基本都需要创建连接、session、Destination这么几步，我们直接看代码吧。<br><strong>点对点的模型：</strong><br>生产者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//1、创建一个连接工厂对象，需要指定服务的ip及端口。</span></span><br><span class="line">	ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.25.161:61616"</span>);</span><br><span class="line">	<span class="comment">//2、使用工厂对象创建一个Connection对象。</span></span><br><span class="line">	Connection connection = connectionFactory.createConnection();</span><br><span class="line">	<span class="comment">//3、开启连接，调用Connection对象的start方法。</span></span><br><span class="line">	connection.start();</span><br><span class="line">	<span class="comment">//4、创建一个Session对象。</span></span><br><span class="line">	<span class="comment">//第一个参数：是否开启事务。如果true开启事务，第二个参数无意义。一般不开启事务false。</span></span><br><span class="line">	<span class="comment">//第二个参数：应答模式。自动应答或者手动应答。一般自动应答。</span></span><br><span class="line">	Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">	<span class="comment">//5、使用Session对象创建一个Destination对象。两种形式queue、topic，现在应该使用queue</span></span><br><span class="line">	Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line">	<span class="comment">//6、使用Session对象创建一个Producer对象。</span></span><br><span class="line">	MessageProducer producer = session.createProducer(queue);</span><br><span class="line">	<span class="comment">//7、创建一个Message对象，可以使用TextMessage。</span></span><br><span class="line">	<span class="comment">/*TextMessage textMessage = new ActiveMQTextMessage();</span></span><br><span class="line"><span class="comment">	textMessage.setText("hello Activemq");*/</span></span><br><span class="line">	TextMessage textMessage = session.createTextMessage(<span class="string">"hello activemq"</span>);</span><br><span class="line">	<span class="comment">//8、发送消息</span></span><br><span class="line">	producer.send(textMessage);</span><br><span class="line">	<span class="comment">//9、关闭资源</span></span><br><span class="line">	producer.close();</span><br><span class="line">	session.close();</span><br><span class="line">	connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个ConnectionFactory对象连接MQ服务器</span></span><br><span class="line">	ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.25.161:61616"</span>);</span><br><span class="line">	<span class="comment">//创建一个连接对象</span></span><br><span class="line">	Connection connection = connectionFactory.createConnection();</span><br><span class="line">	<span class="comment">//开启连接</span></span><br><span class="line">	connection.start();</span><br><span class="line">	<span class="comment">//使用Connection对象创建一个Session对象</span></span><br><span class="line">	Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">	<span class="comment">//创建一个Destination对象。queue对象</span></span><br><span class="line">	Queue queue = session.createQueue(<span class="string">"spring-queue"</span>);</span><br><span class="line">	<span class="comment">//使用Session对象创建一个消费者对象。</span></span><br><span class="line">	MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//打印结果</span></span><br><span class="line">			TextMessage textMessage = (TextMessage) message;</span><br><span class="line">			String text;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				text = textMessage.getText();</span><br><span class="line">				System.out.println(text);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//等待接收消息</span></span><br><span class="line">	System.in.read();</span><br><span class="line">	<span class="comment">//关闭资源</span></span><br><span class="line">	consumer.close();</span><br><span class="line">	session.close();</span><br><span class="line">	connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们运行了生产者后，我们可以在管控台看到Queue中多了一条消息，并且还没有被消费<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_2.jpg" alt="mq_2"><br>当我们运行消费者后就可以接收到生产者发送的消息。<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_3.jpg" alt="mq_3"><br>并且管控台也出现了相应的变化<br><img src="http://ou3np1yz4.bkt.clouddn.com/mq_4.jpg" alt="mq_4"><br><strong>发布订阅的模型：</strong><br>生产者代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">  public void testTopicProducer() throws Exception &#123;</span><br><span class="line">      //1、创建一个连接工厂对象，需要指定服务的ip及端口。</span><br><span class="line">      ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.72.121:61616&quot;);</span><br><span class="line">      //2、使用工厂对象创建一个Connection对象。</span><br><span class="line">      Connection connection = connectionFactory.createConnection();</span><br><span class="line">      //3、开启连接，调用Connection对象的start方法。</span><br><span class="line">      connection.start();</span><br><span class="line">      //4、创建一个Session对象。</span><br><span class="line">      //第一个参数：是否开启事务。如果true开启事务，第二个参数无意义。一般不开启事务false。</span><br><span class="line">      //第二个参数：应答模式。自动应答或者手动应答。一般自动应答。</span><br><span class="line">      Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">      //5、使用Session对象创建一个Destination对象。两种形式queue、topic，现在应该使用topic</span><br><span class="line">      Topic topic = session.createTopic(&quot;test-topic&quot;);</span><br><span class="line">      //6、使用Session对象创建一个Producer对象。</span><br><span class="line">      MessageProducer producer = session.createProducer(topic);</span><br><span class="line">      //7、创建一个Message对象，可以使用TextMessage。</span><br><span class="line">/*TextMessage textMessage = new ActiveMQTextMessage();</span><br><span class="line">textMessage.setText(&quot;hello Activemq&quot;);*/</span><br><span class="line">      TextMessage textMessage = session.createTextMessage(&quot;topic message&quot;);</span><br><span class="line">      //8、发送消息</span><br><span class="line">      producer.send(textMessage);</span><br><span class="line">      //9、关闭资源</span><br><span class="line">      producer.close();</span><br><span class="line">      session.close();</span><br><span class="line">      connection.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个ConnectionFactory对象连接MQ服务器</span></span><br><span class="line">    ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.72.121:61616"</span>);</span><br><span class="line">    <span class="comment">//创建一个连接对象</span></span><br><span class="line">    Connection connection = connectionFactory.createConnection();</span><br><span class="line">    <span class="comment">//开启连接</span></span><br><span class="line">    connection.start();</span><br><span class="line">    <span class="comment">//使用Connection对象创建一个Session对象</span></span><br><span class="line">    Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">    <span class="comment">//创建一个Destination对象。topic对象</span></span><br><span class="line">    Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line">    <span class="comment">//使用Session对象创建一个消费者对象。</span></span><br><span class="line">    MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//打印结果</span></span><br><span class="line">            TextMessage textMessage = (TextMessage) message;</span><br><span class="line">            String text;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                text = textMessage.getText();</span><br><span class="line">                System.out.println(text);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"topic消费者3启动。。。。"</span>);</span><br><span class="line">    <span class="comment">//等待接收消息</span></span><br><span class="line">    System.in.read();</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    consumer.close();</span><br><span class="line">    session.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发布订阅模型具有严格的时间相关性，如果没有订阅者的话，发布者发布的内容就被浪费掉了。</p>
<h2 id="三、ActiveMQ与Spring整合"><a href="#三、ActiveMQ与Spring整合" class="headerlink" title="三、ActiveMQ与Spring整合"></a>三、ActiveMQ与Spring整合</h2><p>Spring提供了JMSTemplate,极大地便利了MQ的使用，我们只需要提前在配置文件中配置相关的JMS配置，就可在代码中直接使用。<br><strong>Spring配置文件：</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://192.168.25.161:61616"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置生产者 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是队列(Queue)目的地，点对点的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>spring-queue<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是主题(Topic)目的地，一对多的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"itemAddTopic"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 接收消息配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myMessageListener"</span> <span class="attr">class</span>=<span class="string">"cn.e3mall.search.listener.MyMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"queueDestination"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置好后可在代码中使用以下方法<br>生产者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 第一步：初始化一个spring容器</span></span><br><span class="line">	ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring/applicationContext-activemq.xml"</span>);</span><br><span class="line">	<span class="comment">// 第二步：从容器中获得JMSTemplate对象。</span></span><br><span class="line">	JmsTemplate jmsTemplate = applicationContext.getBean(JmsTemplate.class);</span><br><span class="line">	<span class="comment">// 第三步：从容器中获得一个Destination对象</span></span><br><span class="line">	Queue queue = (Queue) applicationContext.getBean(<span class="string">"queueDestination"</span>);</span><br><span class="line">	<span class="comment">// 第四步：使用JMSTemplate对象发送消息，需要知道Destination</span></span><br><span class="line">	jmsTemplate.send(queue, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">			TextMessage textMessage = session.createTextMessage(<span class="string">"spring activemq test"</span>);</span><br><span class="line">			<span class="keyword">return</span> textMessage;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承MessageListener接口并重新它的onMessage方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TextMessage textMessage = (TextMessage) message;</span><br><span class="line">			<span class="comment">//取消息内容</span></span><br><span class="line">			String text = textMessage.getText();</span><br><span class="line">			System.out.println(text);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者的使用是在Spring容器中注入一个监听器，所以我们需要在配置文件中配置它，它随着Spring的启动而启动，并且实时监听。当有消息向它发送时，他会立即进行逻辑处理。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/useMQ/">http://catalinali.top/2017/useMQ/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式之策略模式]]></title>
      <url>/2017/strategyPattern/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/strategy_logo.jpg" alt="strategy_logo"></p>
<blockquote>
<p>在开发中我们会使用很多中间件，开发过程当然是单机配置，可是上生产环境的时候如何快速切换到集群配置，总不能修改代码吧，这里我们就可以结合Spring来使用策略模式。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、什么是策略模式？"><a href="#一、什么是策略模式？" class="headerlink" title="一、什么是策略模式？"></a>一、什么是策略模式？</h2><p>在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过if…else…或者case等条件判断语句来进行选择。<br>    然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。</p>
<h2 id="二、基本的策略模式使用方法"><a href="#二、基本的策略模式使用方法" class="headerlink" title="二、基本的策略模式使用方法"></a>二、基本的策略模式使用方法</h2><p>我们直接来看例子：<br><strong>1.策略接口</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: Strategy Pattern Interface</span></span><br><span class="line"><span class="comment"> * Created at:	2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStrategy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.准备两个实现类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 实现类A</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是实现类A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 实现类B</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是实现类B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.策略执行Context类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 策略执行</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Strategy stg;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stg.testStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  Getter And Setter */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStg</span><span class="params">(Strategy stg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stg = stg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们准备一个main方法来测试一下他<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: StrategyTest</span></span><br><span class="line"><span class="comment"> * Author: lllx</span></span><br><span class="line"><span class="comment"> * Created at: 2017/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Strategy stgB = <span class="keyword">new</span> StrategyB();</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(stgB);</span><br><span class="line">        context.setStg(stgB);</span><br><span class="line">        context.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://ou3np1yz4.bkt.clouddn.com/strategy_1.jpg" alt="strategy_1"><br>实例化不同的实现类可以出现不同的结果。</p>
<h2 id="三、与Spring想结合的策略模式"><a href="#三、与Spring想结合的策略模式" class="headerlink" title="三、与Spring想结合的策略模式"></a>三、与Spring想结合的策略模式</h2><p>我们主要利用Spring的核心IOC来实现它，还是使用上面的例子；<br>由于我们要在Spring的配置文件中来注入Context的实例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"context"</span> <span class="attr">class</span> = <span class="string">"top.catalinali.search.service.impl.Context"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stg"</span> <span class="attr">ref</span>=<span class="string">"stgB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stgA"</span> <span class="attr">class</span> = <span class="string">"top.catalinali.search.service.impl.StrategyA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stgB"</span> <span class="attr">class</span> = <span class="string">"top.catalinali.search.service.impl.StrategyB"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以通过只修改配置文件来更改context的实现类，从而达到策略模式的目的。</p>
<h2 id="四、通过Spring使用策略模式替换中间件的单机与集群配置"><a href="#四、通过Spring使用策略模式替换中间件的单机与集群配置" class="headerlink" title="四、通过Spring使用策略模式替换中间件的单机与集群配置"></a>四、通过Spring使用策略模式替换中间件的单机与集群配置</h2><p>在开发环境中，许多中间件使用的是单机配置。可到了生产我们就需要使用集群配置。这里我们就可以通过策略模式来快速改变中间件的配置，现在我们以Redis为例：<br><strong>1.策略接口</strong><br>首先我们把Redis方法抽成一个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JedisClient</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">set</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Boolean <span class="title">exists</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">ttl</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">incr</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">hset</span><span class="params">(String key, String field, String value)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">hget</span><span class="params">(String key, String field)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">hdel</span><span class="params">(String key, String... field)</span></span>;</span><br><span class="line">	<span class="function">Boolean <span class="title">hexists</span><span class="params">(String key, String field)</span></span>;</span><br><span class="line">	<span class="function">List&lt;String&gt; <span class="title">hvals</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Long <span class="title">del</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.单机和集群两个实现类</strong><br>这里我们准备单机和集群两个实现类：JedisClientPool和JedisClientCluster。实现上面的JedisClient接口，分别使用单机和集群的代码来实现这些方法。因为代码冗长就不在这里贴出来了。<br><strong>3.配置文件</strong><br>我们使用不同的环境只需要把不用的配置注释掉就好。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 连接redis单机版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisClientPool"</span> <span class="attr">class</span>=<span class="string">"top.catalinali.common.jedis.JedisClientPool"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jedisPool"</span> <span class="attr">ref</span>=<span class="string">"jedisPool"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPool"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"192.168.72.121"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接redis集群 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;bean id="jedisClientCluster" class="cn.e3mall.common.jedis.JedisClientCluster"&gt;</span></span><br><span class="line"><span class="comment">	&lt;property name="jedisCluster" ref="jedisCluster"/&gt;</span></span><br><span class="line"><span class="comment">&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt;</span></span><br><span class="line"><span class="comment">	&lt;constructor-arg name="nodes"&gt;</span></span><br><span class="line"><span class="comment">		&lt;set&gt;</span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7001"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7002"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7003"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7004"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7005"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">			&lt;bean class="redis.clients.jedis.HostAndPort"&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="host" value="192.168.25.162"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">				&lt;constructor-arg name="port" value="7006"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">			&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">		&lt;/set&gt;</span></span><br><span class="line"><span class="comment">	&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">&lt;/bean&gt; --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样在我们开发时只需要注释掉连接集群的配置，而在上线时注释掉单机的配置就好。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://scholers.iteye.com/blog/2012936" target="_blank" rel="noopener">spring与策略模式</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/strategyPattern/">http://catalinali.top/2017/strategyPattern/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> design-patterns </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design-patterns </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js小白入门，搭建开发环境]]></title>
      <url>/2017/installVue/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_logo.jpg" alt="installvue_logo"></p>
<blockquote>
<p>最近Vue.js的热度持续上升，甚至有标题说2017再不会Vue.js就out了。而作为一个不排斥前段的后端码农来说，当然也要跟得上时代。近来准备放下手中的DOM操作，来一次Vue.js从入门到放弃。现将环境搭建过程记录下来。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>Node.js Javascript的运行时环境</li>
<li>npm Node.js下的包管理工具</li>
<li>webpack 前端资源模块化管理和打包工具</li>
<li>vue-cli 脚手架构建工具</li>
<li>cnpm  npm的淘宝镜像</li>
</ul>
<p>如果你像我一样是个后端开发者，并且对以上的工具还处在一脸懵逼的状态下。那么可以先看一下这篇文章<a href="https://zhuanlan.zhihu.com/p/31044340" target="_blank" rel="noopener">萌新也能懂的现代 JavaScript 开发</a>。了解一下现代 JavaScript的演变过程。</p>
<h3 id="Vue-js安装"><a href="#Vue-js安装" class="headerlink" title="Vue.js安装"></a>Vue.js安装</h3><p><strong>1.</strong> Node.js的安装非常容易，首先从<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载你所需操作系统的版本，然后一直下一步就ok，这里贴个菜鸟教程的<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">传送门</a>。<br>安装完成之后，在命令行敲出<code>node -v</code>，如果出现对应版本号，则表示安装成功。<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_01.jpg" alt="installvue_01"><br><strong>2.</strong> npm是随同Node.js一起安装的包管理工具,直接在命令行敲出<code>npm -v</code>就可以查看是否安装成功。<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_02.jpg" alt="installvue_02"><br>npm包管理器虽然有了，但是由于npm下载需要依赖包的服务器地址在国外，导致很多资源访问会很慢。所以我们可以安装淘宝的国内镜像。<br><strong>3.</strong> 在命令行敲出<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>。<br>这样就可以使用 cnpm 命令来安装模块了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install [name]</span><br></pre></td></tr></table></figure></p>
<p><strong>4.</strong> 安装webpack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack -g</span><br></pre></td></tr></table></figure></p>
<p><strong>5.</strong> 安装vue脚手架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure></p>
<h3 id="初始化一个Vue-js环境"><a href="#初始化一个Vue-js环境" class="headerlink" title="初始化一个Vue.js环境"></a>初始化一个Vue.js环境</h3><p>在电脑上新建一个文件夹用来存放我们的代码。然后使用命令行进入这个文件夹<code>cd 目录路径</code>。<br>之后使用命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack name</span><br></pre></td></tr></table></figure></p>
<p>来初始化一个vue环境，这个命令的意思是初始化一个项目，其中webpack是构建工具，也就是整个项目是基于webpack的。在安装过程会有一些初始化的设置，我们可以采用默认配置，一路回车 。<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_04.png" alt="installvue_04"><br>从上图的我们还可以看到vue很贴心的告诉了我们快速开始(To get started)的命令<br><strong>安装项目依赖</strong><br>一定要从官方仓库安装，npm 服务器在国外所以这一步安装速度会很慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<p>不要从国内镜像cnpm安装(会导致后面缺了很多依赖库)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure></p>
<p>安装 vue 路由模块vue-router和网络请求模块vue-resource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-router vue-resource --save</span><br></pre></td></tr></table></figure></p>
<p>启动项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p>
<p>运行成功以后他会告诉你ip和端口号<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_05.png" alt="installvue_05"><br>访问这个地址<br><img src="http://ou3np1yz4.bkt.clouddn.com/installvue_06.png" alt="installvue_06"><br>如果出现上图。恭喜你，已经可以开始Vue.js之旅了。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/installVue/">http://catalinali.top/2017/installVue/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> vue.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[走进Redis：Redis的安装、使用以及集群的搭建]]></title>
      <url>/2017/buildredis/</url>
      <content type="html"><![CDATA[<hr>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/redis_logo.jpeg" alt="redis_logo"></p>
<blockquote>
<p>今天学习了淘淘商城中的redis的使用，在这里把它记录下来。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、Redis的安装"><a href="#一、Redis的安装" class="headerlink" title="一、Redis的安装"></a>一、Redis的安装</h2><p>Redis的安装是很简单的,安装之前我们需要c语言的编译环境。如果没有gcc需要在线安装。<code>yum install gcc-c++</code>。</p>
<h3 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h3><p>第一步：redis的源码包上传到linux系统。<br>第二步：解压缩redis。<code>tar -zxvf redis-3.0.0.tar.gz</code><br>第三步：编译。进入redis源码目录。<code>make</code><br>第四步：安装。<code>make install PREFIX=/usr/local/redis</code>,PREFIX参数指定redis的安装目录。</p>
<h2 id="二、Redis的启动与基本操作"><a href="#二、Redis的启动与基本操作" class="headerlink" title="二、Redis的启动与基本操作"></a>二、Redis的启动与基本操作</h2><p><strong>1.运行redis</strong><br>在redis的安装目录下直接运行<code>./redis-server</code>就可以启动redis,但这是前端启动。如果我们想后台启动就需要：<br>①进入<em>redis-3.0.0.tar.gz</em>解压出来的文件夹，复制里面的redis.conf文件到安装目录下。然后将daemonize改为yes<img src="http://ou3np1yz4.bkt.clouddn.com/redis_1.jpg" alt="redis_1"><br>②执行<code>./redis-server redis.conf</code>运行redis。这样redis就后台运行了,我们可以使用<code>ps aux|grep redis</code>来查看redis的运行状态<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_2.png" alt="redis_2"><br>我们可以使用以下命令来进入操作redis：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli ##进入redis客户端</span><br><span class="line">./redis-cli -h 192.168.72.121 -p 6379 ##连接指定ip和端口的redis服务器</span><br><span class="line">./redis-cli shutdown ##关闭redis客户端</span><br></pre></td></tr></table></figure></p>
<p><strong>2.redis中的五种类型</strong><br>先来看几个操作数据库的基本命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KEYS *                   ##获得当前数据库的所有键</span><br><span class="line">EXISTS key [key ...]     ##判断键是否存在，返回个数，如果key有一样的也是叠加数</span><br><span class="line">DEL key [key ...]        ##删除键，返回删除的个数</span><br><span class="line">TYPE key                 ##获取减值的数据类型（string，hash，list，set，zset）</span><br><span class="line">FLUSHALL                 ##清空所有数据库</span><br><span class="line">Expire key second        ##设置key的过期时间</span><br><span class="line">Ttl key                  ##查看key的有效期</span><br><span class="line">Persist key              ##清除key的过期时间。Key持久化。</span><br></pre></td></tr></table></figure></p>
<p>redis中所有的数据都是Key-value类型的，其中有五种主要数据类型：字符串类型（string），散列类型（hash），列表类型（list），集合类型（set），有序集合类型（zset）。而在这五种类型中，我们最常用的是字符串类型，散列类型。这里简单介绍一下字符串类型和散列类型：<br>①<strong>字符串类型string</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET         ##赋值，用法： SET key value</span><br><span class="line">GET         ##取值，用法： GET key</span><br><span class="line">INCR        ##递增数字，仅仅对数字类型的键有用，相当于Java的i++运算，用法： INCR key</span><br><span class="line">INCRBY      ##增加指定的数字，仅仅对数字类型的键有用，相当于Java的i+=3，用法：INCRBY key increment，意思是key自增increment，increment可以为负数，表示减少。</span><br><span class="line">DECR        ##递减数字，仅仅对数字类型的键有用，相当于Java的i–，用法：DECR key</span><br><span class="line">DECRBY      ##减少指定的数字，仅仅对数字类型的键有用，相当于Java的i-=3，用法：DECRBY key decrement，意思是key自减decrement，decrement可以为正数，表示增加。</span><br><span class="line">INCRBYFLOAT ##增加指定浮点数，仅仅对数字类型的键有用，用法：INCRBYFLOAT key increment</span><br><span class="line">APPEND      ##向尾部追加值，相当于Java中的”hello”.append(“ world”)，用法：APPEND key value</span><br><span class="line">STRLEN      ##获取字符串长度，用法：STRLEN key</span><br><span class="line">MSET        ##同时设置多个key的值，用法：MSET key1 value1 [key2 value2 ...]</span><br><span class="line">MGET        ##同时获取多个key的值，用法：MGET key1 [key2 ...]</span><br></pre></td></tr></table></figure></p>
<p>②<strong>散列类型hash</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HSET        ##赋值，用法：HSET key field value</span><br><span class="line">HMSET       ##一次赋值多个字段，用法：HMSET key field1 value1 [field2 values]</span><br><span class="line">HGET        ##取值，用法：HSET key field</span><br><span class="line">HMGET       ##一次取多个字段的值，用法：HMSET key field1 [field2]</span><br><span class="line">HGETALL     ##一次取所有字段的值，用法：HGETALL key</span><br><span class="line">HEXISTS     ##判断字段是否存在，用法：HEXISTS key field</span><br><span class="line">HSETNX      ##当字段不存在时赋值，用法：HSETNX key field value</span><br><span class="line">HINCRBY     ##增加数字，仅对数字类型的值有用，用法：HINCRBY key field increment</span><br><span class="line">HDEL        ##删除字段，用法：HDEL key field</span><br><span class="line">HKEYS       ##获取所有字段名，用法：HKEYS key</span><br><span class="line">HVALS       ##获取所有字段值，用法：HVALS key</span><br><span class="line">HLEN        ##获取字段数量，用法：HLEN key</span><br></pre></td></tr></table></figure></p>
<p>其他的数据类型就不详细介绍了，相关资料可以点击<a href="https://www.baidu.com/s?wd=redis%E7%9A%84%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B&amp;rsv_spt=1&amp;rsv_iqid=0xe2ece0d100005fa4&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_n=2&amp;rsv_sug3=17&amp;rsv_sug1=14&amp;rsv_sug7=100&amp;rsv_t=eae6CtVWEeBxwTXJYEIsK1Rg%2BIZxWLgTM0hyCSOEYS2VOLZsg6CfpRxdvrRCXXlTZCe7&amp;rsv_sug2=0&amp;inputT=3842&amp;rsv_sug4=3842" target="_blank" rel="noopener">传送门</a></p>
<h2 id="三、Redis的持久化方案"><a href="#三、Redis的持久化方案" class="headerlink" title="三、Redis的持久化方案"></a>三、Redis的持久化方案</h2><p>Redis的所有数据都是保存到内存中的。<br>Rdb：快照形式，定期把内存中当前时刻的数据保存到磁盘。Redis默认支持的持久化方案,一直开启,不会被关闭。<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_3.png" alt="redis_Rdb"><br>通过上图我们可以看到,<strong>dump.rdb</strong>会在以下情况保存一次。</p>
<ul>
<li>900秒（15分钟）之内至少有1个KEY进行了改变</li>
<li>300秒（5分钟）之内至少有10个KEY进行了改变</li>
<li>60秒（1分钟）之内至少有10000个KEY进行了改变</li>
</ul>
<p>aof形式：append only file。把所有对redis数据库操作的命令，增删改操作的命令。保存到文件中。数据库恢复时把所有的命令执行一遍即可。要想开启aof模式需要在<strong>redis.conf</strong>配置文件中将appendonly改为yes<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_4.png" alt="redis_aof"></p>
<h2 id="四、Redis集群的搭建"><a href="#四、Redis集群的搭建" class="headerlink" title="四、Redis集群的搭建"></a>四、Redis集群的搭建</h2><h3 id="1-Redis集群特点"><a href="#1-Redis集群特点" class="headerlink" title="1.Redis集群特点"></a>1.Redis集群特点</h3><p>Redis集群搭建的方式有多种，例如使用zookeeper等，但从redis3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其redis-cluster架构图如下：<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_5.png" alt="redis_cluster"><br>其架构细节：<br>1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。<br>2、节点的fail是通过集群中超过半数的节点检测失效时才生效。<br>3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。<br>4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。<br>5、Redis集群预分好16384个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个槽中。</p>
<h3 id="2-Redis集群环境搭建"><a href="#2-Redis集群环境搭建" class="headerlink" title="2.Redis集群环境搭建"></a>2.Redis集群环境搭建</h3><p>Redis集群中至少应该有三个节点。要保证集群的高可用，需要每个节点有一个备份机。<br>Redis集群至少需要6台服务器。由于条件限制,这里采用与淘淘商城相同的方式搭建伪分布式。在一台虚拟机运行6个redis实例。需要修改redis的端口号7001-7006。<br><strong>第一步</strong>：创建6个redis实例，每个实例运行在不同的端口。需要修改redis.conf配置文件,将端口号修改成7001-7006。除此之外,还需要把cluster-enabled yes前的注释去掉。<br><strong>第二步</strong>：启动每个redis实例。这里我们可以自己写一个shell脚本,这里给出我的也就是淘淘商城中所使用的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd redis01</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis02</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis03</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis04</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis05</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis06</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></p>
<p>关闭集群的脚本也类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -p 7001 shutdown</span><br><span class="line">./redis-cli -p 7002 shutdown</span><br><span class="line">./redis-cli -p 7003 shutdown</span><br><span class="line">./redis-cli -p 7004 shutdown</span><br><span class="line">./redis-cli -p 7005 shutdown</span><br><span class="line">./redis-cli -p 7006 shutdown</span><br></pre></td></tr></table></figure></p>
<p>记得在运行脚本前要添加可执行（x）的权限：<code>chmod u+x fileName.sh</code><br><strong>第三步</strong>：使用ruby脚本搭建集群。<br>首先我们需要安装ruby运行环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br></pre></td></tr></table></figure></p>
<p>然后我们需要安装ruby脚本运行使用的包,将这个文件放在集群文件根目录下，然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-3.0.0.gem</span><br></pre></td></tr></table></figure></p>
<p>文件我上传在了<a href="http://download.csdn.net/download/a3212/10048482" target="_blank" rel="noopener">CSDN</a>。<br>这时我们就可以启动集群环境了,运行下面这条命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 192.168.72.121:7001 192.168.72.121:7002 192.168.72.121:7003 192.168.72.121:7004 192.168.72.121:7005  192.168.72.121:7006</span><br></pre></td></tr></table></figure></p>
<p>从这条命令我们可以看出使用6个节点来创建一个集群，集群中每个主节点有1个从节点。运行过程中输入一个yes就成功了。需要注意的是在真正搭建的时候一定要关闭防火墙。这时候我们查看进程<br><strong>第四步</strong>：连接Redis集群<br>因为每一个节点都是互联互通的,所以我们不论连哪个节点都是可以的。</p>
<h2 id="五、使用Java操作Redis"><a href="#五、使用Java操作Redis" class="headerlink" title="五、使用Java操作Redis"></a>五、使用Java操作Redis</h2><p>redis的客户端有很多,从<a href="http://www.redis.cn/clients.html#java" target="_blank" rel="noopener">官网</a>中我们可以看出来,不仅支持的语言众多,而且很多语言有不止一种连接方式。<br><img src="http://ou3np1yz4.bkt.clouddn.com/redis_6.png" alt="redis_client"><br>这里我们采用在JAVA中使用最广泛的Jedis作为实例。</p>
<h3 id="1-连接单机版"><a href="#1-连接单机版" class="headerlink" title="1.连接单机版"></a>1.连接单机版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 第一步：创建一个Jedis对象。需要指定服务端的ip及端口。</span></span><br><span class="line">	Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.25.153"</span>, <span class="number">6379</span>);</span><br><span class="line">	<span class="comment">// 第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。</span></span><br><span class="line">	String result = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">	<span class="comment">// 第三步：打印结果。</span></span><br><span class="line">	System.out.println(result);</span><br><span class="line">	<span class="comment">// 第四步：关闭Jedis</span></span><br><span class="line">	jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来很简单,不过通常在连接单机版的时候我们采用的是连接池的方式。</p>
<h3 id="2-连接单机版使用连接池"><a href="#2-连接单机版使用连接池" class="headerlink" title="2.连接单机版使用连接池"></a>2.连接单机版使用连接池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisPool</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 第一步：创建一个JedisPool对象。需要指定服务端的ip及端口。</span></span><br><span class="line">	JedisPool jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.25.153"</span>, <span class="number">6379</span>);</span><br><span class="line">	<span class="comment">// 第二步：从JedisPool中获得Jedis对象。</span></span><br><span class="line">	Jedis jedis = jedisPool.getResource();</span><br><span class="line">	<span class="comment">// 第三步：使用Jedis操作redis服务器。</span></span><br><span class="line">	jedis.set(<span class="string">"jedis"</span>, <span class="string">"test"</span>);</span><br><span class="line">	String result = jedis.get(<span class="string">"jedis"</span>);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">	<span class="comment">// 第四步：操作完毕后关闭jedis对象，连接池回收资源。</span></span><br><span class="line">	jedis.close();</span><br><span class="line">	<span class="comment">// 第五步：关闭JedisPool对象。</span></span><br><span class="line">	jedisPool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接集群的方式就又稍微不一样了。</p>
<h3 id="3-连接集群版"><a href="#3-连接集群版" class="headerlink" title="3.连接集群版"></a>3.连接集群版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   @Testjava</span><br><span class="line">public void testJedisCluster() throws Exception &#123;</span><br><span class="line">	// 第一步：使用JedisCluster对象。需要一个Set&lt;HostAndPort&gt;参数。Redis节点的列表。</span><br><span class="line">	Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7001));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7002));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7003));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7004));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7005));</span><br><span class="line">	nodes.add(new HostAndPort(&quot;192.168.72.121&quot;, 7006));</span><br><span class="line">	JedisCluster jedisCluster = new JedisCluster(nodes);</span><br><span class="line">	// 第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。</span><br><span class="line">	jedisCluster.set(&quot;hello&quot;, &quot;100&quot;);</span><br><span class="line">	String result = jedisCluster.get(&quot;hello&quot;);</span><br><span class="line">	// 第三步：打印结果</span><br><span class="line">	System.out.println(result);</span><br><span class="line">	// 第四步：系统关闭前，关闭JedisCluster对象。</span><br><span class="line">	jedisCluster.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/buildredis/">http://catalinali.top/2017/buildredis/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx初探究：安装与简单使用]]></title>
      <url>/2017/helloNginx/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/nginx_logo1.jpg" alt="nginx_logo"></p>
<blockquote>
<p>在学习淘淘商城的过程中接触到了nginx,今天就把使用它的过程记录下来,作为留存。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="一、什么是Nginx"><a href="#一、什么是Nginx" class="headerlink" title="一、什么是Nginx"></a>一、什么是Nginx</h2><p>Nginx是一款高性能的http服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li>
<li>虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</li>
<li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li>
</ul>
<h2 id="二、nginx安装"><a href="#二、nginx安装" class="headerlink" title="二、nginx安装"></a>二、nginx安装</h2><h3 id="1-官网下载nginx源码。"><a href="#1-官网下载nginx源码。" class="headerlink" title="1.官网下载nginx源码。"></a>1.<a href="http://nginx.org/" target="_blank" rel="noopener">官网</a>下载nginx源码。</h3><h3 id="2-外部环境准备"><a href="#2-外部环境准备" class="headerlink" title="2.外部环境准备:"></a>2.外部环境准备:</h3><ul>
<li>需要安装gcc的环境:<code>yum install gcc-c++</code></li>
<li>第三方的开发包:<br>① PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>②zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></p>
<p>③OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure></p>
<h3 id="3-正式安装"><a href="#3-正式安装" class="headerlink" title="3.正式安装"></a>3.正式安装</h3><p>第一步：把nginx的源码包上传到linux系统<br>第二步：解压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxf nginx-1.8.0.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>第三步：使用configure命令创建一makeFile文件。<br>./configure \<br>–prefix=/usr/local/nginx \<br>–pid-path=/var/run/nginx/nginx.pid \<br>–lock-path=/var/lock/nginx.lock \<br>–error-log-path=/var/log/nginx/error.log \<br>–http-log-path=/var/log/nginx/access.log \<br>–with-http_gzip_static_module \<br>–http-client-body-temp-path=/var/temp/nginx/client \<br>–http-proxy-temp-path=/var/temp/nginx/proxy \<br>–http-fastcgi-temp-path=/var/temp/nginx/fastcgi \<br>–http-uwsgi-temp-path=/var/temp/nginx/uwsgi \<br>–http-scgi-temp-path=/var/temp/nginx/scgi<br>注意：以上都是一些安装时配置nginx的一些参数,具体含义可以自行百度。另外在启动nginx之前，上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/temp/nginx/client -p</span><br></pre></td></tr></table></figure></p>
<p>第四步：编译,运行<code>make</code>命令<br>第五步：安装运行<code>make install</code>命令<br>第六步：测试<br>进入安装目录下的<strong>sbin</strong>文件,运行<code>./nginx</code>后，打开浏览器访问主机ip。<br>注意：①默认是80端口。②是否关闭防火墙。<br><img src="http://ou3np1yz4.bkt.clouddn.com/nginx_1.png" alt="nginx_1"><br>如果出现上图，恭喜你，nginx安装成功。<br>相关命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop ##关闭nginx</span><br><span class="line">./nginx -s quit ##关闭nginx(推荐使用)</span><br><span class="line">./nginx -s reload ##重启nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="三、配置虚拟主机"><a href="#三、配置虚拟主机" class="headerlink" title="三、配置虚拟主机"></a>三、配置虚拟主机</h2><h3 id="1-通过端口号区分虚拟主机"><a href="#1-通过端口号区分虚拟主机" class="headerlink" title="1.通过端口号区分虚拟主机"></a>1.通过端口号区分虚拟主机</h3><p>打开nginx的配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>可以看到一个server节点,这个就是我们配置虚拟主机的关键,每一个此节点代表一台主机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;    ##端口号</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;    ##nginx安装目录下的html目录</span><br><span class="line">        index  index.html index.htm; ##每台主机对应的页面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们配置了多个server，就相当于配置了多个虚拟主机。这时我们就可以通过不同的端口号来进行访问。</p>
<h3 id="2-通过域名区分虚拟主机"><a href="#2-通过域名区分虚拟主机" class="headerlink" title="2.通过域名区分虚拟主机"></a>2.通过域名区分虚拟主机</h3><p>首先我们要知道当我们打开浏览器访问每一个域名的时候，每一个域名对应的是一个ip地址。并且一个ip地址可以被多个域名绑定。当我们在本地hosts文件（C:\Windows\System32\drivers\etc）中配置了域名与ip的对应的映射关系时，浏览器就不会再去走DNS服务器<br>为了方便测试，我们先在本地hosts文件配置一下测试所用数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.71.121 www.taobao.com</span><br><span class="line">192.168.21.121 www.baidu.com</span><br></pre></td></tr></table></figure></p>
<p>然后配置两个server节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.taobao.com; ##不同域名配置</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html-taobao; ##不同域名访问的不同文件夹</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.baidu.com; ##不同域名配置</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html-baidu; ##不同域名访问的不同文件夹</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在浏览器上访问这两个地址就可以访问到我们配置的两台虚拟主机。</p>
<h2 id="四、反向代理"><a href="#四、反向代理" class="headerlink" title="四、反向代理"></a>四、反向代理</h2><h3 id="1-什么是反向代理"><a href="#1-什么是反向代理" class="headerlink" title="1.什么是反向代理"></a>1.什么是反向代理</h3><p>两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容。<br>两个域名是www.sian.com.cn和www.sohu.com<br>nginx服务器使用虚拟机192.168.101.3</p>
<h3 id="2-实现反向代理"><a href="#2-实现反向代理" class="headerlink" title="2.实现反向代理"></a>2.实现反向代理</h3><p>第一步：安装两个tomcat，分别运行在8080和8081端口。<br>第二步：启动两个tomcat。<br>第三步：反向代理服务器的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat1 &#123;</span><br><span class="line">	server 192.168.25.148:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.sina.com.cn;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass   http://tomcat1;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    upstream tomcat2 &#123;</span><br><span class="line">	server 192.168.25.148:8081;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.sohu.com;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass   http://tomcat2;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>第四步：nginx重新加载配置文件<br>第五步：配置域名<br>在hosts文件中添加域名和ip的映射关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.71.121 www.sina.com.cn</span><br><span class="line">192.168.71.121 www.sohu.com</span><br></pre></td></tr></table></figure></p>
<h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><p>如果一个服务由多条服务器提供，需要把负载分配到不同的服务器处理，需要负载均衡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat2 &#123;</span><br><span class="line">server 192.168.71.121:8081;</span><br><span class="line">server 192.168.71.121:8082;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以根据服务器的实际情况调整服务器权重。权重越高分配的请求越多，权重越低，请求越少。默认是都是1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat2 &#123;</span><br><span class="line">server 192.168.71.121:8081;</span><br><span class="line">server 192.168.71.121:8082 weight=2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/helloNginx/">http://catalinali.top/2017/helloNginx/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记录：mysql中的case when|on duplicate key update|重复插入返回主键的用法]]></title>
      <url>/2017/recordsql/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/case_logo.jpg" alt="case_logo"><br>在平时的开发中不免接触到数据库,这里记录一些平时开发中遇到的细节问题，与大家共勉。</p>
<hr>
<a id="more"></a>
<h2 id="mysql中的条件控制：case函数"><a href="#mysql中的条件控制：case函数" class="headerlink" title="mysql中的条件控制：case函数"></a>mysql中的条件控制：case函数</h2><p>在操作数据库的开发中不免遇到一些类似if else的判断,这时候就用到了Case函数,首先我们用网上用了好多次的例子来看看它的用法:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case when sex = '1' then '男'  </span><br><span class="line">     when sex = '2' then '女'  </span><br><span class="line">     else '其他' <span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p> 利用这个格式我们可以就可以完成类似if else的操作,比如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">SUM</span>(</span><br><span class="line">    <span class="keyword">case</span> </span><br><span class="line">    <span class="keyword">when</span> V.IN_OUT = <span class="string">'2'</span> <span class="keyword">then</span> -AMOUNT</span><br><span class="line">    <span class="keyword">when</span> V.IN_OUT = <span class="string">'1'</span> <span class="keyword">then</span> AMOUNT <span class="keyword">end</span>) AMOUNT</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tb_financial</span><br></pre></td></tr></table></figure>
<p>怎么样,很简单吧！</p>
<h2 id="mysql中重复插入时更新"><a href="#mysql中重复插入时更新" class="headerlink" title="mysql中重复插入时更新"></a>mysql中重复插入时更新</h2><p>为了防止数据重复插入报错,我们可以让重复插入主键相同的数据时改为更新这条数据。<br>我们使用mysql官网的例子:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=c+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>按照<a href="https://dev.mysql.com/doc/refman/5.5/en/insert-on-duplicate.html" target="_blank" rel="noopener">官网</a>的说法,如果列a被声明为UNIQUE并包含该值 1，则这两个语句具有类似的效果。当列b也是唯一的时候,则相当于下面这条sql:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> a=<span class="number">1</span> <span class="keyword">OR</span> b=<span class="number">2</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是,并不建议ON DUPLICATE KEY UPDATE在具有<strong>多个唯一索引</strong>的表上使用。</p>
<h2 id="MyBatis-MySQL-返回插入的主键ID"><a href="#MyBatis-MySQL-返回插入的主键ID" class="headerlink" title="MyBatis+MySQL 返回插入的主键ID"></a>MyBatis+MySQL 返回插入的主键ID</h2><p>在使用Mybatis想返回插入的主键ID也很简单,只需要在insert的Mapper中添加useGeneratedKeys=”true”和keyProperty=”实体中主键属性名”两个属性:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id="InsertTBFinancial" useGeneratedKeys="true" keyProperty="id"&gt;</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Tb_financial</span><br><span class="line">			(<span class="keyword">id</span>,</span><br><span class="line">			 amount,</span><br><span class="line">			 <span class="keyword">comment</span>)</span><br><span class="line">		<span class="keyword">VALUES</span></span><br><span class="line">			(#&#123;<span class="keyword">id</span>&#125;,</span><br><span class="line">			 #&#123;amount&#125;,</span><br><span class="line">			 #&#123;<span class="keyword">comment</span>&#125;)</span><br><span class="line">  	&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样在调用此方法后实体中的主键值就会自动返回:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Financial financial = <span class="keyword">new</span> Financial();  </span><br><span class="line">financial.setId(<span class="string">"chenzhou"</span>);  </span><br><span class="line">financial.setAmount(<span class="string">"xxxx"</span>);  </span><br><span class="line">financial.setComment(<span class="string">"测试插入数据返回主键功能"</span>);  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"插入前主键为："</span>+financial.getId());  </span><br><span class="line">userDao.insertAndGetId(financial);<span class="comment">//插入操作  </span></span><br><span class="line">System.out.println(<span class="string">"插入后主键为："</span>+financial.getId());</span><br></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/recordsql/">http://catalinali.top/2017/recordsql/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dubbo初体验:远程服务调用和管控台的搭建]]></title>
      <url>/2017/helloDubbo/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_logo.jpg" alt="hellodubbo_logo"></p>
<blockquote>
<p>Dubbo是一个阿里巴巴的分布式服务框架。虽然在很久以前阿里停止更新了,但是还是有很多公司在使用它。Dubbo致力于提供高性能和透明化的RPC远程服务调用方案以及SOA服务治理方案。通过他我们可以非常容易地通过Dubbo来构建分布式服务。哦，对了。好像最近阿里又开始更新了。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="Dubbo的架构"><a href="#Dubbo的架构" class="headerlink" title="Dubbo的架构"></a>Dubbo的架构</h2><p><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_1.png" alt="hellodubbo_1"><br><strong>调用关系说明：</strong></p>
<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。 </li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br><br><br>这张图和这段话你可能已经见过无数次了,但是我还是把它从<a href="http://dubbo.io/" target="_blank" rel="noopener">官网</a>复制了过来。原因就是这张图能很简洁的说么Dubbo的调用关系。如果你还没有使用过Dubbo,那这张图可以很快帮你理顺调用关系。</li>
</ul>
<h2 id="Hello-Dubbo"><a href="#Hello-Dubbo" class="headerlink" title="Hello Dubbo"></a>Hello Dubbo</h2><p>我们在使用过程中一般是采用XML配置,原因就是简单方便。在使用之前我们需要搭建Dubbo的注册中心。官方推荐的注册中心是zookeeper。如果你还没有搭建好zookeeper,那么可以看看我之前写的<a href="http://catalinali.top/2017/buildzookeeper/">小白从头到脚搭建zookeeper集群的过程</a>。<br><strong>1.Dubbo依赖</strong><br>如果你使用的是Maven项目,在使用Dubbo的地方加入下面的依赖即可:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.生产者</strong><br>首先展示生产者的接口,很简单的两个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生产者的实现类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleServiceImpl</span> <span class="keyword">implements</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>User类的话就是name、age、sex三个属性。<br><br>接下来就是生产者的Spring配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 具体的实现bean --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sampleService"</span> <span class="attr">class</span>=<span class="string">"top.catalinali.sample.provider.impl.SampleServiceImpl"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"sample-provider"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.71.121:2181?backup=192.168.71.122:2181,192.168.71.123:2181"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 声明需要暴露的服务接口  写操作可以设置retries=0 避免重复调用SOA服务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">retries</span>=<span class="string">"0"</span> <span class="attr">interface</span>=<span class="string">"top.catalinali.sample.provider.SampleService"</span> <span class="attr">ref</span>=<span class="string">"sampleService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.消费者</strong><br>首先消费者需要一个跟生产一模一样的接口类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"sample-consumer"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.71.121:2181?backup=192.168.71.122:2181,192.168.71.123:2181"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 生成远程服务代理，可以像使用本地bean一样使用demoService 检查级联依赖关系 默认为true 当有依赖服务的时候，需要根据需求进行设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"sampleService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">interface</span>=<span class="string">"top.catalinali.sample.provider.SampleService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Dubbo启动"><a href="#Dubbo启动" class="headerlink" title="Dubbo启动"></a>Dubbo启动</h2><p>首先我们先启动生产者启动:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">				<span class="keyword">new</span> String[] &#123; <span class="string">"sample-provider.xml"</span> &#125;);</span><br><span class="line">		context.start(); </span><br><span class="line">		System.in.read(); <span class="comment">// 为保证服务一直开着，利用输入流的阻塞来模拟</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动消费者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">				<span class="keyword">new</span> String[] &#123; <span class="string">"sample-consumer.xml"</span> &#125;);</span><br><span class="line">		context.start();</span><br><span class="line">			</span><br><span class="line">		SampleService sampleService = (SampleService) context.getBean(<span class="string">"sampleService"</span>);</span><br><span class="line">		String hello = sampleService.sayHello(<span class="string">"tom"</span>);</span><br><span class="line">		System.out.println(hello);</span><br><span class="line">		</span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_2.png" alt="hellodubbo_2"><br>项目结构图<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_4.png" alt="hellodubbo_3"></p>
<h2 id="Dubbo的管控台"><a href="#Dubbo的管控台" class="headerlink" title="Dubbo的管控台"></a>Dubbo的管控台</h2><p>Dubbo管控台搭建其实很容易,我们只需要一个在linux上的tomcat跑Dubbo即可,需要的环境:</p>
<ul>
<li>apache-tomcat-7.0.29.tar.gz</li>
<li>dubbo-admin-2.5.4.war</li>
</ul>
<p><strong>1.安装tomcat</strong><br>使用<code>tar -zxvf apache-tomcat-7.0.29.tar.gz</code>解压tar包<br><strong>2.解压dubbo的war包</strong><br>使用<code>unzip dubbo-admin-2.5.3.war -d dubbo-admin</code>解压dubbo-admin-2.5.4.war到tomcat目录下的webapps下。如果提示无unzip命令,使用yum安装<code>yum install -y unzip zip</code>此命令<br><em>注意：</em><br>如果zookeeper注册中心不在此服务器上,则需要打开dubbo-admin/WEB-INF/dubbo.properties文件,将红框改注册中心的ip地址。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_5.png" alt="hellodubbo_5"><br><strong>3.运行tomcat</strong><br>①进入tomcat下的bin目录下,执行<code>./startup.sh</code>脚本。<br>②使用<code>tail -f ../logs/catalina.out</code>查看日志。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_6.png" alt="hellodubbo_6"><br>③进入<em><a href="http://192.168.71.121:8080/dubbo-admin/" target="_blank" rel="noopener">http://192.168.71.121:8080/dubbo-admin/</a></em>就可以看到管控台了(IP地址改成你的服务器ip)<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_7.png" alt="hellodubbo_7"><br>也可以看到我们刚才所运行的服务<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellodubbo_8.png" alt="hellodubbo_8"></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/helloDubbo/">http://catalinali.top/2017/helloDubbo/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Dubbo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白从头到脚搭建zookeeper集群的过程]]></title>
      <url>/2017/buildzookeeper/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_logo.jpg" alt="buildzk_logo"></p>
<blockquote>
<p>zookeeper的字面意思为动物园管理员,正如他的名字,各个子系统能正常为用户提供统一的服务。并且还可以作为Dubbo的注册中心来使用。今天进行了一番centos的安装到zookeeper集群的搭建,也遇到不少坑。特此记录下来搭建过程。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>VMware Workstation 11   </li>
<li>centos 6.4镜像</li>
<li>jdk-7u67-linux-x64.tar.gz</li>
<li>zookeeper-3.4.6.tar.gz</li>
<li>Xshell </li>
<li>Xftp</li>
</ul>
<h2 id="搭建linux环境"><a href="#搭建linux环境" class="headerlink" title="搭建linux环境"></a>搭建linux环境</h2><p>1.linux安装过程就不赘述了,网上有很多。可以参考<a href="http://blog.csdn.net/lzwglory/article/details/53468199" target="_blank" rel="noopener">这一篇</a>。需要注意的是安装过程中我们最好配置一下网络:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_8.png" alt="buildzk_8"><br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_9.png" alt="buildzk_9"><br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_10.png" alt="buildzk_10"><br>最后一步中红色方框的一样就好了,ip只需要最后一段不一样即可。另外我安装的也是minimal模式。<br>2.安装好centos以后我们要更改一下网络连接方式。如图:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_1.png" alt="buildzk_1"><br>3.这样我们就安装好了一台linux,由于我们要搭建集群,所以我们再克隆2台linux:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_2.jpg" alt="buildzk_2"><br>除了这一步,其他的一直下一步就好<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_3.jpg" alt="buildzk_3"><br>这时我们就得到了3台linux环境。可是由于是克隆的,所以后两台连ip地址都是一样的。所以我们需要更改一些配置来使得后2台也能有了自己的ip。参考<a href="http://www.linuxidc.com/Linux/2012-12/76248.htm" target="_blank" rel="noopener">这一篇</a>。<br>4.开启我们的三台linux环境,使用Xshell分别进行连接。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_4.png" alt="buildzk_4"><br>至此,linux环境就搭建成功了。</p>
<h2 id="搭建zookeeper集群"><a href="#搭建zookeeper集群" class="headerlink" title="搭建zookeeper集群"></a>搭建zookeeper集群</h2><p>1.由于zookeeper是Java编写的,运行在Java环境上，所以我们要先安装jdk。具体安装过程可以看我之前写的<a href="http://catalinali.top/2017/installjira/">centos7下破解安装JIRA 7.2</a>的开头部分。<br>2.使用tar -zxvf 将<code>zookeeper-3.4.6.tar.gz</code>解压到某一个位置。<br>3.将zookeeper-3.4.6/conf目录下面的zoo_sample.cfg修改为zoo.cfg。<br>4.使用vi/vim命令修改<code>zoo.cfg</code>的内容如下图:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_5.png" alt="buildzk_5"><br>其中上面的红框是zookeeper的<strong>数据日志目录</strong>,可以更改成自己的位置。下面的红框是集群中服务的列表。<br>5.分别操作linux进入刚才修改的<strong>数据日志目录</strong>,新建一个myid文件。内容分别是<strong>0</strong>、<strong>1</strong>、<strong>2</strong>。没有错,里面就一个数字，用来唯一标识这个服务。这个id是很重要的，一定要保证整个集群中唯一。zookeeper会根据这个id来取出server.x上的配置。比如当前id为1，则对应着zoo.cfg里的server.1的配置。<br>6.使用关闭<code>service iptables stop</code>暂时关闭防火墙,或者使用<code>chkconfig iptables off</code>永久禁用防火墙。然后进入zookeeper下的bin目录,使用./zkServer.sh start同时对三个linux进行操作。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_6.png" alt="buildzk_6"><br>这时候我们再使用<code>./zkServer.sh status</code>来查看状态如果出现下图,恭喜你搭建成功<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildzk_7.png" alt="buildzk_7"><br>其中leader是主节点,follow是从节点。<br>但是大多数情况我们却出现<strong>It is probably not running</strong>。这时可以参考这篇<a href="http://blog.csdn.net/henni_719/article/details/53331724" target="_blank" rel="noopener">文章</a>去解决问题。</p>
<h2 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h2><p>首先感谢上文参考的所有文章！！<br>其次感谢这个开发的网络世界,让我们可以找到想找的所有资料！！！</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/buildzookeeper/">http://catalinali.top/2017/buildzookeeper/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解jdbcTemplate和namedParameterJdbcTemplate]]></title>
      <url>/2017/useJDBC/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_logo.jpg" alt="jdbcTemplate_logo"></p>
<blockquote>
<p>我们开发DAO层时用的最多的就是ORM框架(Mybatis,hibernate)了。在有些特殊的情况下,ORM框架的搭建略显笨重,这时最好的选择就是Spring中的jdbcTemplate了。本文对jdbcTemplate进行详解，并且会对具名参数namedParameterJdbcTemplate进行讲解。</p>
</blockquote>
<hr>
<a id="more"></a>
<h1 id="jdbcTemplate讲解"><a href="#jdbcTemplate讲解" class="headerlink" title="jdbcTemplate讲解"></a>jdbcTemplate讲解</h1><h3 id="jdbcTemplate提供的主要方法"><a href="#jdbcTemplate提供的主要方法" class="headerlink" title="jdbcTemplate提供的主要方法:"></a>jdbcTemplate提供的主要方法:</h3><ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h3 id="jdbcTemplate环境搭建"><a href="#jdbcTemplate环境搭建" class="headerlink" title="jdbcTemplate环境搭建:"></a>jdbcTemplate环境搭建:</h3><p>1 在spring配置文件中加上jdbcTemplate的bean:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注入jdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意:在这之前我们需要先配置好数据库数据源dateSource。<br>2.在使用jdbcTemplate类中使用@Autowired进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br></pre></td></tr></table></figure></p>
<h3 id="jdbcTemplate方法测试"><a href="#jdbcTemplate方法测试" class="headerlink" title="jdbcTemplate方法测试:"></a>jdbcTemplate方法测试:</h3><p>我们准备一个数据库<br><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_1.png" alt="jdbcTemplate_1"><br>准备数据库对应的实体pojo,实体的名称都要对应数据库的字段名称：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">            <span class="string">"id="</span> + id +</span><br><span class="line">            <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1.查询单个对象queryForObject:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select id,username,password from user where id=?"</span>;</span><br><span class="line"></span><br><span class="line">    BeanPropertyRowMapper&lt;User&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class);</span><br><span class="line">    User user = jdbcTemplate.queryForObject(sql, rowMapper,<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果: User{id=1, username=’123’, password=’123’}<br><strong>2.查询多个对象query:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMutiQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select id,username,password from user"</span>;</span><br><span class="line"></span><br><span class="line">    BeanPropertyRowMapper&lt;User&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class);</span><br><span class="line">    List&lt;User&gt; users = jdbcTemplate.query(sql, rowMapper);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果:<br>User{id=1, username=’123’, password=’123’}<br>User{id=2, username=’1234’, password=’1234’}<br><strong>3.查询count、avg、sum等函数返回唯一值:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCountQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select count(*) from user"</span>;</span><br><span class="line"></span><br><span class="line">    BeanPropertyRowMapper&lt;User&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class);</span><br><span class="line">    Integer result = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果:2<br><strong>4.增删改方法测试:</strong><br><strong>新增:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCreate()&#123;</span><br><span class="line">    String sql = &quot;insert into user (username,password) values (?,?)&quot;;</span><br><span class="line">    int create = jdbcTemplate.update(sql, new Object[]&#123;255, 255&#125;);</span><br><span class="line">    System.out.println(create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为1,去数据库查看也确实插入这条。<br><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_2.png" alt="jdbcTemplate_2"><br><strong>修改:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"update user set username=? , password=? where id=?"</span>;</span><br><span class="line">    <span class="keyword">int</span> update = jdbcTemplate.update(sql, <span class="keyword">new</span> Object[]&#123;<span class="number">256</span>, <span class="number">256</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为1,并且确实数据已经修改<br><strong>删除:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"delete from user where id=?"</span>;</span><br><span class="line">    <span class="keyword">int</span> delete = jdbcTemplate.update(sql, <span class="keyword">new</span> Object[]&#123;<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(delete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5.批量操作:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Object[]&gt; batchArgs=<span class="keyword">new</span> ArrayList&lt;Object[]&gt;();</span><br><span class="line">    batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="number">777</span>,<span class="number">888</span>&#125;);</span><br><span class="line">    batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="number">666</span>,<span class="number">888</span>&#125;);</span><br><span class="line">    batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="number">555</span>,<span class="number">888</span>&#125;);</span><br><span class="line">    String sql = <span class="string">"insert into user (username,password) values (?,?)"</span>;</span><br><span class="line">    jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上方法基本满足了日常我们多DAO层进行的操作,不过当你进行CRUD操作时如果传入的参数不确定,这时候你可能会想起ORM框架的便利。没关系！Spring也为我们提供了这样的操作NamedParameterJdbcTemplate。</p>
<h1 id="NamedParameterJdbcTemplate讲解"><a href="#NamedParameterJdbcTemplate讲解" class="headerlink" title="NamedParameterJdbcTemplate讲解"></a>NamedParameterJdbcTemplate讲解</h1><p>在经典的 JDBC 用法中, SQL 参数是用占位符 ? 表示,并且受到位置的限制. 定位参数的问题在于, 一旦参数的顺序发生变化, 就必须改变参数绑定.<br>在 Spring JDBC 框架中, 绑定 SQL 参数的另一种选择是使用具名参数(named parameter).<br><strong>那么什么是具名参数？</strong><br>具名参数: SQL 按名称(以冒号开头)而不是按位置进行指定. 具名参数更易于维护, 也提升了可读性. 具名参数由框架类在运行时用占位符取代<br>具名参数只在 NamedParameterJdbcTemplate 中得到支持。NamedParameterJdbcTemplate可以使用全部jdbcTemplate方法,除此之外,我们来看看使用它的具名参数案例:<br><strong>具名新增：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"insert into user (username,password) values (:username,:password)"</span>;</span><br><span class="line">    User u = <span class="keyword">new</span> User();</span><br><span class="line">    u.setUsername(<span class="string">"555"</span>);</span><br><span class="line">    SqlParameterSource sqlParameterSource=<span class="keyword">new</span> BeanPropertySqlParameterSource(u);</span><br><span class="line">    namedParameterJdbcTemplate.update(sql,sqlParameterSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看结果<br><img src="http://ou3np1yz4.bkt.clouddn.com/jdbcTemplate_3.png" alt="jdbcTemplate_3"><br>这样我们就可以根据pojo类的属性值使用JDBC来操作数据库了。<br><strong>获取新增的主键:</strong><br>NamedParameterJdbcTemplate还新增了KeyHolder类,使用它我们可以获得主键,类似Mybatis中的useGeneratedKeys。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKeyHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">     String sql = <span class="string">"insert into user (username,password) values (:username,:password)"</span>;</span><br><span class="line">     User u = <span class="keyword">new</span> User();</span><br><span class="line">     u.setUsername(<span class="string">"555"</span>);</span><br><span class="line">     SqlParameterSource sqlParameterSource=<span class="keyword">new</span> BeanPropertySqlParameterSource(u);</span><br><span class="line">     KeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder();</span><br><span class="line">     namedParameterJdbcTemplate.update(sql, sqlParameterSource, keyHolder);</span><br><span class="line">     <span class="keyword">int</span> k = keyHolder.getKey().intValue();</span><br><span class="line">     System.out.println(k);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果就是新增的主键。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cnblogs.com/caoyc/p/5630622.html" target="_blank" rel="noopener">Spring JdbcTemplate详解</a></li>
<li><a href="https://my.oschina.net/happyBKs/blog/497798" target="_blank" rel="noopener">Spring框架笔记（二十五）——NamedParameterJdbcTemplate与具名参数</a></li>
<li><a href="http://blog.csdn.net/qq_20545159/article/details/48287621" target="_blank" rel="noopener">使用Spring的NamedParameterJdbcTemplate完成DAO操作</a></li>
</ul>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/useJDBC/">http://catalinali.top/2017/useJDBC/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> jdbcTemplate </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jdbcTemplate </tag>
            
            <tag> namedParameterJdbcTemplate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring中的ApplicationContextAware接口的使用]]></title>
      <url>/2017/UseApplicationContextAware/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/appContext_logo.jpg" alt="appContext_logo"></p>
<blockquote>
<p>最近在看项目代码时发现一个类在项目各个地方都能进行调用,仔细研究后发现这个类实现了ApplicationContextAware这个接口,这个接口可以很方便的获取到Spring的上下文applicationContext。现在就跟我来一起看看如何使用吧。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>我们先新建一个测试类AppCache,在这个类中我定义了一个静态的DictService属性。而DictService类我也提前写好了,里面只输出了一句话用作测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: 测试ApplicationContextAware接口</span></span><br><span class="line"><span class="comment"> * Copyright:   Copyright (c)2017</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DictServiceImpl</span> <span class="keyword">implements</span> <span class="title">DictService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello ApplicationContextAware"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用测试类AppCache实现这个接口,填写它的setApplicationContext方法。Spring容器在加载的时候会调用一次setApplicationContext,并将上下文ApplicationContext传递给这个方法。我们拿到上下文后就可以做很多事情了。这里我使用它来获取了DictService这个bean。然后创建了一个静态的sayHello测试方法调用了DictService中的sayHello。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: 测试ApplicationContextAware接口</span></span><br><span class="line"><span class="comment"> * Copyright:   Copyright (c)2017</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCache</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DictService dictService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        dictService = applicationContext.getBean(DictService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dictService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要把测试类AppCache注入到Spring容器中,在Spring的配置文件中添加测试类的bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--继承ApplicationContextAware接口的类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"appController"</span> <span class="attr">class</span>=<span class="string">"top.catalinali.controller.AppCache"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们新建一个Junit测试类,来调用自己定义的AppCache中的方法sayHello。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Description: 测试ApplicationContextAware接口</span></span><br><span class="line"><span class="comment"> * Copyright:   Copyright (c)2017</span></span><br><span class="line"><span class="comment"> * Author:      lllx</span></span><br><span class="line"><span class="comment"> * Version:     1.0</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestApp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AppCache.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/appContext_1.png" alt="appContext_1"><br>可以看到我们成功输出了Hello ApplicationContextAware这句话。用这样的方法,我们就可以在项目的各个位置来调用AppCache中的方法。除此之外我们也可以使用上下文进行一些别的事情,大家就可以自由发挥啦！</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实我们进入ApplicationContextAware接口内部可以看到他只有一个抽象的setApplicationContext方法,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且他又继承了一个Aware接口。而且这个接口是空的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="这就很有意思了-具体原因就留给大家来讨论吧。"><a href="#这就很有意思了-具体原因就留给大家来讨论吧。" class="headerlink" title="这就很有意思了,具体原因就留给大家来讨论吧。"></a>这就很有意思了,具体原因就留给大家来讨论吧。</h2><blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/UseApplicationContextAware/">http://catalinali.top/2017/UseApplicationContextAware/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7下破解安装JIRA 7.2]]></title>
      <url>/2017/installjira/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_1.jpg" alt="hello_jira"></p>
<blockquote>
<p>JIRA是Atlassian公司出品的项目与事务跟踪工具,是一款Code Review利器。实习的时候帮公司安装了一下jira，发现网上的资料参差不齐，现在抽空把搭建的过程一步步记录下来。有兴趣的朋友可以参考下。</p>
</blockquote>
<hr>
<a id="more"></a>
<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><ul>
<li><p><strong>jdk的搭建</strong><br>jira 7.2的运行需要jdk1.8的依赖，首先去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">oracle官网</a>下载linux版本的jdk，然后我们开始进行安装。</p>
<ol>
<li>找到一个目录解压jdk:<code>tar -zxvf jdk-8u144-linux-i586.tar.gz</code><br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_01.png" alt="hellojira_01"></li>
<li>在usr下创建一个目录,然后将解压的文件放进去:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/java</span><br><span class="line">mv  jdk1.8.0_102 /usr/java/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>配置环境变量,<code>vim /etc/profile</code>,然后在最后面加入下列代码:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_102/</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>4.更新profile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_2.png" alt="hellojira_2"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p> 如果是给公司安装的话,你可能会发现服务器上不止一个版本的jdk,而且<em>/etc/profile</em>下的环境变量也不是1.8的，这时候该怎么办呢？<br>你可以在jira的运行目录下找到程序启动的<strong>.sh</strong>文件,使用vim编辑器在此文件的最上方添加你要使用的jdk的环境变量,让其从这个路径下寻找jdk。</p>
<ul>
<li>数据库mysql的搭建<br>我使用的是<em>centos7</em>,好多配置跟之前的不太一样。也踩了不少坑,这里就简单说一下我的安装过程吧。<br>首先我使用网上大多数人的答案:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql</span><br><span class="line">yum install mysql-server</span><br><span class="line">yum install mysql-devel</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果发现安装上的压根不是mysql,而是一个mariadb的鬼玩意。于是我去查资料发现centos7的默认数据库由mysql改为了mariadb。于是我又查了各种资料进行mysql的安装,简单说一下步骤:</p>
<p><strong>1.首先下载mysql的repo源</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>2.安装mysql-community-release-el7-5.noarch.rpm包</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>3.安装mysql</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
<p>这样mysql就安装好了,不过这是centos7下的方法,如果大家用的别的环境就不适用了。<br><strong>4.mysql安装好后是没有密码的,我们需要登录mysql然后设置密码:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">use mysql;</span><br><span class="line">update user set password=password(‘123456‘) where user=‘root‘;</span><br></pre></td></tr></table></figure>
<p><strong>5.设置远程连接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;          #使用&apos;mysql&apos;这个数据库</span><br><span class="line">Grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123456&apos; with grant option;   #赋权限</span><br><span class="line">flush privileges;   #刷新权限</span><br></pre></td></tr></table></figure>
<p>这时候我们使用这个账号就可以远程访问了,比如使用桌面的sqlyog进行连接。如果连接不上有可能是3306端口没有放开,下面说一下centos7下的开放端口的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state #查看运行状态</span><br><span class="line">firewall-cmd --add-port=3306/tcp --permanent #开放3306端口</span><br><span class="line">firewall-cmd --reload #生效刚才的端口设置</span><br></pre></td></tr></table></figure>
<p><strong>6.创建一个jira使用的mysql账号</strong><br>回到正题,mysql已经安装好了。现在我们来为jira创建一个mysql用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &apos;jira&apos;@&apos;%&apos; IDENTIFIED BY &apos;jira&apos;;</span><br></pre></td></tr></table></figure>
<p>创建一个jira数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database jira default character set utf8 collate utf8_bin;</span><br></pre></td></tr></table></figure>
<p>给jira用户赋权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT all on jiradb.* to &apos;jira&apos;@&apos;%&apos; identified by &apos;jira&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>这时候我们可以使用<code>show grants for jira@localhost;</code>来查看一下权限。</p>
<h1 id="二、破解安装jira"><a href="#二、破解安装jira" class="headerlink" title="二、破解安装jira"></a>二、破解安装jira</h1><p>这时候我们就可以安装并破解jira了<br><strong>1.下载linux版本的jira</strong><br>首先去<a href="https://www.atlassian.com/software/jira/download" target="_blank" rel="noopener">官网</a>下载linux版本的jira<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_03.png" alt="hellojira_03"><br>并且把破解包下载下来链接：<a href="http://pan.baidu.com/s/1bMfksQ" target="_blank" rel="noopener">http://pan.baidu.com/s/1bMfksQ</a> 密码：lsc7<br><strong>2.开始安装jira</strong><br>将安装包放入linux随意一个目录下后,使用如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> chmod 755 atlassian-jira-software-7.4.2-x64.bin #修改权限</span><br><span class="line"></span><br><span class="line">./atlassian-jira-software-7.4.2-x64.bin</span><br></pre></td></tr></table></figure>
<p>安装过程有一些选项,如果选不对就会出现下图情景,我们可以看到jira安装的端口是8080,安装的路径是/opt/atlassian/jira和/var/atlassian/application-data/jira目录下:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_04.png" alt="hellojira_04.png"><br>因为8080端口比较常用,所以我们把他更换一下:<code>vim /opt/atlassian/jira/conf/server.xml</code><br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_4.png" alt="hellojira_4.png"><br>这里我把红框中的端口改为了8090<br><strong>3.破解jira</strong><br>解压破解包,找到一下两个文件:</p>
<pre><code>atlassian-extras-3.1.2.jar    #jira破解文件
mysql-connector-java-5.1.39-bin.jar   #mysql驱动
</code></pre><p>和两个文件复制到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下。这时候需要注意,jira破解文件是需要替换里面的原文件,但由于他的版本比较旧,所以就需要大家先找到原本目录下的atlassian-extras-3.x.jar文件。将它删除,然后把我们的破解文件换成它的名字。<br><strong>4.启动jira</strong><br>进入/opt/atlassian/jira/bin目录下运行<em>start-jira.sh</em><br>打开桌面上的浏览器,访问<a href="http://localhost:8090" target="_blank" rel="noopener">http://localhost:8090</a>。就可以看到启动画面,如果不能访问,尝试用上面的方法放开一下8090端口:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_6.png" alt="hellojira_6"><br>点击continue后开始选择配置数据库:<br>输入正确的数据库信息后可以先test一下,如果test成功的话,执行下一步会jira会自动的向数据库中创建表。<br>这里需要注意的就是Mode选项。private是只有管理员可以注册账号，public是用户可以自己注册。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_10.png" alt="hellojira_10"><br>下面的步骤需要获取license:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_11.png" alt="hellojira_11"><br>需要我们去官网注册一个账号来获取license:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_13.png" alt="hellojira_13"><br>确定后会自动跳转回来:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_14.png" alt="hellojira_14"><br>之后就简单多了:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_15.png" alt="hellojira_14"><br>点击<em>Next</em><br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_16.png" alt="hellojira_14"><br>选择<em>Finish</em>,之后选择一些语言就好了:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellojira_17.png" alt="hellojira_14"></p>
<p>jira到这里就算是安装完成了,看着步骤多其实没有什么难点。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.ilanni.com/?p=12119" target="_blank" rel="noopener">烂泥：jira7.2安装、中文及破解</a></li>
<li><a href="http://10551335.blog.51cto.com/10541335/1749945" target="_blank" rel="noopener">Centos 6.7下 jira7.1.1+confluence5.96+mysql结合（破解）</a></li>
<li><a href="http://blog.csdn.net/dunhanson/article/details/52997803" target="_blank" rel="noopener">CentOS yum 安装、卸载MariaDB数据库</a></li>
<li><a href="http://www.cnblogs.com/julyme/p/5969626.html" target="_blank" rel="noopener">centos7下使用yum安装mysql</a></li>
<li><a href="http://blog.csdn.net/sodino/article/details/52356472" target="_blank" rel="noopener">【Linux】CentOS 7通过Firewall开放防火墙端口</a></li>
</ul>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/installjira/">http://catalinali.top/2017/installjira/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> jira </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jira </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记录：使用IDEA搭建Maven+SSM的过程]]></title>
      <url>/2017/IDEABuildSSM/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_15.jpg" alt="hellossm_15"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>IntelliJ IDEA被认为是当前 Java 开发效率最快的 IDE 工具。份额已经逐渐超越Eclipse。一直使用Eclipse的我也不禁想尝尝鲜，之前简单的使用它搭建了一下SSM环境，现在把他记录下来。</p>
</blockquote>
<a id="more"></a>
<h1 id="新建一个Maven项目"><a href="#新建一个Maven项目" class="headerlink" title="新建一个Maven项目"></a>新建一个Maven项目</h1><p>打开IDEA,选择新建一个项目<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_1.png" alt="hellossm_1"><br>如图:首先我们选择一个maven Project,然后要创建模板勾选Create from archetype。由于我们准备新建一个web工程所以选择maven-archetype-webapp。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_2.png" alt="hellossm_2"><br>下一步:填写GroupId,ArtifactId。填写的标准就不用多说了吧。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_3.png" alt="hellossm_3"><br>下一步:选择使用的maven的本地位置,这个根据实际情况选择就好。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_4.png" alt="hellossm_4"><br>下一步:这一步会填写项目名称,根据实际来就好了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_5.png" alt="hellossm_5"><br>然后点击Finish,一个空的web工程就建好了。</p>
<h1 id="搭建SSM环境"><a href="#搭建SSM环境" class="headerlink" title="搭建SSM环境"></a>搭建SSM环境</h1><p><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_6.png" alt="hellossm_6"><br>IDEA里的java文件只能在Source Boot类型的文件夹下创建,所以我们要新建一个文件夹，然后将它的类型改为Source Boot:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_7.png" alt="hellossm_7"><br>这时候我们就可以新建需要的类了。ssm的配置还是那老一套，由于篇幅问题这里就不贴出来了。配置完的大体结构是这样的。<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_8.png" alt="hellossm_8"></p>
<h1 id="运行web工程"><a href="#运行web工程" class="headerlink" title="运行web工程"></a>运行web工程</h1><p>选择如图位置：<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_9.png" alt="hellossm_9"><br>然后选择如图:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_10.png" alt="hellossm_10"><br>这里主要选择本地tomcat的位置<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_11.png" alt="hellossm_11"><br>然后我们切换到第二栏Deployment:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_12.png" alt="hellossm_12"><br>选择如图的选项,注意这里一定要选择带exploded的这个:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_13.png" alt="hellossm_13"><br>选择OK，然后install–&gt;运行tomcat。如果出现如图，则表示成功:<br><img src="http://ou3np1yz4.bkt.clouddn.com/hellossm_14.png" alt="hellossm_14"></p>
<h1 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h1><p>IntelliJ IDEA现在已经被基本被认为是当前 Java 开发效率最快的 IDE 工具。对于用惯了Eclipse的我来说显然快要跟不上时代了,这篇文章只是简单的记录了一下搭建的过程,目的是快速熟悉一下IDEA的运行方式。然而关于SSM配置内容却只字未提。一个是因为关于SSM整合的文章现在网上多的是,大家只要一搜就好了。再一个是因为配置都是一大段一大段的,全部粘上来未免太占篇幅。<br>最后贴一个IDEA的<a href="https://youmeek.gitbooks.io/intellij-idea-tutorial/content/" target="_blank" rel="noopener">教程</a></p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/IDEABuildSSM/">http://catalinali.top/2017/IDEABuildSSM/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SSM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SSM </tag>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo骚操作：主题配置|搜索|评论|SEO|统计|图床]]></title>
      <url>/2017/secondBuildHexo/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/front-pic2.jpg" alt="front-pic2"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>相信各位在看过上一篇blog<a href="http://catalinali.top/2017/firstBuildHexo/">手把手教你使用hexo搭建属于你的个人博客</a>后已经初步搭建了属于自己的博客，不过细心的你可能已经发现这样的博客还是缺点什么，现在就来说说Hexo的骚操作:添加主题、统计、评论、SEO等等等等。</p>
</blockquote>
<hr>
<a id="more"></a>
<p>承接上篇最后说过的:根目录下的<code>_config.yml</code>叫做<strong>站点配置文件</strong>，主题下文件夹的<code>_config.yml</code>叫做<strong>主题配置文件</strong>。好了,现在进入正题，今天我们要对Hexo进行一些脱胎换骨的操作，让你从内到外了解Hexo，要完成的操作如下：</p>
<ul>
<li>添加个性化主题</li>
<li>在github保存Hexo</li>
<li>添加评论系统</li>
<li>添加搜索与统计</li>
<li>添加图床</li>
</ul>
<h2 id="一、添加个性化主题"><a href="#一、添加个性化主题" class="headerlink" title="一、添加个性化主题"></a>一、添加个性化主题</h2><p>Hexo默认的主题可能满足不了你的胃口，我们这里选择换一个更加个性化的主题，首先先去挑一个你心仪的主题:<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">传送门</a>。大家也可以自行寻找一些主题。这里使用人气最高的Next主题为例：<br><strong>1.安装主题</strong><br>打开<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">github下载地址</a>，clone下载地址<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_1.png" alt="buildHexo2_1"><br>进入你的Hexo根目录右键选择Git Bash Here,在命令行中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure></p>
<p>这时在我们的<code>theme</code>文件夹下就会有一个名next的主题文件夹。<br><strong>2.配置主题</strong><br>进入<strong>站点配置文件</strong>,找到theme选项，后面填写你要使用的主题名字。这里再次强调一下,_config.yml使用的是<code>YAML</code>语法。选项后面要先加一个空格才能填值，遇到无法解决的问题不妨对格式进行<a href="http://www.yamllint.com/" target="_blank" rel="noopener">校验</a>。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_2.png" alt="buildHexo2_2"><br>这时候就可以使用调试模式来查看一下主题了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清除缓存</span><br><span class="line">hexo g #自动生成静态页面,hexo generate的缩写</span><br><span class="line">hexo s --debug #调试模式,在浏览器进入http://localhost:4000/进行访问</span><br></pre></td></tr></table></figure></p>
<p>发现没有什么问题就可以使用<code>hexo d</code>进行发布了,Next主题有他的<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a>,一些基本的设置都可以在上面找的，这里就不赘述了。</p>
<h2 id="二、在github保存Hexo"><a href="#二、在github保存Hexo" class="headerlink" title="二、在github保存Hexo"></a>二、在github保存Hexo</h2><p>当你慢慢了解Hexo以后，不知你是否会有这样的想法:当我换了一台电脑，我该怎样继续更新的我blog。查阅了众多资料后找到了我心中答案:<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">传送门</a>。我们要用的就是知乎中1楼的这个高亮答案。过程他已经说的很清楚了，但是这里我要说几个我遇到的坑:</p>
<ul>
<li>在明白了答主的步骤后，我们发现刚才的主题是用git拉下来的,那么Next主题文件夹下就会有一个<strong>.git</strong>的隐藏文件夹,这个文件会影响我们对博客文件的提交，所以我们要首要的一步是删除Next文件夹下隐藏的<strong>.git</strong>文件夹</li>
<li>这篇文章楼下答主<a href="https://www.zhihu.com/people/KOKO-55/answers" target="_blank" rel="noopener"><strong>KOKO</strong></a>所说的内容。在我们拉下来仓库以后会生成一个.git文件夹。这个文件夹记录了我们所对应github的分支。然而在进行了hexo命令操作以后会覆盖这个.git文件夹。所以应该提前将这个文件夹备份一下,然后回过头来进行覆盖。</li>
</ul>
<h2 id="三、为Hexo添加评论系统"><a href="#三、为Hexo添加评论系统" class="headerlink" title="三、为Hexo添加评论系统"></a>三、为Hexo添加评论系统</h2><p>官方文档里推荐了好多个评论系统,一路用过来发现DISQUS被墙了,网易云跟帖跟多说关闭服务了。现在还比较好用的就剩下来必力跟畅言了,并且我们选择的Next昨天还很贴心的集成了这两个评论系统。</p>
<ul>
<li>添加来必力<br>1.注册<a href="https://livere.com/" target="_blank" rel="noopener">来必力</a>,注册过程中可能会冒出一些棒子语言，让我们使用直觉注册好后点击我的页面–&gt;代码管理–&gt;data-uid<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_3.png" alt="buildHexo2_3"><br>2.复制我们的这个id,粘贴到主题配置文件<code>livere_uid</code>选项后面<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_4.png" alt="buildHexo2_4"><br>这时你再重新部署你的Hexo,是不是已经有了来必力评论系统</li>
<li>添加畅言<br>畅言的UI感觉比来必力清爽一些，但是注册的过程需要ICP备案号,这个比较麻烦<br>1.注册<a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言</a>,进入账户管理–&gt;后台总览–&gt;畅言秘钥<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_5.png" alt="buildHexo2_5"><br>2.复制畅言秘钥，粘贴到主题配置文件<code>changyan</code>后面<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_6.png" alt="buildHexo2_6"></li>
</ul>
<h2 id="四、为Hexo搜索与统计"><a href="#四、为Hexo搜索与统计" class="headerlink" title="四、为Hexo搜索与统计"></a>四、为Hexo搜索与统计</h2><p>搜索与统计都比较简单，<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">官方文档</a>有详尽的明细,统计推荐不蒜子，简单粗暴。<br>搜索的话我使用的是本地搜索，即Local Search。他的原理是在你本地生成一个xml文件,搜索的时候对这个文件进行检索。下面说说安装步骤<br>1.执行下面2个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p>
<p>2.打开站点配置文件，新增以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<p>3.打开主题配置文件，启用本地搜索功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p>
<h2 id="五、为Hexo添加图床"><a href="#五、为Hexo添加图床" class="headerlink" title="五、为Hexo添加图床"></a>五、为Hexo添加图床</h2><p>以后写博客避免不了常常使用图片,可是Github Pages是有容量限制的,总不能全部都作为静态文件进行上传吧。这里推荐一个好评的<a href="https://portal.qiniu.com/signup?code=3letjvek8jgia" target="_blank" rel="noopener">七牛云</a>图床。七牛云不是免费的，但每个用户有10GB免费存储，每月10GB免费下载流量,对于博客使用来说够了。使用方法:<br>1.打开链接并注册,单机 对象存储–&gt;创建空间。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_7.png" alt="buildHexo2_7"><br>2.当我们使用图片时。需要先上传到七牛,然后复制外链,之后就可以在MarkDown文章中使用了。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo2_8.png" alt="buildHexo2_8"><br>3.每次这样获取图片链接,相信你一定会很烦的。这里有一个针对七牛的小工具<a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">Mpic</a>。简化了这一步骤,相信你一定会爱上他的。</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/secondBuildHexo/">http://catalinali.top/2017/secondBuildHexo/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你使用hexo搭建属于你的个人博客]]></title>
      <url>/2017/firstBuildHexo/</url>
      <content type="html"><![CDATA[<p><img src="http://ou3np1yz4.bkt.clouddn.com/front-pic1.jpg" alt="front-pic-1"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>   每当看到别人精美的个人博客时，不知你是否有一点点的羡慕。别急，现在我就来手把手教你搭建自己的个人博客。<br>    在技术日趋成熟的今天，有着很多种快速生成博客的框架:Hexo,Jekyll,Wordpress等等。今天我们就用<code>Hexo</code>来带着大家完成自己的博客 </p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo?"></a>什么是Hexo?</h2><p>Hexo<a href="https://hexo.io/" target="_blank" rel="noopener">官网</a>中说是这么描述的：<strong>A fast, simple &amp; powerful blog framework</strong>,即:一个快速、简单且强大的博客快速生产工具。它的简单体现在你完全有可能在30分钟内就生成属于你的个人博客。而它的强大体现在你对细节的调整上完全有可能花上一天的时间。</p>
<h2 id="一、巧妇难为无米之炊-准备搭建环境"><a href="#一、巧妇难为无米之炊-准备搭建环境" class="headerlink" title="一、巧妇难为无米之炊:准备搭建环境"></a>一、巧妇难为无米之炊:准备搭建环境</h2><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><p>Node.js 的实质是一个JavaScript运行环境,这里我们主要使用它来生成我们博客的静态页面。从<a href="http://nodejs.cn/" target="_blank" rel="noopener">官网</a>下载最新的安装包进行默认安装就好。安装过程略。</p>
<h3 id="2-安装git环境"><a href="#2-安装git环境" class="headerlink" title="2.安装git环境"></a>2.安装git环境</h3><p>git是最流行的分布式版本控制系统，我们使用它主要是与github进行交互。安装<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">git</a>使用默认选项安装即可，安装过程略。如果你还对git不是特别熟悉，推荐一个学习git的教程:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">传送门</a></p>
<h3 id="3-注册github"><a href="#3-注册github" class="headerlink" title="3.注册github"></a>3.注册github</h3><p><a href="https://github.com/" target="_blank" rel="noopener">github</a>就不用说了吧，它是一个面向开源及私有软件项目的托管平台。几乎所有的程序员都听说过它的大名。就正常注册一个账号就好了。<br>注册号以后首先给我们的账号添加本机的SSH，具体方法及原因在<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="noopener">这篇文章</a>已经有了详细说明，并且方法也很简单</p>
<h2 id="二、上正菜：开始搭建博客"><a href="#二、上正菜：开始搭建博客" class="headerlink" title="二、上正菜：开始搭建博客"></a>二、上正菜：开始搭建博客</h2><p>环境都准备好后，我们就可以开始安装博客了:<br><strong>1.创建文件夹</strong><br>    在本地新建一个文件夹用于存放我们的博客，并且右键菜单选择Git Bash Here,然后在Git Bash里输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure></p>
<p>然后回车，如图：</p>
<p><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_1.png" alt="buildHexo_1"><br>我在执行这个的时候出现了下图的警告,但是并不影响我们的安装，不用理会它。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_5.png" alt="buildHexo_5"><br>如果没有输出err之类的错误并且目录下多了一个node_modules文件夹，那这步就算成功了<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_6.png" alt="buildHexo_6"></p>
<p><strong>2.执行hexo命令</strong><br>依次执行以下3个命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init  --初始化hexo环境,这时会在目录下自动生成hexo的文件</span><br><span class="line">npm install --安装npm依赖包</span><br><span class="line">hexo generate --生成静态页面</span><br><span class="line">hexo server --生成本地服务</span><br></pre></td></tr></table></figure></p>
<p>好了，这时候我们打开浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>看看可不可以访问。如果默认的hexo博客出现，那么恭喜你，你已经搭建好了自己的博客，接下来我们就要将它发布到网上。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_11.png" alt="buildHexo_11"><br><strong>3.可能遇到的报错</strong>:</p>
<ul>
<li><p><strong>日志报错</strong><br>这个报错一般是由于在命令执行中用户使用Ctrl+C强制中断了命令的执行，导致log中记录已经执行，但实际没有执行完成。解决办法:删除图中路径下的.log文件<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_7.png" alt="buildHexo_7"></p>
</li>
<li><p><strong>在非空文件夹下执行<code>hexo init</code>命令</strong><br><code>hexo init</code>这个命令是自动生成hexo目录时使用的命令，使用他有一个前提是必须是空文件夹，如果出现了这个错误，把所有文件删除就行。如果还是报错，别着急，看看是不是有隐藏文件没有删除。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_8.png" alt="buildHexo_8"></p>
</li>
<li><p><strong>hexo命令未找到</strong><br>有的同学可能会出现在执行hexo命令时出现<code>conmand not found</code>的提示，这是由于hexo没有配到环境变量中，只需要手动配置一下就好了，这里演示一下win7的配置方式，其他系统也差不多，自行<a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a>就好:<br>1.找到并进入根目录下<strong>node_modules</strong>文件夹,这时我们发现里面有很多文件夹，找到<code>hexo</code>文件夹,这里我们可以看到一个<code>bin</code>文件夹，进到<code>bin</code>目录下，复制当前路径:<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_9.png" alt="buildHexo_9"><br>2.右键我的电脑–&gt;高级系统设置–&gt;高级–&gt;环境变量。在系统变量那栏找到Path并双击这行,在弹出的<code>编辑系统变量</code>这栏的变量值的<strong>最后</strong>先输入一个分号<code>；</code>表示与前一个变量隔开,然后再把刚才复制的hexo路径添加到分号后面。<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_10.png" alt="buildHexo_10"></p>
</li>
</ul>
<h2 id="三、万事具备，只欠东风：将本地博客发布到网络上"><a href="#三、万事具备，只欠东风：将本地博客发布到网络上" class="headerlink" title="三、万事具备，只欠东风：将本地博客发布到网络上"></a>三、万事具备，只欠东风：将本地博客发布到网络上</h2><p>这时候就要用到了我们的github：<br><strong>1.创建远程仓库</strong><br>新建一个跟自己账号<strong>名字</strong>一样的空仓库，如图：<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_2.png" alt="buildHexo_2"><br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_3.png" alt="buildHexo_3"><br><strong>2.连接本地与远程github仓库</strong><br>打开本地博客的文件夹，打开<strong>_config.yml</strong>进行编辑<br><img src="http://ou3np1yz4.bkt.clouddn.com/buildHexo_4.png" alt="buildHexo_4"><br>翻到文件最下方，将deploy的选项改成以下的形式，并将yournmae修改为你自己的名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p>
<p>然后在GitBash中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>这时候，我们再最后执行一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>就可以在浏览器中访问<a href="http://yourname.github.io/来进入你的博客啦" target="_blank" rel="noopener">http://yourname.github.io/来进入你的博客啦</a><br>大功告成！！</p>
<h2 id="四、一鼓作气：详细了解Hexo"><a href="#四、一鼓作气：详细了解Hexo" class="headerlink" title="四、一鼓作气：详细了解Hexo"></a>四、一鼓作气：详细了解Hexo</h2><p>博客已经可以访问了，但我相信大家对Hexo还是一头雾水，现在我们来深入学习一下Hexo:<br><strong>1.Hexo的基本命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo generate --生成个人博客所需的静态页面</span><br><span class="line">hexo server --本地预览</span><br><span class="line">hexo deploy --部署我们的个人博客</span><br><span class="line">hexo clean --清除缓存</span><br></pre></td></tr></table></figure></p>
<p>这几个命令都能用首字母缩写完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g --generate </span><br><span class="line">hexo s --server </span><br><span class="line">hexo d --deploy</span><br></pre></td></tr></table></figure></p>
<p><strong>2.写文章的需要用到下面的命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; --新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; --新建页面</span><br></pre></td></tr></table></figure></p>
<p>编辑我们的博客的时候可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></p>
<p>然后访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>来进入调试模式，更改了配置或文章后随时刷新页面来查看效果。<br>Hexo的文章支持的是<code>MarkDown</code>语法。网上有很多资料，这里提供一个<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">传送门</a>。</p>
<p><strong>3.我们每次部署的步骤是</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>后两步可以简写为<code>hexo g -d</code>，另外我们也可以使用<code>hexo help</code>来查看hexo命令帮助</p>
<p><strong>4.目录结构说明</strong><br>hexo init 出来的文件各自的作用如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`-----------</span><br><span class="line">|  +-- .deploy       #hexo deploy生成的文件</span><br><span class="line">|  +-- node_modules  #npm组件</span><br><span class="line">|  +-- public        #生成的静态网页文件</span><br><span class="line">|  +--scaffolds      #模板</span><br><span class="line">|  +-- source        #博客正文和其他源文件</span><br><span class="line">|  |   +-- _posts    #我们自己写的文章以md结尾</span><br><span class="line">|  +-- themes        #主题</span><br><span class="line">|  +-- _config.yml   #全局配置文件</span><br><span class="line">|  `-- package.json  #定义了hexo所需要的各种模块</span><br></pre></td></tr></table></figure></p>
<p><strong>5.配置文件</strong><br>搭建好博客后，我们的各种细节配置基本都是在配置文件中完成的，Hexo中的配置文件一共分2中，在文件夹跟目录下的<code>_config.yml</code>叫做<strong>站点配置文件</strong>,同样的文件名我们可以在<code>theme</code>文件夹下的主题文件夹里面也找的。而主题文件夹下的<code>_config.yml</code>叫做主题配置文件。这里说明一下站点配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site #站点信息</span><br><span class="line">title:  #标题</span><br><span class="line">subtitle:  #副标题</span><br><span class="line">description:  #站点描述，给搜索引擎看的</span><br><span class="line">author:  #作者</span><br><span class="line">email:  #电子邮箱</span><br><span class="line">language: zh-CN #语言</span><br><span class="line"># URL #链接格式</span><br><span class="line">url:  #网址</span><br><span class="line">root: / #根目录</span><br><span class="line">permalink: :year/:month/:day/:title/ #文章的链接格式</span><br><span class="line">tag_dir: tags #标签目录</span><br><span class="line">archive_dir: archives #存档目录</span><br><span class="line">category_dir: categories #分类目录</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">permalink_defaults:</span><br><span class="line"># Directory #目录</span><br><span class="line">source_dir: source #源文件目录</span><br><span class="line">public_dir: public #生成的网页文件目录</span><br><span class="line"># Writing #写作</span><br><span class="line">new_post_name: :title.md #新文章标题</span><br><span class="line">default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</span><br><span class="line">titlecase: false #标题转换成大写</span><br><span class="line">external_link: true #在新选项卡中打开连接</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">highlight: #语法高亮</span><br><span class="line">  enable: true #是否启用</span><br><span class="line">  line_number: true #显示行号</span><br><span class="line">  tab_replace:</span><br><span class="line"># Category &amp; Tag #分类和标签</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"># Archives</span><br><span class="line">2: 开启分页</span><br><span class="line">1: 禁用分页</span><br><span class="line">0: 全部禁用</span><br><span class="line">archive: 2</span><br><span class="line">category: 2</span><br><span class="line">tag: 2</span><br><span class="line"># Server #本地服务器</span><br><span class="line">port: 4000 #端口号</span><br><span class="line">server_ip: localhost #IP 地址</span><br><span class="line">logger: false</span><br><span class="line">logger_format: dev</span><br><span class="line"># Date / Time format #日期时间格式</span><br><span class="line">date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"># Pagination #分页</span><br><span class="line">per_page: 10 #每页文章数，设置成 0 禁用分页</span><br><span class="line">pagination_dir: page</span><br><span class="line"># Disqus #Disqus评论，替换为多说</span><br><span class="line">disqus_shortname:</span><br><span class="line"># Extensions #拓展插件</span><br><span class="line">theme: landscape-plus #主题</span><br><span class="line">exclude_generator:</span><br><span class="line">plugins: #插件，例如生成 RSS 和站点地图的</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"># Deployment #部署，将 lmintlcx 改成用户名</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: github创库地址.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>有时候我们部署了以后自己博客的链接打不开,查看生成的静态文件也没有index.html,或者是各种奇怪的报错。这时候有可能是我们的站点配置文件<code>_config.yml</code>格式出现了问题。这时候不妨去一些YAML格式检测网站去检测一下格式是否正确:<a href="http://www.yamllint.com/" target="_blank" rel="noopener">传送门</a>。</p>
<h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>完成上面的操作,你就已经一只脚踏进了<code>hexo</code>的大门,这时的你肯定还有很多疑问,比如博客的头像怎么更换，博客的主题怎么配置等等等等。这里先留下一个悬念,有兴趣的同学可以先行查询一些资料^_^</p>
<hr>
<blockquote>
<p>本文作者： catalinaLi<br>本文链接： <a href="http://catalinali.top/2017/firstBuildHexo/">http://catalinali.top/2017/firstBuildHexo/</a><br>版权声明： 原创文章，有问题请评论中留言。非商业转载请注明作者及出处。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
